diff -ruN freetype-2.7-orig/builds/freetype.mk freetype-2.7/builds/freetype.mk
--- freetype-2.7-orig/builds/freetype.mk	2016-02-03 19:13:58.000000000 +0100
+++ freetype-2.7/builds/freetype.mk	2016-09-09 16:01:22.458500695 +0200
@@ -161,6 +161,7 @@
              $(CFLAGS) \
              $DFT2_BUILD_LIBRARY \
              $DFT_CONFIG_MODULES_H="<ftmodule.h>" \
+			 $D_GNU_SOURCE \
              $(FTOPTION_FLAG)
 
 
diff -ruN freetype-2.7-orig/configure freetype-2.7/configure
--- freetype-2.7-orig/configure	2016-02-03 19:13:58.000000000 +0100
+++ freetype-2.7/configure	2016-09-09 16:01:22.461834056 +0200
@@ -13,6 +13,8 @@
 # Call the `configure' script located in `builds/unix'.
 #
 
+export LDFLAGS="$LDFLAGS -lm"
+
 rm -f config.mk builds/unix/unix-def.mk builds/unix/unix-cc.mk
 
 # respect GNUMAKE environment variable for backwards compatibility
diff -ruN freetype-2.7-orig/devel/ftoption.h freetype-2.7/devel/ftoption.h
--- freetype-2.7-orig/devel/ftoption.h	2016-09-02 08:19:35.000000000 +0200
+++ freetype-2.7/devel/ftoption.h	2016-09-09 16:01:22.461834056 +0200
@@ -626,6 +626,16 @@
   /*                                                                       */
 #define TT_CONFIG_OPTION_BYTECODE_INTERPRETER
 
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define FT_CONFIG_OPTION_INFINALITY_PATCHSET if you want to enable     */
+  /* all additional infinality patches, which are configured via env       */
+  /* variables.                                                            */
+  /*                                                                       */
+  /*   This option requires TT_CONFIG_OPTION_SUBPIXEL_HINTING to           */
+  /*   defined.                                                            */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_INFINALITY_PATCHSET
 
   /*************************************************************************/
   /*                                                                       */
diff -ruN freetype-2.7-orig/devel/ftoption.h.orig freetype-2.7/devel/ftoption.h.orig
--- freetype-2.7-orig/devel/ftoption.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ freetype-2.7/devel/ftoption.h.orig	2016-09-02 08:19:35.000000000 +0200
@@ -0,0 +1,933 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftoption.h (for development)                                           */
+/*                                                                         */
+/*    User-selectable configuration macros (specification only).           */
+/*                                                                         */
+/*  Copyright 1996-2016 by                                                 */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef FTOPTION_H_
+#define FTOPTION_H_
+
+
+#include <ft2build.h>
+
+
+FT_BEGIN_HEADER
+
+  /*************************************************************************/
+  /*                                                                       */
+  /*                 USER-SELECTABLE CONFIGURATION MACROS                  */
+  /*                                                                       */
+  /* This file contains the default configuration macro definitions for    */
+  /* a standard build of the FreeType library.  There are three ways to    */
+  /* use this file to build project-specific versions of the library:      */
+  /*                                                                       */
+  /*  - You can modify this file by hand, but this is not recommended in   */
+  /*    cases where you would like to build several versions of the        */
+  /*    library from a single source directory.                            */
+  /*                                                                       */
+  /*  - You can put a copy of this file in your build directory, more      */
+  /*    precisely in `$BUILD/freetype/config/ftoption.h', where `$BUILD'   */
+  /*    is the name of a directory that is included _before_ the FreeType  */
+  /*    include path during compilation.                                   */
+  /*                                                                       */
+  /*    The default FreeType Makefiles and Jamfiles use the build          */
+  /*    directory `builds/<system>' by default, but you can easily change  */
+  /*    that for your own projects.                                        */
+  /*                                                                       */
+  /*  - Copy the file <ft2build.h> to `$BUILD/ft2build.h' and modify it    */
+  /*    slightly to pre-define the macro FT_CONFIG_OPTIONS_H used to       */
+  /*    locate this file during the build.  For example,                   */
+  /*                                                                       */
+  /*      #define FT_CONFIG_OPTIONS_H  <myftoptions.h>                     */
+  /*      #include <freetype/config/ftheader.h>                            */
+  /*                                                                       */
+  /*    will use `$BUILD/myftoptions.h' instead of this file for macro     */
+  /*    definitions.                                                       */
+  /*                                                                       */
+  /*    Note also that you can similarly pre-define the macro              */
+  /*    FT_CONFIG_MODULES_H used to locate the file listing of the modules */
+  /*    that are statically linked to the library at compile time.  By     */
+  /*    default, this file is <freetype/config/ftmodule.h>.                */
+  /*                                                                       */
+  /* We highly recommend using the third method whenever possible.         */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /**** G E N E R A L   F R E E T Y P E   2   C O N F I G U R A T I O N ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* If you enable this configuration option, FreeType recognizes an       */
+  /* environment variable called `FREETYPE_PROPERTIES', which can be used  */
+  /* to control the various font drivers and modules.  The controllable    */
+  /* properties are listed in the section `Controlling FreeType Modules'   */
+  /* in the reference's table of contents; currently there are properties  */
+  /* for the auto-hinter (file `ftautoh.h'), CFF (file `ftcffdrv.h'), and  */
+  /* TrueType (file `ftttdrv.h').                                          */
+  /*                                                                       */
+  /* `FREETYPE_PROPERTIES' has the following syntax form (broken here into */
+  /* multiple lines for better readability).                               */
+  /*                                                                       */
+  /*   <optional whitespace>                                               */
+  /*   <module-name1> ':'                                                  */
+  /*   <property-name1> '=' <property-value1>                              */
+  /*   <whitespace>                                                        */
+  /*   <module-name2> ':'                                                  */
+  /*   <property-name2> '=' <property-value2>                              */
+  /*   ...                                                                 */
+  /*                                                                       */
+  /* Example:                                                              */
+  /*                                                                       */
+  /*   FREETYPE_PROPERTIES=truetype:interpreter-version=35 \               */
+  /*                       cff:no-stem-darkening=1 \                       */
+  /*                       autofitter:warping=1                            */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_ENVIRONMENT_PROPERTIES
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Uncomment the line below if you want to activate sub-pixel rendering  */
+  /* (a.k.a. LCD rendering, or ClearType) in this build of the library.    */
+  /*                                                                       */
+  /* Note that this feature is covered by several Microsoft patents        */
+  /* and should not be activated in any default build of the library.      */
+  /*                                                                       */
+  /* This macro has no impact on the FreeType API, only on its             */
+  /* _implementation_.  For example, using FT_RENDER_MODE_LCD when calling */
+  /* FT_Render_Glyph still generates a bitmap that is 3 times wider than   */
+  /* the original size in case this macro isn't defined; however, each     */
+  /* triplet of subpixels has R=G=B.                                       */
+  /*                                                                       */
+  /* This is done to allow FreeType clients to run unmodified, forcing     */
+  /* them to display normal gray-level anti-aliased glyphs.                */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_SUBPIXEL_RENDERING
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Many compilers provide a non-ANSI 64-bit data type that can be used   */
+  /* by FreeType to speed up some computations.  However, this will create */
+  /* some problems when compiling the library in strict ANSI mode.         */
+  /*                                                                       */
+  /* For this reason, the use of 64-bit integers is normally disabled when */
+  /* the __STDC__ macro is defined.  You can however disable this by       */
+  /* defining the macro FT_CONFIG_OPTION_FORCE_INT64 here.                 */
+  /*                                                                       */
+  /* For most compilers, this will only create compilation warnings when   */
+  /* building the library.                                                 */
+  /*                                                                       */
+  /* ObNote: The compiler-specific 64-bit integers are detected in the     */
+  /*         file `ftconfig.h' either statically or through the            */
+  /*         `configure' script on supported platforms.                    */
+  /*                                                                       */
+#undef FT_CONFIG_OPTION_FORCE_INT64
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* If this macro is defined, do not try to use an assembler version of   */
+  /* performance-critical functions (e.g. FT_MulFix).  You should only do  */
+  /* that to verify that the assembler function works properly, or to      */
+  /* execute benchmark tests of the various implementations.               */
+/* #define FT_CONFIG_OPTION_NO_ASSEMBLER */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* If this macro is defined, try to use an inlined assembler version of  */
+  /* the `FT_MulFix' function, which is a `hotspot' when loading and       */
+  /* hinting glyphs, and which should be executed as fast as possible.     */
+  /*                                                                       */
+  /* Note that if your compiler or CPU is not supported, this will default */
+  /* to the standard and portable implementation found in `ftcalc.c'.      */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_INLINE_MULFIX
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* LZW-compressed file support.                                          */
+  /*                                                                       */
+  /*   FreeType now handles font files that have been compressed with the  */
+  /*   `compress' program.  This is mostly used to parse many of the PCF   */
+  /*   files that come with various X11 distributions.  The implementation */
+  /*   uses NetBSD's `zopen' to partially uncompress the file on the fly   */
+  /*   (see src/lzw/ftgzip.c).                                             */
+  /*                                                                       */
+  /*   Define this macro if you want to enable this `feature'.             */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_USE_LZW
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Gzip-compressed file support.                                         */
+  /*                                                                       */
+  /*   FreeType now handles font files that have been compressed with the  */
+  /*   `gzip' program.  This is mostly used to parse many of the PCF files */
+  /*   that come with XFree86.  The implementation uses `zlib' to          */
+  /*   partially uncompress the file on the fly (see src/gzip/ftgzip.c).   */
+  /*                                                                       */
+  /*   Define this macro if you want to enable this `feature'.  See also   */
+  /*   the macro FT_CONFIG_OPTION_SYSTEM_ZLIB below.                       */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_USE_ZLIB
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* ZLib library selection                                                */
+  /*                                                                       */
+  /*   This macro is only used when FT_CONFIG_OPTION_USE_ZLIB is defined.  */
+  /*   It allows FreeType's `ftgzip' component to link to the system's     */
+  /*   installation of the ZLib library.  This is useful on systems like   */
+  /*   Unix or VMS where it generally is already available.                */
+  /*                                                                       */
+  /*   If you let it undefined, the component will use its own copy        */
+  /*   of the zlib sources instead.  These have been modified to be        */
+  /*   included directly within the component and *not* export external    */
+  /*   function names.  This allows you to link any program with FreeType  */
+  /*   _and_ ZLib without linking conflicts.                               */
+  /*                                                                       */
+  /*   Do not #undef this macro here since the build system might define   */
+  /*   it for certain configurations only.                                 */
+  /*                                                                       */
+/* #define FT_CONFIG_OPTION_SYSTEM_ZLIB */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Bzip2-compressed file support.                                        */
+  /*                                                                       */
+  /*   FreeType now handles font files that have been compressed with the  */
+  /*   `bzip2' program.  This is mostly used to parse many of the PCF      */
+  /*   files that come with XFree86.  The implementation uses `libbz2' to  */
+  /*   partially uncompress the file on the fly (see src/bzip2/ftbzip2.c). */
+  /*   Contrary to gzip, bzip2 currently is not included and need to use   */
+  /*   the system available bzip2 implementation.                          */
+  /*                                                                       */
+  /*   Define this macro if you want to enable this `feature'.             */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_USE_BZIP2
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define to disable the use of file stream functions and types, FILE,   */
+  /* fopen() etc.  Enables the use of smaller system libraries on embedded */
+  /* systems that have multiple system libraries, some with or without     */
+  /* file stream support, in the cases where file stream support is not    */
+  /* necessary such as memory loading of font files.                       */
+  /*                                                                       */
+/* #define FT_CONFIG_OPTION_DISABLE_STREAM_SUPPORT */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* PNG bitmap support.                                                   */
+  /*                                                                       */
+  /*   FreeType now handles loading color bitmap glyphs in the PNG format. */
+  /*   This requires help from the external libpng library.  Uncompressed  */
+  /*   color bitmaps do not need any external libraries and will be        */
+  /*   supported regardless of this configuration.                         */
+  /*                                                                       */
+  /*   Define this macro if you want to enable this `feature'.             */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_USE_PNG
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* HarfBuzz support.                                                     */
+  /*                                                                       */
+  /*   FreeType uses the HarfBuzz library to improve auto-hinting of       */
+  /*   OpenType fonts.  If available, many glyphs not directly addressable */
+  /*   by a font's character map will be hinted also.                      */
+  /*                                                                       */
+  /*   Define this macro if you want to enable this `feature'.             */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_USE_HARFBUZZ
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* DLL export compilation                                                */
+  /*                                                                       */
+  /*   When compiling FreeType as a DLL, some systems/compilers need a     */
+  /*   special keyword in front OR after the return type of function       */
+  /*   declarations.                                                       */
+  /*                                                                       */
+  /*   Two macros are used within the FreeType source code to define       */
+  /*   exported library functions: FT_EXPORT and FT_EXPORT_DEF.            */
+  /*                                                                       */
+  /*     FT_EXPORT( return_type )                                          */
+  /*                                                                       */
+  /*       is used in a function declaration, as in                        */
+  /*                                                                       */
+  /*         FT_EXPORT( FT_Error )                                         */
+  /*         FT_Init_FreeType( FT_Library*  alibrary );                    */
+  /*                                                                       */
+  /*                                                                       */
+  /*     FT_EXPORT_DEF( return_type )                                      */
+  /*                                                                       */
+  /*       is used in a function definition, as in                         */
+  /*                                                                       */
+  /*         FT_EXPORT_DEF( FT_Error )                                     */
+  /*         FT_Init_FreeType( FT_Library*  alibrary )                     */
+  /*         {                                                             */
+  /*           ... some code ...                                           */
+  /*           return FT_Err_Ok;                                           */
+  /*         }                                                             */
+  /*                                                                       */
+  /*   You can provide your own implementation of FT_EXPORT and            */
+  /*   FT_EXPORT_DEF here if you want.  If you leave them undefined, they  */
+  /*   will be later automatically defined as `extern return_type' to      */
+  /*   allow normal compilation.                                           */
+  /*                                                                       */
+  /*   Do not #undef these macros here since the build system might define */
+  /*   them for certain configurations only.                               */
+  /*                                                                       */
+/* #define FT_EXPORT(x)      extern x */
+/* #define FT_EXPORT_DEF(x)  x */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Glyph Postscript Names handling                                       */
+  /*                                                                       */
+  /*   By default, FreeType 2 is compiled with the `psnames' module.  This */
+  /*   module is in charge of converting a glyph name string into a        */
+  /*   Unicode value, or return a Macintosh standard glyph name for the    */
+  /*   use with the TrueType `post' table.                                 */
+  /*                                                                       */
+  /*   Undefine this macro if you do not want `psnames' compiled in your   */
+  /*   build of FreeType.  This has the following effects:                 */
+  /*                                                                       */
+  /*   - The TrueType driver will provide its own set of glyph names,      */
+  /*     if you build it to support postscript names in the TrueType       */
+  /*     `post' table.                                                     */
+  /*                                                                       */
+  /*   - The Type 1 driver will not be able to synthesize a Unicode        */
+  /*     charmap out of the glyphs found in the fonts.                     */
+  /*                                                                       */
+  /*   You would normally undefine this configuration macro when building  */
+  /*   a version of FreeType that doesn't contain a Type 1 or CFF driver.  */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_POSTSCRIPT_NAMES
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Postscript Names to Unicode Values support                            */
+  /*                                                                       */
+  /*   By default, FreeType 2 is built with the `PSNames' module compiled  */
+  /*   in.  Among other things, the module is used to convert a glyph name */
+  /*   into a Unicode value.  This is especially useful in order to        */
+  /*   synthesize on the fly a Unicode charmap from the CFF/Type 1 driver  */
+  /*   through a big table named the `Adobe Glyph List' (AGL).             */
+  /*                                                                       */
+  /*   Undefine this macro if you do not want the Adobe Glyph List         */
+  /*   compiled in your `PSNames' module.  The Type 1 driver will not be   */
+  /*   able to synthesize a Unicode charmap out of the glyphs found in the */
+  /*   fonts.                                                              */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_ADOBE_GLYPH_LIST
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Support for Mac fonts                                                 */
+  /*                                                                       */
+  /*   Define this macro if you want support for outline fonts in Mac      */
+  /*   format (mac dfont, mac resource, macbinary containing a mac         */
+  /*   resource) on non-Mac platforms.                                     */
+  /*                                                                       */
+  /*   Note that the `FOND' resource isn't checked.                        */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_MAC_FONTS
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Guessing methods to access embedded resource forks                    */
+  /*                                                                       */
+  /*   Enable extra Mac fonts support on non-Mac platforms (e.g.           */
+  /*   GNU/Linux).                                                         */
+  /*                                                                       */
+  /*   Resource forks which include fonts data are stored sometimes in     */
+  /*   locations which users or developers don't expected.  In some cases, */
+  /*   resource forks start with some offset from the head of a file.  In  */
+  /*   other cases, the actual resource fork is stored in file different   */
+  /*   from what the user specifies.  If this option is activated,         */
+  /*   FreeType tries to guess whether such offsets or different file      */
+  /*   names must be used.                                                 */
+  /*                                                                       */
+  /*   Note that normal, direct access of resource forks is controlled via */
+  /*   the FT_CONFIG_OPTION_MAC_FONTS option.                              */
+  /*                                                                       */
+#ifdef FT_CONFIG_OPTION_MAC_FONTS
+#define FT_CONFIG_OPTION_GUESSING_EMBEDDED_RFORK
+#endif
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Allow the use of FT_Incremental_Interface to load typefaces that      */
+  /* contain no glyph data, but supply it via a callback function.         */
+  /* This is required by clients supporting document formats which         */
+  /* supply font data incrementally as the document is parsed, such        */
+  /* as the Ghostscript interpreter for the PostScript language.           */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_INCREMENTAL
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* The size in bytes of the render pool used by the scan-line converter  */
+  /* to do all of its work.                                                */
+  /*                                                                       */
+#define FT_RENDER_POOL_SIZE  16384L
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* FT_MAX_MODULES                                                        */
+  /*                                                                       */
+  /*   The maximum number of modules that can be registered in a single    */
+  /*   FreeType library object.  32 is the default.                        */
+  /*                                                                       */
+#define FT_MAX_MODULES  32
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Debug level                                                           */
+  /*                                                                       */
+  /*   FreeType can be compiled in debug or trace mode.  In debug mode,    */
+  /*   errors are reported through the `ftdebug' component.  In trace      */
+  /*   mode, additional messages are sent to the standard output during    */
+  /*   execution.                                                          */
+  /*                                                                       */
+  /*   Define FT_DEBUG_LEVEL_ERROR to build the library in debug mode.     */
+  /*   Define FT_DEBUG_LEVEL_TRACE to build it in trace mode.              */
+  /*                                                                       */
+  /*   Don't define any of these macros to compile in `release' mode!      */
+  /*                                                                       */
+  /*   Do not #undef these macros here since the build system might define */
+  /*   them for certain configurations only.                               */
+  /*                                                                       */
+#define FT_DEBUG_LEVEL_ERROR
+#define FT_DEBUG_LEVEL_TRACE
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Autofitter debugging                                                  */
+  /*                                                                       */
+  /*   If FT_DEBUG_AUTOFIT is defined, FreeType provides some means to     */
+  /*   control the autofitter behaviour for debugging purposes with global */
+  /*   boolean variables (consequently, you should *never* enable this     */
+  /*   while compiling in `release' mode):                                 */
+  /*                                                                       */
+  /*     _af_debug_disable_horz_hints                                      */
+  /*     _af_debug_disable_vert_hints                                      */
+  /*     _af_debug_disable_blue_hints                                      */
+  /*                                                                       */
+  /*   Additionally, the following functions provide dumps of various      */
+  /*   internal autofit structures to stdout (using `printf'):             */
+  /*                                                                       */
+  /*     af_glyph_hints_dump_points                                        */
+  /*     af_glyph_hints_dump_segments                                      */
+  /*     af_glyph_hints_dump_edges                                         */
+  /*     af_glyph_hints_get_num_segments                                   */
+  /*     af_glyph_hints_get_segment_offset                                 */
+  /*                                                                       */
+  /*   As an argument, they use another global variable:                   */
+  /*                                                                       */
+  /*     _af_debug_hints                                                   */
+  /*                                                                       */
+  /*   Please have a look at the `ftgrid' demo program to see how those    */
+  /*   variables and macros should be used.                                */
+  /*                                                                       */
+  /*   Do not #undef these macros here since the build system might define */
+  /*   them for certain configurations only.                               */
+  /*                                                                       */
+#define FT_DEBUG_AUTOFIT
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Memory Debugging                                                      */
+  /*                                                                       */
+  /*   FreeType now comes with an integrated memory debugger that is       */
+  /*   capable of detecting simple errors like memory leaks or double      */
+  /*   deletes.  To compile it within your build of the library, you       */
+  /*   should define FT_DEBUG_MEMORY here.                                 */
+  /*                                                                       */
+  /*   Note that the memory debugger is only activated at runtime when     */
+  /*   when the _environment_ variable `FT2_DEBUG_MEMORY' is defined also! */
+  /*                                                                       */
+  /*   Do not #undef this macro here since the build system might define   */
+  /*   it for certain configurations only.                                 */
+  /*                                                                       */
+#define FT_DEBUG_MEMORY
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Module errors                                                         */
+  /*                                                                       */
+  /*   If this macro is set (which is _not_ the default), the higher byte  */
+  /*   of an error code gives the module in which the error has occurred,  */
+  /*   while the lower byte is the real error code.                        */
+  /*                                                                       */
+  /*   Setting this macro makes sense for debugging purposes only, since   */
+  /*   it would break source compatibility of certain programs that use    */
+  /*   FreeType 2.                                                         */
+  /*                                                                       */
+  /*   More details can be found in the files ftmoderr.h and fterrors.h.   */
+  /*                                                                       */
+#undef FT_CONFIG_OPTION_USE_MODULE_ERRORS
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Position Independent Code                                             */
+  /*                                                                       */
+  /*   If this macro is set (which is _not_ the default), FreeType2 will   */
+  /*   avoid creating constants that require address fixups.  Instead the  */
+  /*   constants will be moved into a struct and additional intialization  */
+  /*   code will be used.                                                  */
+  /*                                                                       */
+  /*   Setting this macro is needed for systems that prohibit address      */
+  /*   fixups, such as BREW.  [Note that standard compilers like gcc or    */
+  /*   clang handle PIC generation automatically; you don't have to set    */
+  /*   FT_CONFIG_OPTION_PIC, which is only necessary for very special      */
+  /*   compilers.]                                                         */
+  /*                                                                       */
+  /*   Note that FT_CONFIG_OPTION_PIC support is not available for all     */
+  /*   modules (see `modules.cfg' for a complete list).  For building with */
+  /*   FT_CONFIG_OPTION_PIC support, do the following.                     */
+  /*                                                                       */
+  /*     0. Clone the repository.                                          */
+  /*     1. Define FT_CONFIG_OPTION_PIC.                                   */
+  /*     2. Remove all subdirectories in `src' that don't have             */
+  /*        FT_CONFIG_OPTION_PIC support.                                  */
+  /*     3. Comment out the corresponding modules in `modules.cfg'.        */
+  /*     4. Compile.                                                       */
+  /*                                                                       */
+/* #define FT_CONFIG_OPTION_PIC */
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****        S F N T   D R I V E R    C O N F I G U R A T I O N       ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_EMBEDDED_BITMAPS if you want to support       */
+  /* embedded bitmaps in all formats using the SFNT module (namely         */
+  /* TrueType & OpenType).                                                 */
+  /*                                                                       */
+#define TT_CONFIG_OPTION_EMBEDDED_BITMAPS
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_POSTSCRIPT_NAMES if you want to be able to    */
+  /* load and enumerate the glyph Postscript names in a TrueType or        */
+  /* OpenType file.                                                        */
+  /*                                                                       */
+  /* Note that when you do not compile the `PSNames' module by undefining  */
+  /* the above FT_CONFIG_OPTION_POSTSCRIPT_NAMES, the `sfnt' module will   */
+  /* contain additional code used to read the PS Names table from a font.  */
+  /*                                                                       */
+  /* (By default, the module uses `PSNames' to extract glyph names.)       */
+  /*                                                                       */
+#define TT_CONFIG_OPTION_POSTSCRIPT_NAMES
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_SFNT_NAMES if your applications need to       */
+  /* access the internal name table in a SFNT-based format like TrueType   */
+  /* or OpenType.  The name table contains various strings used to         */
+  /* describe the font, like family name, copyright, version, etc.  It     */
+  /* does not contain any glyph name though.                               */
+  /*                                                                       */
+  /* Accessing SFNT names is done through the functions declared in        */
+  /* `ftsnames.h'.                                                         */
+  /*                                                                       */
+#define TT_CONFIG_OPTION_SFNT_NAMES
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* TrueType CMap support                                                 */
+  /*                                                                       */
+  /*   Here you can fine-tune which TrueType CMap table format shall be    */
+  /*   supported.                                                          */
+#define TT_CONFIG_CMAP_FORMAT_0
+#define TT_CONFIG_CMAP_FORMAT_2
+#define TT_CONFIG_CMAP_FORMAT_4
+#define TT_CONFIG_CMAP_FORMAT_6
+#define TT_CONFIG_CMAP_FORMAT_8
+#define TT_CONFIG_CMAP_FORMAT_10
+#define TT_CONFIG_CMAP_FORMAT_12
+#define TT_CONFIG_CMAP_FORMAT_13
+#define TT_CONFIG_CMAP_FORMAT_14
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****    T R U E T Y P E   D R I V E R    C O N F I G U R A T I O N   ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_BYTECODE_INTERPRETER if you want to compile   */
+  /* a bytecode interpreter in the TrueType driver.                        */
+  /*                                                                       */
+  /* By undefining this, you will only compile the code necessary to load  */
+  /* TrueType glyphs without hinting.                                      */
+  /*                                                                       */
+  /*   Do not #undef this macro here, since the build system might         */
+  /*   define it for certain configurations only.                          */
+  /*                                                                       */
+#define TT_CONFIG_OPTION_BYTECODE_INTERPRETER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_SUBPIXEL_HINTING if you want to compile       */
+  /* subpixel hinting support into the TrueType driver.  This modifies the */
+  /* TrueType hinting mechanism when anything but FT_RENDER_MODE_MONO is   */
+  /* requested.                                                            */
+  /*                                                                       */
+  /* In particular, it modifies the bytecode interpreter to interpret (or  */
+  /* not) instructions in a certain way so that all TrueType fonts look    */
+  /* like they do in a Windows ClearType (DirectWrite) environment.  See   */
+  /* [1] for a technical overview on what this means.  See `ttinterp.h'    */
+  /* for more details on the LEAN option.                                  */
+  /*                                                                       */
+  /* There are three options.                                              */
+  /*                                                                       */
+  /* 1. This option is associated with the `Infinality' moniker.           */
+  /*    Contributed by an individual nicknamed Infinality with the goal of */
+  /*    making TrueType fonts render better than on Windows.  A high       */
+  /*    amount of configurability and flexibility, down to rules for       */
+  /*    single glyphs in fonts, but also very slow.  Its experimental and  */
+  /*    slow nature and the original developer losing interest meant that  */
+  /*    this option was never enabled in default builds.                   */
+  /*                                                                       */
+  /* 2. The new default mode for the TrueType driver.  The Infinality code */
+  /*    base was stripped to the bare minimum and all configurability      */
+  /*    removed in the name of speed and simplicity.  The configurability  */
+  /*    was mainly aimed at legacy fonts like Arial, Times New Roman, or   */
+  /*    Courier.  Legacy fonts are fonts that modify vertical stems to     */
+  /*    achieve clean black-and-white bitmaps.  The new mode focuses on    */
+  /*    applying a minimal set of rules to all fonts indiscriminately so   */
+  /*    that modern and web fonts render well while legacy fonts render    */
+  /*    okay.                                                              */
+  /*                                                                       */
+  /* 3. Compile both.                                                      */
+  /*                                                                       */
+  /* By undefining these, you get rendering behavior like on Windows       */
+  /* without ClearType, i.e., Windows XP without ClearType enabled and     */
+  /* Win9x (interpreter version v35).  Or not, depending on how much       */
+  /* hinting blood and testing tears the font designer put into a given    */
+  /* font.  If you define one or both subpixel hinting options, you can    */
+  /* switch between between v35 and the ones you define.                   */
+  /*                                                                       */
+  /* This option requires TT_CONFIG_OPTION_BYTECODE_INTERPRETER to be      */
+  /* defined.                                                              */
+  /*                                                                       */
+  /* [1] http://www.microsoft.com/typography/cleartype/truetypecleartype.aspx */
+  /*                                                                       */
+/* #define TT_CONFIG_OPTION_SUBPIXEL_HINTING  1     */
+/* #define TT_CONFIG_OPTION_SUBPIXEL_HINTING  2     */
+#define TT_CONFIG_OPTION_SUBPIXEL_HINTING     ( 1 | 2 )
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED to compile the        */
+  /* TrueType glyph loader to use Apple's definition of how to handle      */
+  /* component offsets in composite glyphs.                                */
+  /*                                                                       */
+  /* Apple and MS disagree on the default behavior of component offsets    */
+  /* in composites.  Apple says that they should be scaled by the scaling  */
+  /* factors in the transformation matrix (roughly, it's more complex)     */
+  /* while MS says they should not.  OpenType defines two bits in the      */
+  /* composite flags array which can be used to disambiguate, but old      */
+  /* fonts will not have them.                                             */
+  /*                                                                       */
+  /*   http://www.microsoft.com/typography/otspec/glyf.htm                 */
+  /*   https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6glyf.html */
+  /*                                                                       */
+#undef TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_GX_VAR_SUPPORT if you want to include         */
+  /* support for Apple's distortable font technology (fvar, gvar, cvar,    */
+  /* and avar tables).  This has many similarities to Type 1 Multiple      */
+  /* Masters support.                                                      */
+  /*                                                                       */
+#define TT_CONFIG_OPTION_GX_VAR_SUPPORT
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_BDF if you want to include support for        */
+  /* an embedded `BDF ' table within SFNT-based bitmap formats.            */
+  /*                                                                       */
+#define TT_CONFIG_OPTION_BDF
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Option TT_CONFIG_OPTION_MAX_RUNNABLE_OPCODES controls the maximum     */
+  /* number of bytecode instructions executed for a single run of the      */
+  /* bytecode interpreter, needed to prevent infinite loops.  You don't    */
+  /* want to change this except for very special situations (e.g., making  */
+  /* a library fuzzer spend less time to handle broken fonts).             */
+  /*                                                                       */
+  /* It is not expected that this value is ever modified by a configuring  */
+  /* script; instead, it gets surrounded with #ifndef ... #endif so that   */
+  /* the value can be set as a preprocessor option on the compiler's       */
+  /* command line.                                                         */
+  /*                                                                       */
+#ifndef TT_CONFIG_OPTION_MAX_RUNNABLE_OPCODES
+#define TT_CONFIG_OPTION_MAX_RUNNABLE_OPCODES  1000000L
+#endif
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****      T Y P E 1   D R I V E R    C O N F I G U R A T I O N       ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* T1_MAX_DICT_DEPTH is the maximum depth of nest dictionaries and       */
+  /* arrays in the Type 1 stream (see t1load.c).  A minimum of 4 is        */
+  /* required.                                                             */
+  /*                                                                       */
+#define T1_MAX_DICT_DEPTH  5
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* T1_MAX_SUBRS_CALLS details the maximum number of nested sub-routine   */
+  /* calls during glyph loading.                                           */
+  /*                                                                       */
+#define T1_MAX_SUBRS_CALLS  16
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* T1_MAX_CHARSTRING_OPERANDS is the charstring stack's capacity.  A     */
+  /* minimum of 16 is required.                                            */
+  /*                                                                       */
+  /* The Chinese font MingTiEG-Medium (CNS 11643 character set) needs 256. */
+  /*                                                                       */
+#define T1_MAX_CHARSTRINGS_OPERANDS  256
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define this configuration macro if you want to prevent the            */
+  /* compilation of `t1afm', which is in charge of reading Type 1 AFM      */
+  /* files into an existing face.  Note that if set, the T1 driver will be */
+  /* unable to produce kerning distances.                                  */
+  /*                                                                       */
+#undef T1_CONFIG_OPTION_NO_AFM
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define this configuration macro if you want to prevent the            */
+  /* compilation of the Multiple Masters font support in the Type 1        */
+  /* driver.                                                               */
+  /*                                                                       */
+#undef T1_CONFIG_OPTION_NO_MM_SUPPORT
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****         C F F   D R I V E R    C O N F I G U R A T I O N        ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Using CFF_CONFIG_OPTION_DARKENING_PARAMETER_{X,Y}{1,2,3,4} it is      */
+  /* possible to set up the default values of the four control points that */
+  /* define the stem darkening behaviour of the (new) CFF engine.  For     */
+  /* more details please read the documentation of the                     */
+  /* `darkening-parameters' property of the cff driver module (file        */
+  /* `ftcffdrv.h'), which allows the control at run-time.                  */
+  /*                                                                       */
+  /* Do *not* undefine these macros!                                       */
+  /*                                                                       */
+#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1   500
+#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y1   400
+
+#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2  1000
+#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y2   275
+
+#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_X3  1667
+#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y3   275
+
+#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_X4  2333
+#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y4     0
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* CFF_CONFIG_OPTION_OLD_ENGINE controls whether the pre-Adobe CFF       */
+  /* engine gets compiled into FreeType.  If defined, it is possible to    */
+  /* switch between the two engines using the `hinting-engine' property of */
+  /* the cff driver module.                                                */
+  /*                                                                       */
+#define CFF_CONFIG_OPTION_OLD_ENGINE
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****    A U T O F I T   M O D U L E    C O N F I G U R A T I O N     ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Compile autofit module with CJK (Chinese, Japanese, Korean) script    */
+  /* support.                                                              */
+  /*                                                                       */
+#define AF_CONFIG_OPTION_CJK
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Compile autofit module with Indic script support.                     */
+  /*                                                                       */
+#define AF_CONFIG_OPTION_INDIC
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Compile autofit module with warp hinting.  The idea of the warping    */
+  /* code is to slightly scale and shift a glyph within a single dimension */
+  /* so that as much of its segments are aligned (more or less) on the     */
+  /* grid.  To find out the optimal scaling and shifting value, various    */
+  /* parameter combinations are tried and scored.                          */
+  /*                                                                       */
+  /* This experimental option is active only if the rendering mode is      */
+  /* FT_RENDER_MODE_LIGHT; you can switch warping on and off with the      */
+  /* `warping' property of the auto-hinter (see file `ftautoh.h' for more  */
+  /* information; by default it is switched off).                          */
+  /*                                                                       */
+#define AF_CONFIG_OPTION_USE_WARPER
+
+  /* */
+
+
+  /*
+   * This macro is obsolete.  Support has been removed in FreeType
+   * version 2.5.
+   */
+/* #define FT_CONFIG_OPTION_OLD_INTERNALS */
+
+
+  /*
+   * This macro is defined if native TrueType hinting is requested by the
+   * definitions above.
+   */
+#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
+#define  TT_USE_BYTECODE_INTERPRETER
+
+#if TT_CONFIG_OPTION_SUBPIXEL_HINTING & 1
+#define  TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+#endif
+
+#if TT_CONFIG_OPTION_SUBPIXEL_HINTING & 2
+#define  TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
+#endif
+#endif
+
+
+  /*
+   * Check CFF darkening parameters.  The checks are the same as in function
+   * `cff_property_set' in file `cffdrivr.c'.
+   */
+#if CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1 < 0   || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2 < 0   || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_X3 < 0   || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_X4 < 0   || \
+                                                      \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y1 < 0   || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y2 < 0   || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y3 < 0   || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y4 < 0   || \
+                                                      \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1 >        \
+      CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2     || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2 >        \
+      CFF_CONFIG_OPTION_DARKENING_PARAMETER_X3     || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_X3 >        \
+      CFF_CONFIG_OPTION_DARKENING_PARAMETER_X4     || \
+                                                      \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y1 > 500 || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y2 > 500 || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y3 > 500 || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y4 > 500
+#error "Invalid CFF darkening parameters!"
+#endif
+
+FT_END_HEADER
+
+
+#endif /* FTOPTION_H_ */
+
+
+/* END */
diff -ruN freetype-2.7-orig/include/freetype/config/ftoption.h freetype-2.7/include/freetype/config/ftoption.h
--- freetype-2.7-orig/include/freetype/config/ftoption.h	2016-09-02 07:47:15.000000000 +0200
+++ freetype-2.7/include/freetype/config/ftoption.h	2016-09-09 16:03:06.759343564 +0200
@@ -122,7 +122,7 @@
   /* This is done to allow FreeType clients to run unmodified, forcing     */
   /* them to display normal gray-level anti-aliased glyphs.                */
   /*                                                                       */
-/* #define FT_CONFIG_OPTION_SUBPIXEL_RENDERING */
+#define FT_CONFIG_OPTION_SUBPIXEL_RENDERING
 
 
   /*************************************************************************/
@@ -675,7 +675,7 @@
   /* [1] http://www.microsoft.com/typography/cleartype/truetypecleartype.aspx */
   /*                                                                       */
 /* #define TT_CONFIG_OPTION_SUBPIXEL_HINTING  1         */
-#define TT_CONFIG_OPTION_SUBPIXEL_HINTING  2
+#define TT_CONFIG_OPTION_SUBPIXEL_HINTING  1
 /* #define TT_CONFIG_OPTION_SUBPIXEL_HINTING  ( 1 | 2 ) */
 
 
diff -ruN freetype-2.7-orig/include/freetype/config/ftoption.h.orig freetype-2.7/include/freetype/config/ftoption.h.orig
--- freetype-2.7-orig/include/freetype/config/ftoption.h.orig	1970-01-01 01:00:00.000000000 +0100
+++ freetype-2.7/include/freetype/config/ftoption.h.orig	2016-09-02 07:47:15.000000000 +0200
@@ -0,0 +1,933 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftoption.h                                                             */
+/*                                                                         */
+/*    User-selectable configuration macros (specification only).           */
+/*                                                                         */
+/*  Copyright 1996-2016 by                                                 */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef FTOPTION_H_
+#define FTOPTION_H_
+
+
+#include <ft2build.h>
+
+
+FT_BEGIN_HEADER
+
+  /*************************************************************************/
+  /*                                                                       */
+  /*                 USER-SELECTABLE CONFIGURATION MACROS                  */
+  /*                                                                       */
+  /* This file contains the default configuration macro definitions for    */
+  /* a standard build of the FreeType library.  There are three ways to    */
+  /* use this file to build project-specific versions of the library:      */
+  /*                                                                       */
+  /*  - You can modify this file by hand, but this is not recommended in   */
+  /*    cases where you would like to build several versions of the        */
+  /*    library from a single source directory.                            */
+  /*                                                                       */
+  /*  - You can put a copy of this file in your build directory, more      */
+  /*    precisely in `$BUILD/freetype/config/ftoption.h', where `$BUILD'   */
+  /*    is the name of a directory that is included _before_ the FreeType  */
+  /*    include path during compilation.                                   */
+  /*                                                                       */
+  /*    The default FreeType Makefiles and Jamfiles use the build          */
+  /*    directory `builds/<system>' by default, but you can easily change  */
+  /*    that for your own projects.                                        */
+  /*                                                                       */
+  /*  - Copy the file <ft2build.h> to `$BUILD/ft2build.h' and modify it    */
+  /*    slightly to pre-define the macro FT_CONFIG_OPTIONS_H used to       */
+  /*    locate this file during the build.  For example,                   */
+  /*                                                                       */
+  /*      #define FT_CONFIG_OPTIONS_H  <myftoptions.h>                     */
+  /*      #include <freetype/config/ftheader.h>                            */
+  /*                                                                       */
+  /*    will use `$BUILD/myftoptions.h' instead of this file for macro     */
+  /*    definitions.                                                       */
+  /*                                                                       */
+  /*    Note also that you can similarly pre-define the macro              */
+  /*    FT_CONFIG_MODULES_H used to locate the file listing of the modules */
+  /*    that are statically linked to the library at compile time.  By     */
+  /*    default, this file is <freetype/config/ftmodule.h>.                */
+  /*                                                                       */
+  /* We highly recommend using the third method whenever possible.         */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /**** G E N E R A L   F R E E T Y P E   2   C O N F I G U R A T I O N ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* If you enable this configuration option, FreeType recognizes an       */
+  /* environment variable called `FREETYPE_PROPERTIES', which can be used  */
+  /* to control the various font drivers and modules.  The controllable    */
+  /* properties are listed in the section `Controlling FreeType Modules'   */
+  /* in the reference's table of contents; currently there are properties  */
+  /* for the auto-hinter (file `ftautoh.h'), CFF (file `ftcffdrv.h'), and  */
+  /* TrueType (file `ftttdrv.h').                                          */
+  /*                                                                       */
+  /* `FREETYPE_PROPERTIES' has the following syntax form (broken here into */
+  /* multiple lines for better readability).                               */
+  /*                                                                       */
+  /*   <optional whitespace>                                               */
+  /*   <module-name1> ':'                                                  */
+  /*   <property-name1> '=' <property-value1>                              */
+  /*   <whitespace>                                                        */
+  /*   <module-name2> ':'                                                  */
+  /*   <property-name2> '=' <property-value2>                              */
+  /*   ...                                                                 */
+  /*                                                                       */
+  /* Example:                                                              */
+  /*                                                                       */
+  /*   FREETYPE_PROPERTIES=truetype:interpreter-version=35 \               */
+  /*                       cff:no-stem-darkening=1 \                       */
+  /*                       autofitter:warping=1                            */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_ENVIRONMENT_PROPERTIES
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Uncomment the line below if you want to activate sub-pixel rendering  */
+  /* (a.k.a. LCD rendering, or ClearType) in this build of the library.    */
+  /*                                                                       */
+  /* Note that this feature is covered by several Microsoft patents        */
+  /* and should not be activated in any default build of the library.      */
+  /*                                                                       */
+  /* This macro has no impact on the FreeType API, only on its             */
+  /* _implementation_.  For example, using FT_RENDER_MODE_LCD when calling */
+  /* FT_Render_Glyph still generates a bitmap that is 3 times wider than   */
+  /* the original size in case this macro isn't defined; however, each     */
+  /* triplet of subpixels has R=G=B.                                       */
+  /*                                                                       */
+  /* This is done to allow FreeType clients to run unmodified, forcing     */
+  /* them to display normal gray-level anti-aliased glyphs.                */
+  /*                                                                       */
+/* #define FT_CONFIG_OPTION_SUBPIXEL_RENDERING */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Many compilers provide a non-ANSI 64-bit data type that can be used   */
+  /* by FreeType to speed up some computations.  However, this will create */
+  /* some problems when compiling the library in strict ANSI mode.         */
+  /*                                                                       */
+  /* For this reason, the use of 64-bit integers is normally disabled when */
+  /* the __STDC__ macro is defined.  You can however disable this by       */
+  /* defining the macro FT_CONFIG_OPTION_FORCE_INT64 here.                 */
+  /*                                                                       */
+  /* For most compilers, this will only create compilation warnings when   */
+  /* building the library.                                                 */
+  /*                                                                       */
+  /* ObNote: The compiler-specific 64-bit integers are detected in the     */
+  /*         file `ftconfig.h' either statically or through the            */
+  /*         `configure' script on supported platforms.                    */
+  /*                                                                       */
+#undef FT_CONFIG_OPTION_FORCE_INT64
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* If this macro is defined, do not try to use an assembler version of   */
+  /* performance-critical functions (e.g. FT_MulFix).  You should only do  */
+  /* that to verify that the assembler function works properly, or to      */
+  /* execute benchmark tests of the various implementations.               */
+/* #define FT_CONFIG_OPTION_NO_ASSEMBLER */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* If this macro is defined, try to use an inlined assembler version of  */
+  /* the `FT_MulFix' function, which is a `hotspot' when loading and       */
+  /* hinting glyphs, and which should be executed as fast as possible.     */
+  /*                                                                       */
+  /* Note that if your compiler or CPU is not supported, this will default */
+  /* to the standard and portable implementation found in `ftcalc.c'.      */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_INLINE_MULFIX
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* LZW-compressed file support.                                          */
+  /*                                                                       */
+  /*   FreeType now handles font files that have been compressed with the  */
+  /*   `compress' program.  This is mostly used to parse many of the PCF   */
+  /*   files that come with various X11 distributions.  The implementation */
+  /*   uses NetBSD's `zopen' to partially uncompress the file on the fly   */
+  /*   (see src/lzw/ftgzip.c).                                             */
+  /*                                                                       */
+  /*   Define this macro if you want to enable this `feature'.             */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_USE_LZW
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Gzip-compressed file support.                                         */
+  /*                                                                       */
+  /*   FreeType now handles font files that have been compressed with the  */
+  /*   `gzip' program.  This is mostly used to parse many of the PCF files */
+  /*   that come with XFree86.  The implementation uses `zlib' to          */
+  /*   partially uncompress the file on the fly (see src/gzip/ftgzip.c).   */
+  /*                                                                       */
+  /*   Define this macro if you want to enable this `feature'.  See also   */
+  /*   the macro FT_CONFIG_OPTION_SYSTEM_ZLIB below.                       */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_USE_ZLIB
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* ZLib library selection                                                */
+  /*                                                                       */
+  /*   This macro is only used when FT_CONFIG_OPTION_USE_ZLIB is defined.  */
+  /*   It allows FreeType's `ftgzip' component to link to the system's     */
+  /*   installation of the ZLib library.  This is useful on systems like   */
+  /*   Unix or VMS where it generally is already available.                */
+  /*                                                                       */
+  /*   If you let it undefined, the component will use its own copy        */
+  /*   of the zlib sources instead.  These have been modified to be        */
+  /*   included directly within the component and *not* export external    */
+  /*   function names.  This allows you to link any program with FreeType  */
+  /*   _and_ ZLib without linking conflicts.                               */
+  /*                                                                       */
+  /*   Do not #undef this macro here since the build system might define   */
+  /*   it for certain configurations only.                                 */
+  /*                                                                       */
+/* #define FT_CONFIG_OPTION_SYSTEM_ZLIB */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Bzip2-compressed file support.                                        */
+  /*                                                                       */
+  /*   FreeType now handles font files that have been compressed with the  */
+  /*   `bzip2' program.  This is mostly used to parse many of the PCF      */
+  /*   files that come with XFree86.  The implementation uses `libbz2' to  */
+  /*   partially uncompress the file on the fly (see src/bzip2/ftbzip2.c). */
+  /*   Contrary to gzip, bzip2 currently is not included and need to use   */
+  /*   the system available bzip2 implementation.                          */
+  /*                                                                       */
+  /*   Define this macro if you want to enable this `feature'.             */
+  /*                                                                       */
+/* #define FT_CONFIG_OPTION_USE_BZIP2 */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define to disable the use of file stream functions and types, FILE,   */
+  /* fopen() etc.  Enables the use of smaller system libraries on embedded */
+  /* systems that have multiple system libraries, some with or without     */
+  /* file stream support, in the cases where file stream support is not    */
+  /* necessary such as memory loading of font files.                       */
+  /*                                                                       */
+/* #define FT_CONFIG_OPTION_DISABLE_STREAM_SUPPORT */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* PNG bitmap support.                                                   */
+  /*                                                                       */
+  /*   FreeType now handles loading color bitmap glyphs in the PNG format. */
+  /*   This requires help from the external libpng library.  Uncompressed  */
+  /*   color bitmaps do not need any external libraries and will be        */
+  /*   supported regardless of this configuration.                         */
+  /*                                                                       */
+  /*   Define this macro if you want to enable this `feature'.             */
+  /*                                                                       */
+/* #define FT_CONFIG_OPTION_USE_PNG */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* HarfBuzz support.                                                     */
+  /*                                                                       */
+  /*   FreeType uses the HarfBuzz library to improve auto-hinting of       */
+  /*   OpenType fonts.  If available, many glyphs not directly addressable */
+  /*   by a font's character map will be hinted also.                      */
+  /*                                                                       */
+  /*   Define this macro if you want to enable this `feature'.             */
+  /*                                                                       */
+/* #define FT_CONFIG_OPTION_USE_HARFBUZZ */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* DLL export compilation                                                */
+  /*                                                                       */
+  /*   When compiling FreeType as a DLL, some systems/compilers need a     */
+  /*   special keyword in front OR after the return type of function       */
+  /*   declarations.                                                       */
+  /*                                                                       */
+  /*   Two macros are used within the FreeType source code to define       */
+  /*   exported library functions: FT_EXPORT and FT_EXPORT_DEF.            */
+  /*                                                                       */
+  /*     FT_EXPORT( return_type )                                          */
+  /*                                                                       */
+  /*       is used in a function declaration, as in                        */
+  /*                                                                       */
+  /*         FT_EXPORT( FT_Error )                                         */
+  /*         FT_Init_FreeType( FT_Library*  alibrary );                    */
+  /*                                                                       */
+  /*                                                                       */
+  /*     FT_EXPORT_DEF( return_type )                                      */
+  /*                                                                       */
+  /*       is used in a function definition, as in                         */
+  /*                                                                       */
+  /*         FT_EXPORT_DEF( FT_Error )                                     */
+  /*         FT_Init_FreeType( FT_Library*  alibrary )                     */
+  /*         {                                                             */
+  /*           ... some code ...                                           */
+  /*           return FT_Err_Ok;                                           */
+  /*         }                                                             */
+  /*                                                                       */
+  /*   You can provide your own implementation of FT_EXPORT and            */
+  /*   FT_EXPORT_DEF here if you want.  If you leave them undefined, they  */
+  /*   will be later automatically defined as `extern return_type' to      */
+  /*   allow normal compilation.                                           */
+  /*                                                                       */
+  /*   Do not #undef these macros here since the build system might define */
+  /*   them for certain configurations only.                               */
+  /*                                                                       */
+/* #define FT_EXPORT(x)      extern x */
+/* #define FT_EXPORT_DEF(x)  x */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Glyph Postscript Names handling                                       */
+  /*                                                                       */
+  /*   By default, FreeType 2 is compiled with the `psnames' module.  This */
+  /*   module is in charge of converting a glyph name string into a        */
+  /*   Unicode value, or return a Macintosh standard glyph name for the    */
+  /*   use with the TrueType `post' table.                                 */
+  /*                                                                       */
+  /*   Undefine this macro if you do not want `psnames' compiled in your   */
+  /*   build of FreeType.  This has the following effects:                 */
+  /*                                                                       */
+  /*   - The TrueType driver will provide its own set of glyph names,      */
+  /*     if you build it to support postscript names in the TrueType       */
+  /*     `post' table.                                                     */
+  /*                                                                       */
+  /*   - The Type 1 driver will not be able to synthesize a Unicode        */
+  /*     charmap out of the glyphs found in the fonts.                     */
+  /*                                                                       */
+  /*   You would normally undefine this configuration macro when building  */
+  /*   a version of FreeType that doesn't contain a Type 1 or CFF driver.  */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_POSTSCRIPT_NAMES
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Postscript Names to Unicode Values support                            */
+  /*                                                                       */
+  /*   By default, FreeType 2 is built with the `PSNames' module compiled  */
+  /*   in.  Among other things, the module is used to convert a glyph name */
+  /*   into a Unicode value.  This is especially useful in order to        */
+  /*   synthesize on the fly a Unicode charmap from the CFF/Type 1 driver  */
+  /*   through a big table named the `Adobe Glyph List' (AGL).             */
+  /*                                                                       */
+  /*   Undefine this macro if you do not want the Adobe Glyph List         */
+  /*   compiled in your `PSNames' module.  The Type 1 driver will not be   */
+  /*   able to synthesize a Unicode charmap out of the glyphs found in the */
+  /*   fonts.                                                              */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_ADOBE_GLYPH_LIST
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Support for Mac fonts                                                 */
+  /*                                                                       */
+  /*   Define this macro if you want support for outline fonts in Mac      */
+  /*   format (mac dfont, mac resource, macbinary containing a mac         */
+  /*   resource) on non-Mac platforms.                                     */
+  /*                                                                       */
+  /*   Note that the `FOND' resource isn't checked.                        */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_MAC_FONTS
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Guessing methods to access embedded resource forks                    */
+  /*                                                                       */
+  /*   Enable extra Mac fonts support on non-Mac platforms (e.g.           */
+  /*   GNU/Linux).                                                         */
+  /*                                                                       */
+  /*   Resource forks which include fonts data are stored sometimes in     */
+  /*   locations which users or developers don't expected.  In some cases, */
+  /*   resource forks start with some offset from the head of a file.  In  */
+  /*   other cases, the actual resource fork is stored in file different   */
+  /*   from what the user specifies.  If this option is activated,         */
+  /*   FreeType tries to guess whether such offsets or different file      */
+  /*   names must be used.                                                 */
+  /*                                                                       */
+  /*   Note that normal, direct access of resource forks is controlled via */
+  /*   the FT_CONFIG_OPTION_MAC_FONTS option.                              */
+  /*                                                                       */
+#ifdef FT_CONFIG_OPTION_MAC_FONTS
+#define FT_CONFIG_OPTION_GUESSING_EMBEDDED_RFORK
+#endif
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Allow the use of FT_Incremental_Interface to load typefaces that      */
+  /* contain no glyph data, but supply it via a callback function.         */
+  /* This is required by clients supporting document formats which         */
+  /* supply font data incrementally as the document is parsed, such        */
+  /* as the Ghostscript interpreter for the PostScript language.           */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_INCREMENTAL
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* The size in bytes of the render pool used by the scan-line converter  */
+  /* to do all of its work.                                                */
+  /*                                                                       */
+#define FT_RENDER_POOL_SIZE  16384L
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* FT_MAX_MODULES                                                        */
+  /*                                                                       */
+  /*   The maximum number of modules that can be registered in a single    */
+  /*   FreeType library object.  32 is the default.                        */
+  /*                                                                       */
+#define FT_MAX_MODULES  32
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Debug level                                                           */
+  /*                                                                       */
+  /*   FreeType can be compiled in debug or trace mode.  In debug mode,    */
+  /*   errors are reported through the `ftdebug' component.  In trace      */
+  /*   mode, additional messages are sent to the standard output during    */
+  /*   execution.                                                          */
+  /*                                                                       */
+  /*   Define FT_DEBUG_LEVEL_ERROR to build the library in debug mode.     */
+  /*   Define FT_DEBUG_LEVEL_TRACE to build it in trace mode.              */
+  /*                                                                       */
+  /*   Don't define any of these macros to compile in `release' mode!      */
+  /*                                                                       */
+  /*   Do not #undef these macros here since the build system might define */
+  /*   them for certain configurations only.                               */
+  /*                                                                       */
+/* #define FT_DEBUG_LEVEL_ERROR */
+/* #define FT_DEBUG_LEVEL_TRACE */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Autofitter debugging                                                  */
+  /*                                                                       */
+  /*   If FT_DEBUG_AUTOFIT is defined, FreeType provides some means to     */
+  /*   control the autofitter behaviour for debugging purposes with global */
+  /*   boolean variables (consequently, you should *never* enable this     */
+  /*   while compiling in `release' mode):                                 */
+  /*                                                                       */
+  /*     _af_debug_disable_horz_hints                                      */
+  /*     _af_debug_disable_vert_hints                                      */
+  /*     _af_debug_disable_blue_hints                                      */
+  /*                                                                       */
+  /*   Additionally, the following functions provide dumps of various      */
+  /*   internal autofit structures to stdout (using `printf'):             */
+  /*                                                                       */
+  /*     af_glyph_hints_dump_points                                        */
+  /*     af_glyph_hints_dump_segments                                      */
+  /*     af_glyph_hints_dump_edges                                         */
+  /*     af_glyph_hints_get_num_segments                                   */
+  /*     af_glyph_hints_get_segment_offset                                 */
+  /*                                                                       */
+  /*   As an argument, they use another global variable:                   */
+  /*                                                                       */
+  /*     _af_debug_hints                                                   */
+  /*                                                                       */
+  /*   Please have a look at the `ftgrid' demo program to see how those    */
+  /*   variables and macros should be used.                                */
+  /*                                                                       */
+  /*   Do not #undef these macros here since the build system might define */
+  /*   them for certain configurations only.                               */
+  /*                                                                       */
+/* #define FT_DEBUG_AUTOFIT */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Memory Debugging                                                      */
+  /*                                                                       */
+  /*   FreeType now comes with an integrated memory debugger that is       */
+  /*   capable of detecting simple errors like memory leaks or double      */
+  /*   deletes.  To compile it within your build of the library, you       */
+  /*   should define FT_DEBUG_MEMORY here.                                 */
+  /*                                                                       */
+  /*   Note that the memory debugger is only activated at runtime when     */
+  /*   when the _environment_ variable `FT2_DEBUG_MEMORY' is defined also! */
+  /*                                                                       */
+  /*   Do not #undef this macro here since the build system might define   */
+  /*   it for certain configurations only.                                 */
+  /*                                                                       */
+/* #define FT_DEBUG_MEMORY */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Module errors                                                         */
+  /*                                                                       */
+  /*   If this macro is set (which is _not_ the default), the higher byte  */
+  /*   of an error code gives the module in which the error has occurred,  */
+  /*   while the lower byte is the real error code.                        */
+  /*                                                                       */
+  /*   Setting this macro makes sense for debugging purposes only, since   */
+  /*   it would break source compatibility of certain programs that use    */
+  /*   FreeType 2.                                                         */
+  /*                                                                       */
+  /*   More details can be found in the files ftmoderr.h and fterrors.h.   */
+  /*                                                                       */
+#undef FT_CONFIG_OPTION_USE_MODULE_ERRORS
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Position Independent Code                                             */
+  /*                                                                       */
+  /*   If this macro is set (which is _not_ the default), FreeType2 will   */
+  /*   avoid creating constants that require address fixups.  Instead the  */
+  /*   constants will be moved into a struct and additional intialization  */
+  /*   code will be used.                                                  */
+  /*                                                                       */
+  /*   Setting this macro is needed for systems that prohibit address      */
+  /*   fixups, such as BREW.  [Note that standard compilers like gcc or    */
+  /*   clang handle PIC generation automatically; you don't have to set    */
+  /*   FT_CONFIG_OPTION_PIC, which is only necessary for very special      */
+  /*   compilers.]                                                         */
+  /*                                                                       */
+  /*   Note that FT_CONFIG_OPTION_PIC support is not available for all     */
+  /*   modules (see `modules.cfg' for a complete list).  For building with */
+  /*   FT_CONFIG_OPTION_PIC support, do the following.                     */
+  /*                                                                       */
+  /*     0. Clone the repository.                                          */
+  /*     1. Define FT_CONFIG_OPTION_PIC.                                   */
+  /*     2. Remove all subdirectories in `src' that don't have             */
+  /*        FT_CONFIG_OPTION_PIC support.                                  */
+  /*     3. Comment out the corresponding modules in `modules.cfg'.        */
+  /*     4. Compile.                                                       */
+  /*                                                                       */
+/* #define FT_CONFIG_OPTION_PIC */
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****        S F N T   D R I V E R    C O N F I G U R A T I O N       ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_EMBEDDED_BITMAPS if you want to support       */
+  /* embedded bitmaps in all formats using the SFNT module (namely         */
+  /* TrueType & OpenType).                                                 */
+  /*                                                                       */
+#define TT_CONFIG_OPTION_EMBEDDED_BITMAPS
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_POSTSCRIPT_NAMES if you want to be able to    */
+  /* load and enumerate the glyph Postscript names in a TrueType or        */
+  /* OpenType file.                                                        */
+  /*                                                                       */
+  /* Note that when you do not compile the `PSNames' module by undefining  */
+  /* the above FT_CONFIG_OPTION_POSTSCRIPT_NAMES, the `sfnt' module will   */
+  /* contain additional code used to read the PS Names table from a font.  */
+  /*                                                                       */
+  /* (By default, the module uses `PSNames' to extract glyph names.)       */
+  /*                                                                       */
+#define TT_CONFIG_OPTION_POSTSCRIPT_NAMES
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_SFNT_NAMES if your applications need to       */
+  /* access the internal name table in a SFNT-based format like TrueType   */
+  /* or OpenType.  The name table contains various strings used to         */
+  /* describe the font, like family name, copyright, version, etc.  It     */
+  /* does not contain any glyph name though.                               */
+  /*                                                                       */
+  /* Accessing SFNT names is done through the functions declared in        */
+  /* `ftsnames.h'.                                                         */
+  /*                                                                       */
+#define TT_CONFIG_OPTION_SFNT_NAMES
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* TrueType CMap support                                                 */
+  /*                                                                       */
+  /*   Here you can fine-tune which TrueType CMap table format shall be    */
+  /*   supported.                                                          */
+#define TT_CONFIG_CMAP_FORMAT_0
+#define TT_CONFIG_CMAP_FORMAT_2
+#define TT_CONFIG_CMAP_FORMAT_4
+#define TT_CONFIG_CMAP_FORMAT_6
+#define TT_CONFIG_CMAP_FORMAT_8
+#define TT_CONFIG_CMAP_FORMAT_10
+#define TT_CONFIG_CMAP_FORMAT_12
+#define TT_CONFIG_CMAP_FORMAT_13
+#define TT_CONFIG_CMAP_FORMAT_14
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****    T R U E T Y P E   D R I V E R    C O N F I G U R A T I O N   ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_BYTECODE_INTERPRETER if you want to compile   */
+  /* a bytecode interpreter in the TrueType driver.                        */
+  /*                                                                       */
+  /* By undefining this, you will only compile the code necessary to load  */
+  /* TrueType glyphs without hinting.                                      */
+  /*                                                                       */
+  /*   Do not #undef this macro here, since the build system might         */
+  /*   define it for certain configurations only.                          */
+  /*                                                                       */
+#define TT_CONFIG_OPTION_BYTECODE_INTERPRETER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_SUBPIXEL_HINTING if you want to compile       */
+  /* subpixel hinting support into the TrueType driver.  This modifies the */
+  /* TrueType hinting mechanism when anything but FT_RENDER_MODE_MONO is   */
+  /* requested.                                                            */
+  /*                                                                       */
+  /* In particular, it modifies the bytecode interpreter to interpret (or  */
+  /* not) instructions in a certain way so that all TrueType fonts look    */
+  /* like they do in a Windows ClearType (DirectWrite) environment.  See   */
+  /* [1] for a technical overview on what this means.  See `ttinterp.h'    */
+  /* for more details on the LEAN option.                                  */
+  /*                                                                       */
+  /* There are three options.                                              */
+  /*                                                                       */
+  /* 1. This option is associated with the `Infinality' moniker.           */
+  /*    Contributed by an individual nicknamed Infinality with the goal of */
+  /*    making TrueType fonts render better than on Windows.  A high       */
+  /*    amount of configurability and flexibility, down to rules for       */
+  /*    single glyphs in fonts, but also very slow.  Its experimental and  */
+  /*    slow nature and the original developer losing interest meant that  */
+  /*    this option was never enabled in default builds.                   */
+  /*                                                                       */
+  /* 2. The new default mode for the TrueType driver.  The Infinality code */
+  /*    base was stripped to the bare minimum and all configurability      */
+  /*    removed in the name of speed and simplicity.  The configurability  */
+  /*    was mainly aimed at legacy fonts like Arial, Times New Roman, or   */
+  /*    Courier.  Legacy fonts are fonts that modify vertical stems to     */
+  /*    achieve clean black-and-white bitmaps.  The new mode focuses on    */
+  /*    applying a minimal set of rules to all fonts indiscriminately so   */
+  /*    that modern and web fonts render well while legacy fonts render    */
+  /*    okay.                                                              */
+  /*                                                                       */
+  /* 3. Compile both.                                                      */
+  /*                                                                       */
+  /* By undefining these, you get rendering behavior like on Windows       */
+  /* without ClearType, i.e., Windows XP without ClearType enabled and     */
+  /* Win9x (interpreter version v35).  Or not, depending on how much       */
+  /* hinting blood and testing tears the font designer put into a given    */
+  /* font.  If you define one or both subpixel hinting options, you can    */
+  /* switch between between v35 and the ones you define.                   */
+  /*                                                                       */
+  /* This option requires TT_CONFIG_OPTION_BYTECODE_INTERPRETER to be      */
+  /* defined.                                                              */
+  /*                                                                       */
+  /* [1] http://www.microsoft.com/typography/cleartype/truetypecleartype.aspx */
+  /*                                                                       */
+/* #define TT_CONFIG_OPTION_SUBPIXEL_HINTING  1         */
+#define TT_CONFIG_OPTION_SUBPIXEL_HINTING  2
+/* #define TT_CONFIG_OPTION_SUBPIXEL_HINTING  ( 1 | 2 ) */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED to compile the        */
+  /* TrueType glyph loader to use Apple's definition of how to handle      */
+  /* component offsets in composite glyphs.                                */
+  /*                                                                       */
+  /* Apple and MS disagree on the default behavior of component offsets    */
+  /* in composites.  Apple says that they should be scaled by the scaling  */
+  /* factors in the transformation matrix (roughly, it's more complex)     */
+  /* while MS says they should not.  OpenType defines two bits in the      */
+  /* composite flags array which can be used to disambiguate, but old      */
+  /* fonts will not have them.                                             */
+  /*                                                                       */
+  /*   http://www.microsoft.com/typography/otspec/glyf.htm                 */
+  /*   https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6glyf.html */
+  /*                                                                       */
+#undef TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_GX_VAR_SUPPORT if you want to include         */
+  /* support for Apple's distortable font technology (fvar, gvar, cvar,    */
+  /* and avar tables).  This has many similarities to Type 1 Multiple      */
+  /* Masters support.                                                      */
+  /*                                                                       */
+#define TT_CONFIG_OPTION_GX_VAR_SUPPORT
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_BDF if you want to include support for        */
+  /* an embedded `BDF ' table within SFNT-based bitmap formats.            */
+  /*                                                                       */
+#define TT_CONFIG_OPTION_BDF
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Option TT_CONFIG_OPTION_MAX_RUNNABLE_OPCODES controls the maximum     */
+  /* number of bytecode instructions executed for a single run of the      */
+  /* bytecode interpreter, needed to prevent infinite loops.  You don't    */
+  /* want to change this except for very special situations (e.g., making  */
+  /* a library fuzzer spend less time to handle broken fonts).             */
+  /*                                                                       */
+  /* It is not expected that this value is ever modified by a configuring  */
+  /* script; instead, it gets surrounded with #ifndef ... #endif so that   */
+  /* the value can be set as a preprocessor option on the compiler's       */
+  /* command line.                                                         */
+  /*                                                                       */
+#ifndef TT_CONFIG_OPTION_MAX_RUNNABLE_OPCODES
+#define TT_CONFIG_OPTION_MAX_RUNNABLE_OPCODES  1000000L
+#endif
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****      T Y P E 1   D R I V E R    C O N F I G U R A T I O N       ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* T1_MAX_DICT_DEPTH is the maximum depth of nest dictionaries and       */
+  /* arrays in the Type 1 stream (see t1load.c).  A minimum of 4 is        */
+  /* required.                                                             */
+  /*                                                                       */
+#define T1_MAX_DICT_DEPTH  5
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* T1_MAX_SUBRS_CALLS details the maximum number of nested sub-routine   */
+  /* calls during glyph loading.                                           */
+  /*                                                                       */
+#define T1_MAX_SUBRS_CALLS  16
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* T1_MAX_CHARSTRING_OPERANDS is the charstring stack's capacity.  A     */
+  /* minimum of 16 is required.                                            */
+  /*                                                                       */
+  /* The Chinese font MingTiEG-Medium (CNS 11643 character set) needs 256. */
+  /*                                                                       */
+#define T1_MAX_CHARSTRINGS_OPERANDS  256
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define this configuration macro if you want to prevent the            */
+  /* compilation of `t1afm', which is in charge of reading Type 1 AFM      */
+  /* files into an existing face.  Note that if set, the T1 driver will be */
+  /* unable to produce kerning distances.                                  */
+  /*                                                                       */
+#undef T1_CONFIG_OPTION_NO_AFM
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define this configuration macro if you want to prevent the            */
+  /* compilation of the Multiple Masters font support in the Type 1        */
+  /* driver.                                                               */
+  /*                                                                       */
+#undef T1_CONFIG_OPTION_NO_MM_SUPPORT
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****         C F F   D R I V E R    C O N F I G U R A T I O N        ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Using CFF_CONFIG_OPTION_DARKENING_PARAMETER_{X,Y}{1,2,3,4} it is      */
+  /* possible to set up the default values of the four control points that */
+  /* define the stem darkening behaviour of the (new) CFF engine.  For     */
+  /* more details please read the documentation of the                     */
+  /* `darkening-parameters' property of the cff driver module (file        */
+  /* `ftcffdrv.h'), which allows the control at run-time.                  */
+  /*                                                                       */
+  /* Do *not* undefine these macros!                                       */
+  /*                                                                       */
+#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1   500
+#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y1   400
+
+#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2  1000
+#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y2   275
+
+#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_X3  1667
+#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y3   275
+
+#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_X4  2333
+#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y4     0
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* CFF_CONFIG_OPTION_OLD_ENGINE controls whether the pre-Adobe CFF       */
+  /* engine gets compiled into FreeType.  If defined, it is possible to    */
+  /* switch between the two engines using the `hinting-engine' property of */
+  /* the cff driver module.                                                */
+  /*                                                                       */
+/* #define CFF_CONFIG_OPTION_OLD_ENGINE */
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****    A U T O F I T   M O D U L E    C O N F I G U R A T I O N     ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Compile autofit module with CJK (Chinese, Japanese, Korean) script    */
+  /* support.                                                              */
+  /*                                                                       */
+#define AF_CONFIG_OPTION_CJK
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Compile autofit module with Indic script support.                     */
+  /*                                                                       */
+#define AF_CONFIG_OPTION_INDIC
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Compile autofit module with warp hinting.  The idea of the warping    */
+  /* code is to slightly scale and shift a glyph within a single dimension */
+  /* so that as much of its segments are aligned (more or less) on the     */
+  /* grid.  To find out the optimal scaling and shifting value, various    */
+  /* parameter combinations are tried and scored.                          */
+  /*                                                                       */
+  /* This experimental option is active only if the rendering mode is      */
+  /* FT_RENDER_MODE_LIGHT; you can switch warping on and off with the      */
+  /* `warping' property of the auto-hinter (see file `ftautoh.h' for more  */
+  /* information; by default it is switched off).                          */
+  /*                                                                       */
+#define AF_CONFIG_OPTION_USE_WARPER
+
+  /* */
+
+
+  /*
+   * This macro is obsolete.  Support has been removed in FreeType
+   * version 2.5.
+   */
+/* #define FT_CONFIG_OPTION_OLD_INTERNALS */
+
+
+  /*
+   * This macro is defined if native TrueType hinting is requested by the
+   * definitions above.
+   */
+#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
+#define  TT_USE_BYTECODE_INTERPRETER
+
+#if TT_CONFIG_OPTION_SUBPIXEL_HINTING & 1
+#define  TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+#endif
+
+#if TT_CONFIG_OPTION_SUBPIXEL_HINTING & 2
+#define  TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
+#endif
+#endif
+
+
+  /*
+   * Check CFF darkening parameters.  The checks are the same as in function
+   * `cff_property_set' in file `cffdrivr.c'.
+   */
+#if CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1 < 0   || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2 < 0   || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_X3 < 0   || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_X4 < 0   || \
+                                                      \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y1 < 0   || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y2 < 0   || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y3 < 0   || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y4 < 0   || \
+                                                      \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1 >        \
+      CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2     || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2 >        \
+      CFF_CONFIG_OPTION_DARKENING_PARAMETER_X3     || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_X3 >        \
+      CFF_CONFIG_OPTION_DARKENING_PARAMETER_X4     || \
+                                                      \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y1 > 500 || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y2 > 500 || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y3 > 500 || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y4 > 500
+#error "Invalid CFF darkening parameters!"
+#endif
+
+FT_END_HEADER
+
+
+#endif /* FTOPTION_H_ */
+
+
+/* END */
diff -ruN freetype-2.7-orig/src/autofit/aflatin.c freetype-2.7/src/autofit/aflatin.c
--- freetype-2.7-orig/src/autofit/aflatin.c	2016-08-26 11:45:36.000000000 +0200
+++ freetype-2.7/src/autofit/aflatin.c	2016-09-09 16:01:22.465167416 +0200
@@ -24,7 +24,10 @@
 #include "afpic.h"
 #include "aflatin.h"
 #include "aferrors.h"
-
+#include "strings.h"
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+#include "../base/ftinf.h"
+#endif
 
 #ifdef AF_CONFIG_OPTION_USE_WARPER
 #include "afwarp.h"
@@ -40,6 +43,10 @@
 #undef  FT_COMPONENT
 #define FT_COMPONENT  trace_aflatin
 
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+FT_Pos infinality_cur_width = 0;
+#endif
+
 
   /* needed for computation of round vs. flat segments */
 #define FLAT_THRESHOLD( x )  ( x / 14 )
@@ -1028,7 +1035,10 @@
     FT_Pos        delta;
     AF_LatinAxis  axis;
     FT_UInt       nn;
-
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    FT_Bool adjust_heights         = FALSE;
+    if(ftinf) adjust_heights=ftinf->autohint_increase_glyph_heights;
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
 
     if ( dim == AF_DIMENSION_HORZ )
     {
@@ -1056,7 +1066,7 @@
     {
       AF_LatinAxis  Axis = &metrics->axis[AF_DIMENSION_VERT];
       AF_LatinBlue  blue = NULL;
-
+      int threshold = 40;
 
       for ( nn = 0; nn < Axis->blue_count; nn++ )
       {
@@ -1066,7 +1076,12 @@
           break;
         }
       }
-
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+      if ( adjust_heights                                       &&
+           metrics->root.scaler.face->size->metrics.x_ppem < 15 &&
+           metrics->root.scaler.face->size->metrics.x_ppem > 5  )
+        threshold = 52;
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
       if ( blue )
       {
         FT_Pos   scaled;
@@ -1222,7 +1237,13 @@
 
         /* a blue zone is only active if it is less than 3/4 pixels tall */
         dist = FT_MulFix( blue->ref.org - blue->shoot.org, scale );
+
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+        /* Do at low ppems ( ~< 200 ), in order to prevent fringes */
+        if ( dist <= 256 && dist >= -256 )
+#else
         if ( dist <= 48 && dist >= -48 )
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
         {
 #if 0
           FT_Pos  delta1;
@@ -1273,7 +1294,12 @@
             delta2 = -delta2;
 
           blue->ref.fit   = FT_PIX_ROUND( blue->ref.cur );
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+          /* Round to prevent fringes */
+          blue->shoot.fit = FT_PIX_ROUND( blue->ref.fit - delta2 );
+#else
           blue->shoot.fit = blue->ref.fit - delta2;
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
 
 #endif
 
@@ -2407,7 +2433,10 @@
               dist = edge->fpos - blue->shoot.org;
               if ( dist < 0 )
                 dist = -dist;
-
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+              /* round down to pixels */
+              /*dist = FT_MulFix( dist, scale ) & ~63;*/
+#endif
               dist = FT_MulFix( dist, scale );
               if ( dist < best_dist )
               {
@@ -2583,8 +2612,17 @@
     FT_Pos           dist     = width;
     FT_Int           sign     = 0;
     FT_Int           vertical = ( dim == AF_DIMENSION_VERT );
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    FT_Int           infinality_dist = 0;
+    FT_UInt          autohint_snap_stem_height = 0;
+    if( ftinf ) autohint_snap_stem_height=ftinf->autohint_snap_stem_height;
+    if ( autohint_snap_stem_height > 100 )
+        autohint_snap_stem_height = 100;
+    else if ( autohint_snap_stem_height < 0 )
+        autohint_snap_stem_height = 0;
 
-
+    if ( autohint_snap_stem_height == 0 )
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
     if ( !AF_LATIN_HINTS_DO_STEM_ADJUST( hints ) ||
          axis->extra_light                       )
       return width;
@@ -2594,9 +2632,76 @@
       dist = -width;
       sign = 1;
     }
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    /* Calculate snap value differently than standard freetype */
+    if ( autohint_snap_stem_height > 0                              &&
+         ( ( vertical && !AF_LATIN_HINTS_DO_VERT_SNAP( hints ) )  ||
+           ( !vertical && !AF_LATIN_HINTS_DO_HORZ_SNAP( hints ) ) ) )
+    {
+      infinality_dist = af_latin_snap_width( axis->widths,
+                                             axis->width_count, dist );
+
+      if ( metrics->root.scaler.face->size->metrics.x_ppem > 9 &&
+           axis->width_count > 0                               &&
+           abs( axis->widths[0].cur - infinality_dist ) < 32   &&
+           axis->widths[0].cur > 52                            )
+      {
+          const char *style_name=metrics->root.scaler.face->style_name;
+          if ( style_name!=NULL &&
+               ( strstr( style_name, "Regular" )      ||
+                 strstr( style_name, "Book" )         ||
+                 strstr( style_name, "Medium" )       ||
+                 strcmp( style_name, "Italic" ) == 0  ||
+                 strcmp( style_name, "Oblique" ) == 0 )
+              )
+         {
+          /* regular weight */
+          if ( axis->widths[0].cur < 64 )
+            infinality_dist = 64;
+          else if ( axis->widths[0].cur  < 88 )
+            infinality_dist = 64;
+          else if ( axis->widths[0].cur  < 160 )
+            infinality_dist = 128;
+          else if ( axis->widths[0].cur  < 240 )
+            infinality_dist = 190;
+          else infinality_dist = ( infinality_dist ) & ~63;
+        }
+        else
+        {
+          /* bold gets a different threshold */
+          if ( axis->widths[0].cur < 64 )
+            infinality_dist = 64 ;
+          else if ( axis->widths[0].cur  < 108 )
+            infinality_dist = 64;
+          else if ( axis->widths[0].cur  < 160 )
+            infinality_dist = 128;
+          else if ( axis->widths[0].cur  < 222 )
+            infinality_dist = 190;
+          else if ( axis->widths[0].cur  < 288 )
+            infinality_dist = 254;
+          else infinality_dist = ( infinality_dist + 16 ) & ~63;
+        }
 
-    if ( (  vertical && !AF_LATIN_HINTS_DO_VERT_SNAP( hints ) ) ||
+      }
+      if ( infinality_dist < 52 )
+      {
+        if ( metrics->root.scaler.face->size->metrics.x_ppem < 9 )
+        {
+          if ( infinality_dist < 32 )
+            infinality_dist = 32;
+        }
+        else
+          infinality_dist = 64;
+      }
+    }
+    else if ( autohint_snap_stem_height < 100                            &&
+              ( ( vertical && !AF_LATIN_HINTS_DO_VERT_SNAP( hints ) )  ||
+                ( !vertical && !AF_LATIN_HINTS_DO_HORZ_SNAP( hints ) ) ) )
+#else
+
+    if ( ( vertical && !AF_LATIN_HINTS_DO_VERT_SNAP( hints ) ) ||
          ( !vertical && !AF_LATIN_HINTS_DO_HORZ_SNAP( hints ) ) )
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
     {
       /* smooth hinting process: very lightly quantize the stem width */
 
@@ -2688,6 +2793,9 @@
       }
     }
     else
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+      if ( autohint_snap_stem_height < 100 )
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
     {
       /* strong hinting process: snap the stem width to integer pixels */
 
@@ -2695,7 +2803,10 @@
 
 
       dist = af_latin_snap_width( axis->widths, axis->width_count, dist );
-
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+      if ( autohint_snap_stem_height > 0 )
+        goto Done_Width;
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
       if ( vertical )
       {
         /* in the case of vertical hinting, always round */
@@ -2758,6 +2869,32 @@
     }
 
   Done_Width:
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    if ( axis->widths[0].cur > 42 )
+      /* weighted average */
+      dist = (dist * ( 100 - autohint_snap_stem_height )
+                + infinality_dist * autohint_snap_stem_height ) / 100;
+
+      {
+        int factor = 100;
+        if ( axis->standard_width < 100 )
+          factor = axis->standard_width;
+
+        if ( metrics->root.scaler.face->size->metrics.x_ppem >= 9  && dist < 52 )
+          dist += ( (52 - dist) * factor ) / 100;
+        if ( metrics->root.scaler.face->size->metrics.x_ppem < 9  && dist < 32 )
+          dist += ( (32 - dist) * factor ) / 100;
+
+        if ( axis->standard_width > 100                             &&
+             metrics->root.scaler.face->size->metrics.x_ppem >= 11  &&
+             dist < 64                                              )
+          dist = 64;
+        if ( axis->standard_width > 100                           &&
+             metrics->root.scaler.face->size->metrics.x_ppem >= 9 &&
+             dist < 52                                            )
+          dist = 52;
+      }
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
     if ( sign )
       dist = -dist;
 
@@ -2776,6 +2913,8 @@
     FT_Pos  dist, base_delta;
     FT_Pos  fitted_width;
 
+/* if fitted_width causes stem_edge->pos to land basically on top of an existing
+ * stem_edge->pos, then add or remove 64.  Need to figure out a way to do this */
 
     dist       = stem_edge->opos - base_edge->opos;
     base_delta = base_edge->pos - base_edge->opos;
@@ -3384,8 +3523,11 @@
     int       dim;
 
     AF_LatinAxis  axis;
-
-
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    FT_Int    emboldening_strength = 0;
+    FT_Bool   use_various_tweaks = FALSE;
+    if( ftinf ) use_various_tweaks=ftinf->use_various_tweaks;
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
     error = af_glyph_hints_reload( hints, outline );
     if ( error )
       goto Exit;
@@ -3455,7 +3597,11 @@
     }
 
     af_glyph_hints_save( hints, outline );
-
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    {
+      infinality_cur_width = metrics->axis->widths[0].cur;
+    }
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
   Exit:
     return error;
   }
diff -ruN freetype-2.7-orig/src/autofit/aflatin.c.orig freetype-2.7/src/autofit/aflatin.c.orig
--- freetype-2.7-orig/src/autofit/aflatin.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ freetype-2.7/src/autofit/aflatin.c.orig	2016-08-26 11:45:36.000000000 +0200
@@ -0,0 +1,3490 @@
+/***************************************************************************/
+/*                                                                         */
+/*  aflatin.c                                                              */
+/*                                                                         */
+/*    Auto-fitter hinting routines for latin writing system (body).        */
+/*                                                                         */
+/*  Copyright 2003-2016 by                                                 */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#include <ft2build.h>
+#include FT_ADVANCES_H
+#include FT_INTERNAL_DEBUG_H
+
+#include "afglobal.h"
+#include "afpic.h"
+#include "aflatin.h"
+#include "aferrors.h"
+
+
+#ifdef AF_CONFIG_OPTION_USE_WARPER
+#include "afwarp.h"
+#endif
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
+  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
+  /* messages during execution.                                            */
+  /*                                                                       */
+#undef  FT_COMPONENT
+#define FT_COMPONENT  trace_aflatin
+
+
+  /* needed for computation of round vs. flat segments */
+#define FLAT_THRESHOLD( x )  ( x / 14 )
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*****                                                               *****/
+  /*****            L A T I N   G L O B A L   M E T R I C S            *****/
+  /*****                                                               *****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /* Find segments and links, compute all stem widths, and initialize */
+  /* standard width and height for the glyph with given charcode.     */
+
+  FT_LOCAL_DEF( void )
+  af_latin_metrics_init_widths( AF_LatinMetrics  metrics,
+                                FT_Face          face )
+  {
+    /* scan the array of segments in each direction */
+    AF_GlyphHintsRec  hints[1];
+
+
+    FT_TRACE5(( "\n"
+                "latin standard widths computation (style `%s')\n"
+                "=====================================================\n"
+                "\n",
+                af_style_names[metrics->root.style_class->style] ));
+
+    af_glyph_hints_init( hints, face->memory );
+
+    metrics->axis[AF_DIMENSION_HORZ].width_count = 0;
+    metrics->axis[AF_DIMENSION_VERT].width_count = 0;
+
+    {
+      FT_Error            error;
+      FT_ULong            glyph_index;
+      int                 dim;
+      AF_LatinMetricsRec  dummy[1];
+      AF_Scaler           scaler = &dummy->root.scaler;
+
+#ifdef FT_CONFIG_OPTION_PIC
+      AF_FaceGlobals  globals = metrics->root.globals;
+#endif
+
+      AF_StyleClass   style_class  = metrics->root.style_class;
+      AF_ScriptClass  script_class = AF_SCRIPT_CLASSES_GET
+                                       [style_class->script];
+
+      void*        shaper_buf;
+      const char*  p;
+
+#ifdef FT_DEBUG_LEVEL_TRACE
+      FT_ULong  ch = 0;
+#endif
+
+      p          = script_class->standard_charstring;
+      shaper_buf = af_shaper_buf_create( face );
+
+      /*
+       * We check a list of standard characters to catch features like
+       * `c2sc' (small caps from caps) that don't contain lowercase letters
+       * by definition, or other features that mainly operate on numerals.
+       * The first match wins.
+       */
+
+      glyph_index = 0;
+      while ( *p )
+      {
+        unsigned int  num_idx;
+
+#ifdef FT_DEBUG_LEVEL_TRACE
+        const char*  p_old;
+#endif
+
+
+        while ( *p == ' ' )
+          p++;
+
+#ifdef FT_DEBUG_LEVEL_TRACE
+        p_old = p;
+        GET_UTF8_CHAR( ch, p_old );
+#endif
+
+        /* reject input that maps to more than a single glyph */
+        p = af_shaper_get_cluster( p, &metrics->root, shaper_buf, &num_idx );
+        if ( num_idx > 1 )
+          continue;
+
+        /* otherwise exit loop if we have a result */
+        glyph_index = af_shaper_get_elem( &metrics->root,
+                                          shaper_buf,
+                                          0,
+                                          NULL,
+                                          NULL );
+        if ( glyph_index )
+          break;
+      }
+
+      af_shaper_buf_destroy( face, shaper_buf );
+
+      if ( !glyph_index )
+        goto Exit;
+
+      FT_TRACE5(( "standard character: U+%04lX (glyph index %d)\n",
+                  ch, glyph_index ));
+
+      error = FT_Load_Glyph( face, glyph_index, FT_LOAD_NO_SCALE );
+      if ( error || face->glyph->outline.n_points <= 0 )
+        goto Exit;
+
+      FT_ZERO( dummy );
+
+      dummy->units_per_em = metrics->units_per_em;
+
+      scaler->x_scale = 0x10000L;
+      scaler->y_scale = 0x10000L;
+      scaler->x_delta = 0;
+      scaler->y_delta = 0;
+
+      scaler->face        = face;
+      scaler->render_mode = FT_RENDER_MODE_NORMAL;
+      scaler->flags       = 0;
+
+      af_glyph_hints_rescale( hints, (AF_StyleMetrics)dummy );
+
+      error = af_glyph_hints_reload( hints, &face->glyph->outline );
+      if ( error )
+        goto Exit;
+
+      for ( dim = 0; dim < AF_DIMENSION_MAX; dim++ )
+      {
+        AF_LatinAxis  axis    = &metrics->axis[dim];
+        AF_AxisHints  axhints = &hints->axis[dim];
+        AF_Segment    seg, limit, link;
+        FT_UInt       num_widths = 0;
+
+
+        error = af_latin_hints_compute_segments( hints,
+                                                 (AF_Dimension)dim );
+        if ( error )
+          goto Exit;
+
+        /*
+         *  We assume that the glyphs selected for the stem width
+         *  computation are `featureless' enough so that the linking
+         *  algorithm works fine without adjustments of its scoring
+         *  function.
+         */
+        af_latin_hints_link_segments( hints,
+                                      0,
+                                      NULL,
+                                      (AF_Dimension)dim );
+
+        seg   = axhints->segments;
+        limit = seg + axhints->num_segments;
+
+        for ( ; seg < limit; seg++ )
+        {
+          link = seg->link;
+
+          /* we only consider stem segments there! */
+          if ( link && link->link == seg && link > seg )
+          {
+            FT_Pos  dist;
+
+
+            dist = seg->pos - link->pos;
+            if ( dist < 0 )
+              dist = -dist;
+
+            if ( num_widths < AF_LATIN_MAX_WIDTHS )
+              axis->widths[num_widths++].org = dist;
+          }
+        }
+
+        /* this also replaces multiple almost identical stem widths */
+        /* with a single one (the value 100 is heuristic)           */
+        af_sort_and_quantize_widths( &num_widths, axis->widths,
+                                     dummy->units_per_em / 100 );
+        axis->width_count = num_widths;
+      }
+
+    Exit:
+      for ( dim = 0; dim < AF_DIMENSION_MAX; dim++ )
+      {
+        AF_LatinAxis  axis = &metrics->axis[dim];
+        FT_Pos        stdw;
+
+
+        stdw = ( axis->width_count > 0 ) ? axis->widths[0].org
+                                         : AF_LATIN_CONSTANT( metrics, 50 );
+
+        /* let's try 20% of the smallest width */
+        axis->edge_distance_threshold = stdw / 5;
+        axis->standard_width          = stdw;
+        axis->extra_light             = 0;
+
+#ifdef FT_DEBUG_LEVEL_TRACE
+        {
+          FT_UInt  i;
+
+
+          FT_TRACE5(( "%s widths:\n",
+                      dim == AF_DIMENSION_VERT ? "horizontal"
+                                               : "vertical" ));
+
+          FT_TRACE5(( "  %d (standard)", axis->standard_width ));
+          for ( i = 1; i < axis->width_count; i++ )
+            FT_TRACE5(( " %d", axis->widths[i].org ));
+
+          FT_TRACE5(( "\n" ));
+        }
+#endif
+      }
+    }
+
+    FT_TRACE5(( "\n" ));
+
+    af_glyph_hints_done( hints );
+  }
+
+
+  /* Find all blue zones.  Flat segments give the reference points, */
+  /* round segments the overshoot positions.                        */
+
+  static void
+  af_latin_metrics_init_blues( AF_LatinMetrics  metrics,
+                               FT_Face          face )
+  {
+    FT_Pos        flats [AF_BLUE_STRING_MAX_LEN];
+    FT_Pos        rounds[AF_BLUE_STRING_MAX_LEN];
+
+    FT_UInt       num_flats;
+    FT_UInt       num_rounds;
+
+    AF_LatinBlue  blue;
+    FT_Error      error;
+    AF_LatinAxis  axis = &metrics->axis[AF_DIMENSION_VERT];
+    FT_Outline    outline;
+
+    AF_StyleClass  sc = metrics->root.style_class;
+
+    AF_Blue_Stringset         bss = sc->blue_stringset;
+    const AF_Blue_StringRec*  bs  = &af_blue_stringsets[bss];
+
+    FT_Pos  flat_threshold = FLAT_THRESHOLD( metrics->units_per_em );
+
+    void*  shaper_buf;
+
+
+    /* we walk over the blue character strings as specified in the */
+    /* style's entry in the `af_blue_stringset' array              */
+
+    FT_TRACE5(( "latin blue zones computation\n"
+                "============================\n"
+                "\n" ));
+
+    shaper_buf = af_shaper_buf_create( face );
+
+    for ( ; bs->string != AF_BLUE_STRING_MAX; bs++ )
+    {
+      const char*  p = &af_blue_strings[bs->string];
+      FT_Pos*      blue_ref;
+      FT_Pos*      blue_shoot;
+      FT_Pos       ascender;
+      FT_Pos       descender;
+
+
+#ifdef FT_DEBUG_LEVEL_TRACE
+      {
+        FT_Bool  have_flag = 0;
+
+
+        FT_TRACE5(( "blue zone %d", axis->blue_count ));
+
+        if ( bs->properties )
+        {
+          FT_TRACE5(( " (" ));
+
+          if ( AF_LATIN_IS_TOP_BLUE( bs ) )
+          {
+            FT_TRACE5(( "top" ));
+            have_flag = 1;
+          }
+          else if ( AF_LATIN_IS_SUB_TOP_BLUE( bs ) )
+          {
+            FT_TRACE5(( "sub top" ));
+            have_flag = 1;
+          }
+
+          if ( AF_LATIN_IS_NEUTRAL_BLUE( bs ) )
+          {
+            if ( have_flag )
+              FT_TRACE5(( ", " ));
+            FT_TRACE5(( "neutral" ));
+            have_flag = 1;
+          }
+
+          if ( AF_LATIN_IS_X_HEIGHT_BLUE( bs ) )
+          {
+            if ( have_flag )
+              FT_TRACE5(( ", " ));
+            FT_TRACE5(( "small top" ));
+            have_flag = 1;
+          }
+
+          if ( AF_LATIN_IS_LONG_BLUE( bs ) )
+          {
+            if ( have_flag )
+              FT_TRACE5(( ", " ));
+            FT_TRACE5(( "long" ));
+          }
+
+          FT_TRACE5(( ")" ));
+        }
+
+        FT_TRACE5(( ":\n" ));
+      }
+#endif /* FT_DEBUG_LEVEL_TRACE */
+
+      num_flats  = 0;
+      num_rounds = 0;
+      ascender   = 0;
+      descender  = 0;
+
+      while ( *p )
+      {
+        FT_ULong    glyph_index;
+        FT_Long     y_offset;
+        FT_Int      best_point, best_contour_first, best_contour_last;
+        FT_Vector*  points;
+
+        FT_Pos   best_y_extremum;                      /* same as points.y */
+        FT_Bool  best_round = 0;
+
+        unsigned int  i, num_idx;
+
+#ifdef FT_DEBUG_LEVEL_TRACE
+        const char*  p_old;
+        FT_ULong     ch;
+#endif
+
+
+        while ( *p == ' ' )
+          p++;
+
+#ifdef FT_DEBUG_LEVEL_TRACE
+        p_old = p;
+        GET_UTF8_CHAR( ch, p_old );
+#endif
+
+        p = af_shaper_get_cluster( p, &metrics->root, shaper_buf, &num_idx );
+
+        if ( !num_idx )
+        {
+          FT_TRACE5(( "  U+%04lX unavailable\n", ch ));
+          continue;
+        }
+
+        if ( AF_LATIN_IS_TOP_BLUE( bs ) )
+          best_y_extremum = FT_INT_MIN;
+        else
+          best_y_extremum = FT_INT_MAX;
+
+        /* iterate over all glyph elements of the character cluster */
+        /* and get the data of the `biggest' one                    */
+        for ( i = 0; i < num_idx; i++ )
+        {
+          FT_Pos   best_y;
+          FT_Bool  round = 0;
+
+
+          /* load the character in the face -- skip unknown or empty ones */
+          glyph_index = af_shaper_get_elem( &metrics->root,
+                                            shaper_buf,
+                                            i,
+                                            NULL,
+                                            &y_offset );
+          if ( glyph_index == 0 )
+          {
+            FT_TRACE5(( "  U+%04lX unavailable\n", ch ));
+            continue;
+          }
+
+          error   = FT_Load_Glyph( face, glyph_index, FT_LOAD_NO_SCALE );
+          outline = face->glyph->outline;
+          /* reject glyphs that don't produce any rendering */
+          if ( error || outline.n_points <= 2 )
+          {
+#ifdef FT_DEBUG_LEVEL_TRACE
+            if ( num_idx == 1 )
+              FT_TRACE5(( "  U+%04lX contains no (usable) outlines\n", ch ));
+            else
+              FT_TRACE5(( "  component %d of cluster starting with U+%04lX"
+                          " contains no (usable) outlines\n", i, ch ));
+#endif
+            continue;
+          }
+
+          /* now compute min or max point indices and coordinates */
+          points             = outline.points;
+          best_point         = -1;
+          best_y             = 0;  /* make compiler happy */
+          best_contour_first = 0;  /* ditto */
+          best_contour_last  = 0;  /* ditto */
+
+          {
+            FT_Int  nn;
+            FT_Int  first = 0;
+            FT_Int  last  = -1;
+
+
+            for ( nn = 0; nn < outline.n_contours; first = last + 1, nn++ )
+            {
+              FT_Int  old_best_point = best_point;
+              FT_Int  pp;
+
+
+              last = outline.contours[nn];
+
+              /* Avoid single-point contours since they are never      */
+              /* rasterized.  In some fonts, they correspond to mark   */
+              /* attachment points that are way outside of the glyph's */
+              /* real outline.                                         */
+              if ( last <= first )
+                continue;
+
+              if ( AF_LATIN_IS_TOP_BLUE( bs )     ||
+                   AF_LATIN_IS_SUB_TOP_BLUE( bs ) )
+              {
+                for ( pp = first; pp <= last; pp++ )
+                {
+                  if ( best_point < 0 || points[pp].y > best_y )
+                  {
+                    best_point = pp;
+                    best_y     = points[pp].y;
+                    ascender   = FT_MAX( ascender, best_y + y_offset );
+                  }
+                  else
+                    descender = FT_MIN( descender, points[pp].y + y_offset );
+                }
+              }
+              else
+              {
+                for ( pp = first; pp <= last; pp++ )
+                {
+                  if ( best_point < 0 || points[pp].y < best_y )
+                  {
+                    best_point = pp;
+                    best_y     = points[pp].y;
+                    descender  = FT_MIN( descender, best_y + y_offset );
+                  }
+                  else
+                    ascender = FT_MAX( ascender, points[pp].y + y_offset );
+                }
+              }
+
+              if ( best_point != old_best_point )
+              {
+                best_contour_first = first;
+                best_contour_last  = last;
+              }
+            }
+          }
+
+          /* now check whether the point belongs to a straight or round   */
+          /* segment; we first need to find in which contour the extremum */
+          /* lies, then inspect its previous and next points              */
+          if ( best_point >= 0 )
+          {
+            FT_Pos  best_x = points[best_point].x;
+            FT_Int  prev, next;
+            FT_Int  best_segment_first, best_segment_last;
+            FT_Int  best_on_point_first, best_on_point_last;
+            FT_Pos  dist;
+
+
+            best_segment_first = best_point;
+            best_segment_last  = best_point;
+
+            if ( FT_CURVE_TAG( outline.tags[best_point] ) == FT_CURVE_TAG_ON )
+            {
+              best_on_point_first = best_point;
+              best_on_point_last  = best_point;
+            }
+            else
+            {
+              best_on_point_first = -1;
+              best_on_point_last  = -1;
+            }
+
+            /* look for the previous and next points on the contour  */
+            /* that are not on the same Y coordinate, then threshold */
+            /* the `closeness'...                                    */
+            prev = best_point;
+            next = prev;
+
+            do
+            {
+              if ( prev > best_contour_first )
+                prev--;
+              else
+                prev = best_contour_last;
+
+              dist = FT_ABS( points[prev].y - best_y );
+              /* accept a small distance or a small angle (both values are */
+              /* heuristic; value 20 corresponds to approx. 2.9 degrees)   */
+              if ( dist > 5 )
+                if ( FT_ABS( points[prev].x - best_x ) <= 20 * dist )
+                  break;
+
+              best_segment_first = prev;
+
+              if ( FT_CURVE_TAG( outline.tags[prev] ) == FT_CURVE_TAG_ON )
+              {
+                best_on_point_first = prev;
+                if ( best_on_point_last < 0 )
+                  best_on_point_last = prev;
+              }
+
+            } while ( prev != best_point );
+
+            do
+            {
+              if ( next < best_contour_last )
+                next++;
+              else
+                next = best_contour_first;
+
+              dist = FT_ABS( points[next].y - best_y );
+              if ( dist > 5 )
+                if ( FT_ABS( points[next].x - best_x ) <= 20 * dist )
+                  break;
+
+              best_segment_last = next;
+
+              if ( FT_CURVE_TAG( outline.tags[next] ) == FT_CURVE_TAG_ON )
+              {
+                best_on_point_last = next;
+                if ( best_on_point_first < 0 )
+                  best_on_point_first = next;
+              }
+
+            } while ( next != best_point );
+
+            if ( AF_LATIN_IS_LONG_BLUE( bs ) )
+            {
+              /* If this flag is set, we have an additional constraint to  */
+              /* get the blue zone distance: Find a segment of the topmost */
+              /* (or bottommost) contour that is longer than a heuristic   */
+              /* threshold.  This ensures that small bumps in the outline  */
+              /* are ignored (for example, the `vertical serifs' found in  */
+              /* many Hebrew glyph designs).                               */
+
+              /* If this segment is long enough, we are done.  Otherwise,  */
+              /* search the segment next to the extremum that is long      */
+              /* enough, has the same direction, and a not too large       */
+              /* vertical distance from the extremum.  Note that the       */
+              /* algorithm doesn't check whether the found segment is      */
+              /* actually the one (vertically) nearest to the extremum.    */
+
+              /* heuristic threshold value */
+              FT_Pos  length_threshold = metrics->units_per_em / 25;
+
+
+              dist = FT_ABS( points[best_segment_last].x -
+                               points[best_segment_first].x );
+
+              if ( dist < length_threshold                       &&
+                   best_segment_last - best_segment_first + 2 <=
+                     best_contour_last - best_contour_first      )
+              {
+                /* heuristic threshold value */
+                FT_Pos  height_threshold = metrics->units_per_em / 4;
+
+                FT_Int   first;
+                FT_Int   last;
+                FT_Bool  hit;
+
+                /* we intentionally declare these two variables        */
+                /* outside of the loop since various compilers emit    */
+                /* incorrect warning messages otherwise, talking about */
+                /* `possibly uninitialized variables'                  */
+                FT_Int  p_first = 0;            /* make compiler happy */
+                FT_Int  p_last  = 0;
+
+                FT_Bool  left2right;
+
+
+                /* compute direction */
+                prev = best_point;
+
+                do
+                {
+                  if ( prev > best_contour_first )
+                    prev--;
+                  else
+                    prev = best_contour_last;
+
+                  if ( points[prev].x != best_x )
+                    break;
+
+                } while ( prev != best_point );
+
+                /* skip glyph for the degenerate case */
+                if ( prev == best_point )
+                  continue;
+
+                left2right = FT_BOOL( points[prev].x < points[best_point].x );
+
+                first = best_segment_last;
+                last  = first;
+                hit   = 0;
+
+                do
+                {
+                  FT_Bool  l2r;
+                  FT_Pos   d;
+
+
+                  if ( !hit )
+                  {
+                    /* no hit; adjust first point */
+                    first = last;
+
+                    /* also adjust first and last on point */
+                    if ( FT_CURVE_TAG( outline.tags[first] ) ==
+                           FT_CURVE_TAG_ON )
+                    {
+                      p_first = first;
+                      p_last  = first;
+                    }
+                    else
+                    {
+                      p_first = -1;
+                      p_last  = -1;
+                    }
+
+                    hit = 1;
+                  }
+
+                  if ( last < best_contour_last )
+                    last++;
+                  else
+                    last = best_contour_first;
+
+                  if ( FT_ABS( best_y - points[first].y ) > height_threshold )
+                  {
+                    /* vertical distance too large */
+                    hit = 0;
+                    continue;
+                  }
+
+                  /* same test as above */
+                  dist = FT_ABS( points[last].y - points[first].y );
+                  if ( dist > 5 )
+                    if ( FT_ABS( points[last].x - points[first].x ) <=
+                           20 * dist )
+                    {
+                      hit = 0;
+                      continue;
+                    }
+
+                  if ( FT_CURVE_TAG( outline.tags[last] ) == FT_CURVE_TAG_ON )
+                  {
+                    p_last = last;
+                    if ( p_first < 0 )
+                      p_first = last;
+                  }
+
+                  l2r = FT_BOOL( points[first].x < points[last].x );
+                  d   = FT_ABS( points[last].x - points[first].x );
+
+                  if ( l2r == left2right     &&
+                       d >= length_threshold )
+                  {
+                    /* all constraints are met; update segment after */
+                    /* finding its end                               */
+                    do
+                    {
+                      if ( last < best_contour_last )
+                        last++;
+                      else
+                        last = best_contour_first;
+
+                      d = FT_ABS( points[last].y - points[first].y );
+                      if ( d > 5 )
+                        if ( FT_ABS( points[next].x - points[first].x ) <=
+                               20 * dist )
+                        {
+                          if ( last > best_contour_first )
+                            last--;
+                          else
+                            last = best_contour_last;
+                          break;
+                        }
+
+                      p_last = last;
+
+                      if ( FT_CURVE_TAG( outline.tags[last] ) ==
+                             FT_CURVE_TAG_ON )
+                      {
+                        p_last = last;
+                        if ( p_first < 0 )
+                          p_first = last;
+                      }
+
+                    } while ( last != best_segment_first );
+
+                    best_y = points[first].y;
+
+                    best_segment_first = first;
+                    best_segment_last  = last;
+
+                    best_on_point_first = p_first;
+                    best_on_point_last  = p_last;
+
+                    break;
+                  }
+
+                } while ( last != best_segment_first );
+              }
+            }
+
+            /* for computing blue zones, we add the y offset as returned */
+            /* by the currently used OpenType feature -- for example,    */
+            /* superscript glyphs might be identical to subscript glyphs */
+            /* with a vertical shift                                     */
+            best_y += y_offset;
+
+#ifdef FT_DEBUG_LEVEL_TRACE
+            if ( num_idx == 1 )
+              FT_TRACE5(( "  U+%04lX: best_y = %5ld", ch, best_y ));
+            else
+              FT_TRACE5(( "  component %d of cluster starting with U+%04lX:"
+                          " best_y = %5ld", i, ch, best_y ));
+#endif
+
+            /* now set the `round' flag depending on the segment's kind: */
+            /*                                                           */
+            /* - if the horizontal distance between the first and last   */
+            /*   `on' point is larger than a heuristic threshold         */
+            /*   we have a flat segment                                  */
+            /* - if either the first or the last point of the segment is */
+            /*   an `off' point, the segment is round, otherwise it is   */
+            /*   flat                                                    */
+            if ( best_on_point_first >= 0                               &&
+                 best_on_point_last >= 0                                &&
+                 ( FT_ABS( points[best_on_point_last].x -
+                           points[best_on_point_first].x ) ) >
+                   flat_threshold                                       )
+              round = 0;
+            else
+              round = FT_BOOL(
+                        FT_CURVE_TAG( outline.tags[best_segment_first] ) !=
+                          FT_CURVE_TAG_ON                                   ||
+                        FT_CURVE_TAG( outline.tags[best_segment_last]  ) !=
+                          FT_CURVE_TAG_ON                                   );
+
+            if ( round && AF_LATIN_IS_NEUTRAL_BLUE( bs ) )
+            {
+              /* only use flat segments for a neutral blue zone */
+              FT_TRACE5(( " (round, skipped)\n" ));
+              continue;
+            }
+
+            FT_TRACE5(( " (%s)\n", round ? "round" : "flat" ));
+          }
+
+          if ( AF_LATIN_IS_TOP_BLUE( bs ) )
+          {
+            if ( best_y > best_y_extremum )
+            {
+              best_y_extremum = best_y;
+              best_round      = round;
+            }
+          }
+          else
+          {
+            if ( best_y < best_y_extremum )
+            {
+              best_y_extremum = best_y;
+              best_round      = round;
+            }
+          }
+
+        } /* end for loop */
+
+        if ( !( best_y_extremum == FT_INT_MIN ||
+                best_y_extremum == FT_INT_MAX ) )
+        {
+          if ( best_round )
+            rounds[num_rounds++] = best_y_extremum;
+          else
+            flats[num_flats++]   = best_y_extremum;
+        }
+
+      } /* end while loop */
+
+      if ( num_flats == 0 && num_rounds == 0 )
+      {
+        /*
+         *  we couldn't find a single glyph to compute this blue zone,
+         *  we will simply ignore it then
+         */
+        FT_TRACE5(( "  empty\n" ));
+        continue;
+      }
+
+      /* we have computed the contents of the `rounds' and `flats' tables, */
+      /* now determine the reference and overshoot position of the blue -- */
+      /* we simply take the median value after a simple sort               */
+      af_sort_pos( num_rounds, rounds );
+      af_sort_pos( num_flats,  flats );
+
+      blue       = &axis->blues[axis->blue_count];
+      blue_ref   = &blue->ref.org;
+      blue_shoot = &blue->shoot.org;
+
+      axis->blue_count++;
+
+      if ( num_flats == 0 )
+      {
+        *blue_ref   =
+        *blue_shoot = rounds[num_rounds / 2];
+      }
+      else if ( num_rounds == 0 )
+      {
+        *blue_ref   =
+        *blue_shoot = flats[num_flats / 2];
+      }
+      else
+      {
+        *blue_ref   = flats [num_flats  / 2];
+        *blue_shoot = rounds[num_rounds / 2];
+      }
+
+      /* there are sometimes problems: if the overshoot position of top     */
+      /* zones is under its reference position, or the opposite for bottom  */
+      /* zones.  We must thus check everything there and correct the errors */
+      if ( *blue_shoot != *blue_ref )
+      {
+        FT_Pos   ref      = *blue_ref;
+        FT_Pos   shoot    = *blue_shoot;
+        FT_Bool  over_ref = FT_BOOL( shoot > ref );
+
+
+        if ( ( AF_LATIN_IS_TOP_BLUE( bs )    ||
+               AF_LATIN_IS_SUB_TOP_BLUE( bs) ) ^ over_ref )
+        {
+          *blue_ref   =
+          *blue_shoot = ( shoot + ref ) / 2;
+
+          FT_TRACE5(( "  [overshoot smaller than reference,"
+                      " taking mean value]\n" ));
+        }
+      }
+
+      blue->ascender  = ascender;
+      blue->descender = descender;
+
+      blue->flags = 0;
+      if ( AF_LATIN_IS_TOP_BLUE( bs ) )
+        blue->flags |= AF_LATIN_BLUE_TOP;
+      if ( AF_LATIN_IS_SUB_TOP_BLUE( bs ) )
+        blue->flags |= AF_LATIN_BLUE_SUB_TOP;
+      if ( AF_LATIN_IS_NEUTRAL_BLUE( bs ) )
+        blue->flags |= AF_LATIN_BLUE_NEUTRAL;
+
+      /*
+       * The following flag is used later to adjust the y and x scales
+       * in order to optimize the pixel grid alignment of the top of small
+       * letters.
+       */
+      if ( AF_LATIN_IS_X_HEIGHT_BLUE( bs ) )
+        blue->flags |= AF_LATIN_BLUE_ADJUSTMENT;
+
+      FT_TRACE5(( "    -> reference = %ld\n"
+                  "       overshoot = %ld\n",
+                  *blue_ref, *blue_shoot ));
+
+    } /* end for loop */
+
+    af_shaper_buf_destroy( face, shaper_buf );
+
+    FT_TRACE5(( "\n" ));
+
+    return;
+  }
+
+
+  /* Check whether all ASCII digits have the same advance width. */
+
+  FT_LOCAL_DEF( void )
+  af_latin_metrics_check_digits( AF_LatinMetrics  metrics,
+                                 FT_Face          face )
+  {
+    FT_Bool   started = 0, same_width = 1;
+    FT_Fixed  advance, old_advance = 0;
+
+    void*  shaper_buf;
+
+    /* in all supported charmaps, digits have character codes 0x30-0x39 */
+    const char   digits[] = "0 1 2 3 4 5 6 7 8 9";
+    const char*  p;
+
+
+    p          = digits;
+    shaper_buf = af_shaper_buf_create( face );
+
+    while ( *p )
+    {
+      FT_ULong      glyph_index;
+      unsigned int  num_idx;
+
+
+      /* reject input that maps to more than a single glyph */
+      p = af_shaper_get_cluster( p, &metrics->root, shaper_buf, &num_idx );
+      if ( num_idx > 1 )
+        continue;
+
+      glyph_index = af_shaper_get_elem( &metrics->root,
+                                        shaper_buf,
+                                        0,
+                                        &advance,
+                                        NULL );
+      if ( !glyph_index )
+        continue;
+
+      if ( started )
+      {
+        if ( advance != old_advance )
+        {
+          same_width = 0;
+          break;
+        }
+      }
+      else
+      {
+        old_advance = advance;
+        started     = 1;
+      }
+    }
+
+    af_shaper_buf_destroy( face, shaper_buf );
+
+    metrics->root.digits_have_same_width = same_width;
+  }
+
+
+  /* Initialize global metrics. */
+
+  FT_LOCAL_DEF( FT_Error )
+  af_latin_metrics_init( AF_LatinMetrics  metrics,
+                         FT_Face          face )
+  {
+    FT_CharMap  oldmap = face->charmap;
+
+
+    metrics->units_per_em = face->units_per_EM;
+
+    if ( !FT_Select_Charmap( face, FT_ENCODING_UNICODE ) )
+    {
+      af_latin_metrics_init_widths( metrics, face );
+      af_latin_metrics_init_blues( metrics, face );
+      af_latin_metrics_check_digits( metrics, face );
+    }
+
+    FT_Set_Charmap( face, oldmap );
+    return FT_Err_Ok;
+  }
+
+
+  /* Adjust scaling value, then scale and shift widths   */
+  /* and blue zones (if applicable) for given dimension. */
+
+  static void
+  af_latin_metrics_scale_dim( AF_LatinMetrics  metrics,
+                              AF_Scaler        scaler,
+                              AF_Dimension     dim )
+  {
+    FT_Fixed      scale;
+    FT_Pos        delta;
+    AF_LatinAxis  axis;
+    FT_UInt       nn;
+
+
+    if ( dim == AF_DIMENSION_HORZ )
+    {
+      scale = scaler->x_scale;
+      delta = scaler->x_delta;
+    }
+    else
+    {
+      scale = scaler->y_scale;
+      delta = scaler->y_delta;
+    }
+
+    axis = &metrics->axis[dim];
+
+    if ( axis->org_scale == scale && axis->org_delta == delta )
+      return;
+
+    axis->org_scale = scale;
+    axis->org_delta = delta;
+
+    /*
+     * correct X and Y scale to optimize the alignment of the top of small
+     * letters to the pixel grid
+     */
+    {
+      AF_LatinAxis  Axis = &metrics->axis[AF_DIMENSION_VERT];
+      AF_LatinBlue  blue = NULL;
+
+
+      for ( nn = 0; nn < Axis->blue_count; nn++ )
+      {
+        if ( Axis->blues[nn].flags & AF_LATIN_BLUE_ADJUSTMENT )
+        {
+          blue = &Axis->blues[nn];
+          break;
+        }
+      }
+
+      if ( blue )
+      {
+        FT_Pos   scaled;
+        FT_Pos   threshold;
+        FT_Pos   fitted;
+        FT_UInt  limit;
+        FT_UInt  ppem;
+
+
+        scaled    = FT_MulFix( blue->shoot.org, scale );
+        ppem      = metrics->root.scaler.face->size->metrics.x_ppem;
+        limit     = metrics->root.globals->increase_x_height;
+        threshold = 40;
+
+        /* if the `increase-x-height' property is active, */
+        /* we round up much more often                    */
+        if ( limit                                 &&
+             ppem <= limit                         &&
+             ppem >= AF_PROP_INCREASE_X_HEIGHT_MIN )
+          threshold = 52;
+
+        fitted = ( scaled + threshold ) & ~63;
+
+        if ( scaled != fitted )
+        {
+#if 0
+          if ( dim == AF_DIMENSION_HORZ )
+          {
+            if ( fitted < scaled )
+              scale -= scale / 50;  /* scale *= 0.98 */
+          }
+          else
+#endif
+          if ( dim == AF_DIMENSION_VERT )
+          {
+            FT_Pos    max_height;
+            FT_Pos    dist;
+            FT_Fixed  new_scale;
+
+
+            new_scale = FT_MulDiv( scale, fitted, scaled );
+
+            /* the scaling should not change the result by more than two pixels */
+            max_height = metrics->units_per_em;
+
+            for ( nn = 0; nn < Axis->blue_count; nn++ )
+            {
+              max_height = FT_MAX( max_height, Axis->blues[nn].ascender );
+              max_height = FT_MAX( max_height, -Axis->blues[nn].descender );
+            }
+
+            dist  = FT_ABS( FT_MulFix( max_height, new_scale - scale ) );
+            dist &= ~127;
+
+            if ( dist == 0 )
+            {
+              FT_TRACE5((
+                "af_latin_metrics_scale_dim:"
+                " x height alignment (style `%s'):\n"
+                "                           "
+                " vertical scaling changed from %.4f to %.4f (by %d%%)\n"
+                "\n",
+                af_style_names[metrics->root.style_class->style],
+                scale / 65536.0,
+                new_scale / 65536.0,
+                ( fitted - scaled ) * 100 / scaled ));
+
+              scale = new_scale;
+            }
+#ifdef FT_DEBUG_LEVEL_TRACE
+            else
+            {
+              FT_TRACE5((
+                "af_latin_metrics_scale_dim:"
+                " x height alignment (style `%s'):\n"
+                "                           "
+                " excessive vertical scaling abandoned\n"
+                "\n",
+                af_style_names[metrics->root.style_class->style] ));
+            }
+#endif
+          }
+        }
+      }
+    }
+
+    axis->scale = scale;
+    axis->delta = delta;
+
+    if ( dim == AF_DIMENSION_HORZ )
+    {
+      metrics->root.scaler.x_scale = scale;
+      metrics->root.scaler.x_delta = delta;
+    }
+    else
+    {
+      metrics->root.scaler.y_scale = scale;
+      metrics->root.scaler.y_delta = delta;
+    }
+
+    FT_TRACE5(( "%s widths (style `%s')\n",
+                dim == AF_DIMENSION_HORZ ? "horizontal" : "vertical",
+                af_style_names[metrics->root.style_class->style] ));
+
+    /* scale the widths */
+    for ( nn = 0; nn < axis->width_count; nn++ )
+    {
+      AF_Width  width = axis->widths + nn;
+
+
+      width->cur = FT_MulFix( width->org, scale );
+      width->fit = width->cur;
+
+      FT_TRACE5(( "  %d scaled to %.2f\n",
+                  width->org,
+                  width->cur / 64.0 ));
+    }
+
+    FT_TRACE5(( "\n" ));
+
+    /* an extra-light axis corresponds to a standard width that is */
+    /* smaller than 5/8 pixels                                     */
+    axis->extra_light =
+      (FT_Bool)( FT_MulFix( axis->standard_width, scale ) < 32 + 8 );
+
+#ifdef FT_DEBUG_LEVEL_TRACE
+    if ( axis->extra_light )
+      FT_TRACE5(( "`%s' style is extra light (at current resolution)\n"
+                  "\n",
+                  af_style_names[metrics->root.style_class->style] ));
+#endif
+
+    if ( dim == AF_DIMENSION_VERT )
+    {
+#ifdef FT_DEBUG_LEVEL_TRACE
+      if ( axis->blue_count )
+        FT_TRACE5(( "blue zones (style `%s')\n",
+                    af_style_names[metrics->root.style_class->style] ));
+#endif
+
+      /* scale the blue zones */
+      for ( nn = 0; nn < axis->blue_count; nn++ )
+      {
+        AF_LatinBlue  blue = &axis->blues[nn];
+        FT_Pos        dist;
+
+
+        blue->ref.cur   = FT_MulFix( blue->ref.org, scale ) + delta;
+        blue->ref.fit   = blue->ref.cur;
+        blue->shoot.cur = FT_MulFix( blue->shoot.org, scale ) + delta;
+        blue->shoot.fit = blue->shoot.cur;
+        blue->flags    &= ~AF_LATIN_BLUE_ACTIVE;
+
+        /* a blue zone is only active if it is less than 3/4 pixels tall */
+        dist = FT_MulFix( blue->ref.org - blue->shoot.org, scale );
+        if ( dist <= 48 && dist >= -48 )
+        {
+#if 0
+          FT_Pos  delta1;
+#endif
+          FT_Pos  delta2;
+
+
+          /* use discrete values for blue zone widths */
+
+#if 0
+
+          /* generic, original code */
+          delta1 = blue->shoot.org - blue->ref.org;
+          delta2 = delta1;
+          if ( delta1 < 0 )
+            delta2 = -delta2;
+
+          delta2 = FT_MulFix( delta2, scale );
+
+          if ( delta2 < 32 )
+            delta2 = 0;
+          else if ( delta2 < 64 )
+            delta2 = 32 + ( ( ( delta2 - 32 ) + 16 ) & ~31 );
+          else
+            delta2 = FT_PIX_ROUND( delta2 );
+
+          if ( delta1 < 0 )
+            delta2 = -delta2;
+
+          blue->ref.fit   = FT_PIX_ROUND( blue->ref.cur );
+          blue->shoot.fit = blue->ref.fit + delta2;
+
+#else
+
+          /* simplified version due to abs(dist) <= 48 */
+          delta2 = dist;
+          if ( dist < 0 )
+            delta2 = -delta2;
+
+          if ( delta2 < 32 )
+            delta2 = 0;
+          else if ( delta2 < 48 )
+            delta2 = 32;
+          else
+            delta2 = 64;
+
+          if ( dist < 0 )
+            delta2 = -delta2;
+
+          blue->ref.fit   = FT_PIX_ROUND( blue->ref.cur );
+          blue->shoot.fit = blue->ref.fit - delta2;
+
+#endif
+
+          blue->flags |= AF_LATIN_BLUE_ACTIVE;
+        }
+      }
+
+      /* use sub-top blue zone only if it doesn't overlap with */
+      /* another (non-sup-top) blue zone; otherwise, the       */
+      /* effect would be similar to a neutral blue zone, which */
+      /* is not desired here                                   */
+      for ( nn = 0; nn < axis->blue_count; nn++ )
+      {
+        AF_LatinBlue  blue = &axis->blues[nn];
+        FT_UInt       i;
+
+
+        if ( !( blue->flags & AF_LATIN_BLUE_SUB_TOP ) )
+          continue;
+        if ( !( blue->flags & AF_LATIN_BLUE_ACTIVE ) )
+          continue;
+
+        for ( i = 0; i < axis->blue_count; i++ )
+        {
+          AF_LatinBlue  b = &axis->blues[i];
+
+
+          if ( b->flags & AF_LATIN_BLUE_SUB_TOP )
+            continue;
+          if ( !( b->flags & AF_LATIN_BLUE_ACTIVE ) )
+            continue;
+
+          if ( b->ref.fit <= blue->shoot.fit &&
+               b->shoot.fit >= blue->ref.fit )
+          {
+            blue->flags &= ~AF_LATIN_BLUE_ACTIVE;
+            break;
+          }
+        }
+      }
+
+#ifdef FT_DEBUG_LEVEL_TRACE
+      for ( nn = 0; nn < axis->blue_count; nn++ )
+      {
+        AF_LatinBlue  blue = &axis->blues[nn];
+
+
+        FT_TRACE5(( "  reference %d: %d scaled to %.2f%s\n"
+                    "  overshoot %d: %d scaled to %.2f%s\n",
+                    nn,
+                    blue->ref.org,
+                    blue->ref.fit / 64.0,
+                    blue->flags & AF_LATIN_BLUE_ACTIVE ? ""
+                                                       : " (inactive)",
+                    nn,
+                    blue->shoot.org,
+                    blue->shoot.fit / 64.0,
+                    blue->flags & AF_LATIN_BLUE_ACTIVE ? ""
+                                                       : " (inactive)" ));
+      }
+#endif
+    }
+  }
+
+
+  /* Scale global values in both directions. */
+
+  FT_LOCAL_DEF( void )
+  af_latin_metrics_scale( AF_LatinMetrics  metrics,
+                          AF_Scaler        scaler )
+  {
+    metrics->root.scaler.render_mode = scaler->render_mode;
+    metrics->root.scaler.face        = scaler->face;
+    metrics->root.scaler.flags       = scaler->flags;
+
+    af_latin_metrics_scale_dim( metrics, scaler, AF_DIMENSION_HORZ );
+    af_latin_metrics_scale_dim( metrics, scaler, AF_DIMENSION_VERT );
+  }
+
+
+  /* Extract standard_width from writing system/script specific */
+  /* metrics class.                                             */
+
+  FT_LOCAL_DEF( void )
+  af_latin_get_standard_widths( AF_LatinMetrics  metrics,
+                                FT_Pos*          stdHW,
+                                FT_Pos*          stdVW )
+  {
+    if ( stdHW )
+      *stdHW = metrics->axis[AF_DIMENSION_VERT].standard_width;
+
+    if ( stdVW )
+      *stdVW = metrics->axis[AF_DIMENSION_HORZ].standard_width;
+  }
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*****                                                               *****/
+  /*****           L A T I N   G L Y P H   A N A L Y S I S             *****/
+  /*****                                                               *****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /* Walk over all contours and compute its segments. */
+
+  FT_LOCAL_DEF( FT_Error )
+  af_latin_hints_compute_segments( AF_GlyphHints  hints,
+                                   AF_Dimension   dim )
+  {
+    AF_LatinMetrics  metrics       = (AF_LatinMetrics)hints->metrics;
+    AF_AxisHints     axis          = &hints->axis[dim];
+    FT_Memory        memory        = hints->memory;
+    FT_Error         error         = FT_Err_Ok;
+    AF_Segment       segment       = NULL;
+    AF_SegmentRec    seg0;
+    AF_Point*        contour       = hints->contours;
+    AF_Point*        contour_limit = contour + hints->num_contours;
+    AF_Direction     major_dir, segment_dir;
+
+    FT_Pos  flat_threshold = FLAT_THRESHOLD( metrics->units_per_em );
+
+
+    FT_ZERO( &seg0 );
+    seg0.score = 32000;
+    seg0.flags = AF_EDGE_NORMAL;
+
+    major_dir   = (AF_Direction)FT_ABS( axis->major_dir );
+    segment_dir = major_dir;
+
+    axis->num_segments = 0;
+
+    /* set up (u,v) in each point */
+    if ( dim == AF_DIMENSION_HORZ )
+    {
+      AF_Point  point = hints->points;
+      AF_Point  limit = point + hints->num_points;
+
+
+      for ( ; point < limit; point++ )
+      {
+        point->u = point->fx;
+        point->v = point->fy;
+      }
+    }
+    else
+    {
+      AF_Point  point = hints->points;
+      AF_Point  limit = point + hints->num_points;
+
+
+      for ( ; point < limit; point++ )
+      {
+        point->u = point->fy;
+        point->v = point->fx;
+      }
+    }
+
+    /* do each contour separately */
+    for ( ; contour < contour_limit; contour++ )
+    {
+      AF_Point  point   = contour[0];
+      AF_Point  last    = point->prev;
+      int       on_edge = 0;
+
+      /* we call values measured along a segment (point->v)    */
+      /* `coordinates', and values orthogonal to it (point->u) */
+      /* `positions'                                           */
+      FT_Pos     min_pos      =  32000;
+      FT_Pos     max_pos      = -32000;
+      FT_Pos     min_coord    =  32000;
+      FT_Pos     max_coord    = -32000;
+      FT_UShort  min_flags    =  AF_FLAG_NONE;
+      FT_UShort  max_flags    =  AF_FLAG_NONE;
+      FT_Pos     min_on_coord =  32000;
+      FT_Pos     max_on_coord = -32000;
+
+      FT_Bool  passed;
+
+      AF_Segment  prev_segment = NULL;
+
+      FT_Pos     prev_min_pos      = min_pos;
+      FT_Pos     prev_max_pos      = max_pos;
+      FT_Pos     prev_min_coord    = min_coord;
+      FT_Pos     prev_max_coord    = max_coord;
+      FT_UShort  prev_min_flags    = min_flags;
+      FT_UShort  prev_max_flags    = max_flags;
+      FT_Pos     prev_min_on_coord = min_on_coord;
+      FT_Pos     prev_max_on_coord = max_on_coord;
+
+
+      if ( FT_ABS( last->out_dir )  == major_dir &&
+           FT_ABS( point->out_dir ) == major_dir )
+      {
+        /* we are already on an edge, try to locate its start */
+        last = point;
+
+        for (;;)
+        {
+          point = point->prev;
+          if ( FT_ABS( point->out_dir ) != major_dir )
+          {
+            point = point->next;
+            break;
+          }
+          if ( point == last )
+            break;
+        }
+      }
+
+      last   = point;
+      passed = 0;
+
+      for (;;)
+      {
+        FT_Pos  u, v;
+
+
+        if ( on_edge )
+        {
+          /* get minimum and maximum position */
+          u = point->u;
+          if ( u < min_pos )
+            min_pos = u;
+          if ( u > max_pos )
+            max_pos = u;
+
+          /* get minimum and maximum coordinate together with flags */
+          v = point->v;
+          if ( v < min_coord )
+          {
+            min_coord = v;
+            min_flags = point->flags;
+          }
+          if ( v > max_coord )
+          {
+            max_coord = v;
+            max_flags = point->flags;
+          }
+
+          /* get minimum and maximum coordinate of `on' points */
+          if ( !( point->flags & AF_FLAG_CONTROL ) )
+          {
+            v = point->v;
+            if ( v < min_on_coord )
+              min_on_coord = v;
+            if ( v > max_on_coord )
+              max_on_coord = v;
+          }
+
+          if ( point->out_dir != segment_dir || point == last )
+          {
+            /* check whether the new segment's start point is identical to */
+            /* the previous segment's end point; for example, this might   */
+            /* happen for spikes                                           */
+
+            if ( !prev_segment || segment->first != prev_segment->last )
+            {
+              /* points are different: we are just leaving an edge, thus */
+              /* record a new segment                                    */
+
+              segment->last  = point;
+              segment->pos   = (FT_Short)( ( min_pos + max_pos ) >> 1 );
+              segment->delta = (FT_Short)( ( max_pos - min_pos ) >> 1 );
+
+              /* a segment is round if either its first or last point */
+              /* is a control point, and the length of the on points  */
+              /* inbetween doesn't exceed a heuristic limit           */
+              if ( ( min_flags | max_flags ) & AF_FLAG_CONTROL      &&
+                   ( max_on_coord - min_on_coord ) < flat_threshold )
+                segment->flags |= AF_EDGE_ROUND;
+
+              segment->min_coord = (FT_Short)min_coord;
+              segment->max_coord = (FT_Short)max_coord;
+              segment->height    = segment->max_coord - segment->min_coord;
+
+              prev_segment      = segment;
+              prev_min_pos      = min_pos;
+              prev_max_pos      = max_pos;
+              prev_min_coord    = min_coord;
+              prev_max_coord    = max_coord;
+              prev_min_flags    = min_flags;
+              prev_max_flags    = max_flags;
+              prev_min_on_coord = min_on_coord;
+              prev_max_on_coord = max_on_coord;
+            }
+            else
+            {
+              /* points are the same: we don't create a new segment but */
+              /* merge the current segment with the previous one        */
+
+              if ( prev_segment->last->in_dir == point->in_dir )
+              {
+                /* we have identical directions (this can happen for       */
+                /* degenerate outlines that move zig-zag along the main    */
+                /* axis without changing the coordinate value of the other */
+                /* axis, and where the segments have just been merged):    */
+                /* unify segments                                          */
+
+                /* update constraints */
+
+                if ( prev_min_pos < min_pos )
+                  min_pos = prev_min_pos;
+                if ( prev_max_pos > max_pos )
+                  max_pos = prev_max_pos;
+
+                if ( prev_min_coord < min_coord )
+                {
+                  min_coord = prev_min_coord;
+                  min_flags = prev_min_flags;
+                }
+                if ( prev_max_coord > max_coord )
+                {
+                  max_coord = prev_max_coord;
+                  max_flags = prev_max_flags;
+                }
+
+                if ( prev_min_on_coord < min_on_coord )
+                  min_on_coord = prev_min_on_coord;
+                if ( prev_max_on_coord > max_on_coord )
+                  max_on_coord = prev_max_on_coord;
+
+                prev_segment->last = point;
+                prev_segment->pos  = (FT_Short)( ( min_pos +
+                                                   max_pos ) >> 1 );
+
+                if ( ( min_flags | max_flags ) & AF_FLAG_CONTROL      &&
+                     ( max_on_coord - min_on_coord ) < flat_threshold )
+                  prev_segment->flags |= AF_EDGE_ROUND;
+                else
+                  prev_segment->flags &= ~AF_EDGE_ROUND;
+
+                prev_segment->min_coord = (FT_Short)min_coord;
+                prev_segment->max_coord = (FT_Short)max_coord;
+                prev_segment->height    = prev_segment->max_coord -
+                                          prev_segment->min_coord;
+              }
+              else
+              {
+                /* we have different directions; use the properties of the */
+                /* longer segment and discard the other one                */
+
+                if ( FT_ABS( prev_max_coord - prev_min_coord ) >
+                     FT_ABS( max_coord - min_coord ) )
+                {
+                  /* discard current segment */
+
+                  if ( min_pos < prev_min_pos )
+                    prev_min_pos = min_pos;
+                  if ( max_pos > prev_max_pos )
+                    prev_max_pos = max_pos;
+
+                  prev_segment->last = point;
+                  prev_segment->pos  = (FT_Short)( ( prev_min_pos +
+                                                     prev_max_pos ) >> 1 );
+                }
+                else
+                {
+                  /* discard previous segment */
+
+                  if ( prev_min_pos < min_pos )
+                    min_pos = prev_min_pos;
+                  if ( prev_max_pos > max_pos )
+                    max_pos = prev_max_pos;
+
+                  segment->last = point;
+                  segment->pos  = (FT_Short)( ( min_pos + max_pos ) >> 1 );
+
+                  if ( ( min_flags | max_flags ) & AF_FLAG_CONTROL      &&
+                       ( max_on_coord - min_on_coord ) < flat_threshold )
+                    segment->flags |= AF_EDGE_ROUND;
+
+                  segment->min_coord = (FT_Short)min_coord;
+                  segment->max_coord = (FT_Short)max_coord;
+                  segment->height    = segment->max_coord -
+                                       segment->min_coord;
+
+                  *prev_segment = *segment;
+
+                  prev_min_pos      = min_pos;
+                  prev_max_pos      = max_pos;
+                  prev_min_coord    = min_coord;
+                  prev_max_coord    = max_coord;
+                  prev_min_flags    = min_flags;
+                  prev_max_flags    = max_flags;
+                  prev_min_on_coord = min_on_coord;
+                  prev_max_on_coord = max_on_coord;
+                }
+              }
+
+              axis->num_segments--;
+            }
+
+            on_edge = 0;
+            segment = NULL;
+
+            /* fall through */
+          }
+        }
+
+        /* now exit if we are at the start/end point */
+        if ( point == last )
+        {
+          if ( passed )
+            break;
+          passed = 1;
+        }
+
+        /* if we are not on an edge, check whether the major direction */
+        /* coincides with the current point's `out' direction, or      */
+        /* whether we have a single-point contour                      */
+        if ( !on_edge                                  &&
+             ( FT_ABS( point->out_dir ) == major_dir ||
+               point == point->prev                  ) )
+        {
+          /* this is the start of a new segment! */
+          segment_dir = (AF_Direction)point->out_dir;
+
+          error = af_axis_hints_new_segment( axis, memory, &segment );
+          if ( error )
+            goto Exit;
+
+          /* clear all segment fields */
+          segment[0] = seg0;
+
+          segment->dir   = (FT_Char)segment_dir;
+          segment->first = point;
+          segment->last  = point;
+
+          /* `af_axis_hints_new_segment' reallocates memory,    */
+          /* thus we have to refresh the `prev_segment' pointer */
+          if ( prev_segment )
+            prev_segment = segment - 1;
+
+          min_pos   = max_pos   = point->u;
+          min_coord = max_coord = point->v;
+          min_flags = max_flags = point->flags;
+
+          if ( point->flags & AF_FLAG_CONTROL )
+          {
+            min_on_coord =  32000;
+            max_on_coord = -32000;
+          }
+          else
+            min_on_coord = max_on_coord = point->v;
+
+          on_edge = 1;
+
+          if ( point == point->prev )
+          {
+            /* we have a one-point segment: this is a one-point */
+            /* contour with `in' and `out' direction set to     */
+            /* AF_DIR_NONE                                      */
+            segment->pos = (FT_Short)min_pos;
+
+            if (point->flags & AF_FLAG_CONTROL)
+              segment->flags |= AF_EDGE_ROUND;
+
+            segment->min_coord = (FT_Short)point->v;
+            segment->max_coord = (FT_Short)point->v;
+            segment->height = 0;
+
+            on_edge = 0;
+            segment = NULL;
+          }
+        }
+
+        point = point->next;
+      }
+
+    } /* contours */
+
+
+    /* now slightly increase the height of segments if this makes */
+    /* sense -- this is used to better detect and ignore serifs   */
+    {
+      AF_Segment  segments     = axis->segments;
+      AF_Segment  segments_end = segments + axis->num_segments;
+
+
+      for ( segment = segments; segment < segments_end; segment++ )
+      {
+        AF_Point  first   = segment->first;
+        AF_Point  last    = segment->last;
+        FT_Pos    first_v = first->v;
+        FT_Pos    last_v  = last->v;
+
+
+        if ( first_v < last_v )
+        {
+          AF_Point  p;
+
+
+          p = first->prev;
+          if ( p->v < first_v )
+            segment->height = (FT_Short)( segment->height +
+                                          ( ( first_v - p->v ) >> 1 ) );
+
+          p = last->next;
+          if ( p->v > last_v )
+            segment->height = (FT_Short)( segment->height +
+                                          ( ( p->v - last_v ) >> 1 ) );
+        }
+        else
+        {
+          AF_Point  p;
+
+
+          p = first->prev;
+          if ( p->v > first_v )
+            segment->height = (FT_Short)( segment->height +
+                                          ( ( p->v - first_v ) >> 1 ) );
+
+          p = last->next;
+          if ( p->v < last_v )
+            segment->height = (FT_Short)( segment->height +
+                                          ( ( last_v - p->v ) >> 1 ) );
+        }
+      }
+    }
+
+  Exit:
+    return error;
+  }
+
+
+  /* Link segments to form stems and serifs.  If `width_count' and      */
+  /* `widths' are non-zero, use them to fine-tune the scoring function. */
+
+  FT_LOCAL_DEF( void )
+  af_latin_hints_link_segments( AF_GlyphHints  hints,
+                                FT_UInt        width_count,
+                                AF_WidthRec*   widths,
+                                AF_Dimension   dim )
+  {
+    AF_AxisHints  axis          = &hints->axis[dim];
+    AF_Segment    segments      = axis->segments;
+    AF_Segment    segment_limit = segments + axis->num_segments;
+    FT_Pos        len_threshold, len_score, dist_score, max_width;
+    AF_Segment    seg1, seg2;
+
+
+    if ( width_count )
+      max_width = widths[width_count - 1].org;
+    else
+      max_width = 0;
+
+    /* a heuristic value to set up a minimum value for overlapping */
+    len_threshold = AF_LATIN_CONSTANT( hints->metrics, 8 );
+    if ( len_threshold == 0 )
+      len_threshold = 1;
+
+    /* a heuristic value to weight lengths */
+    len_score = AF_LATIN_CONSTANT( hints->metrics, 6000 );
+
+    /* a heuristic value to weight distances (no call to    */
+    /* AF_LATIN_CONSTANT needed, since we work on multiples */
+    /* of the stem width)                                   */
+    dist_score = 3000;
+
+    /* now compare each segment to the others */
+    for ( seg1 = segments; seg1 < segment_limit; seg1++ )
+    {
+      if ( seg1->dir != axis->major_dir )
+        continue;
+
+      /* search for stems having opposite directions, */
+      /* with seg1 to the `left' of seg2              */
+      for ( seg2 = segments; seg2 < segment_limit; seg2++ )
+      {
+        FT_Pos  pos1 = seg1->pos;
+        FT_Pos  pos2 = seg2->pos;
+
+
+        if ( seg1->dir + seg2->dir == 0 && pos2 > pos1 )
+        {
+          /* compute distance between the two segments */
+          FT_Pos  min = seg1->min_coord;
+          FT_Pos  max = seg1->max_coord;
+          FT_Pos  len;
+
+
+          if ( min < seg2->min_coord )
+            min = seg2->min_coord;
+
+          if ( max > seg2->max_coord )
+            max = seg2->max_coord;
+
+          /* compute maximum coordinate difference of the two segments */
+          /* (this is, how much they overlap)                          */
+          len = max - min;
+          if ( len >= len_threshold )
+          {
+            /*
+             *  The score is the sum of two demerits indicating the
+             *  `badness' of a fit, measured along the segments' main axis
+             *  and orthogonal to it, respectively.
+             *
+             *  o The less overlapping along the main axis, the worse it
+             *    is, causing a larger demerit.
+             *
+             *  o The nearer the orthogonal distance to a stem width, the
+             *    better it is, causing a smaller demerit.  For simplicity,
+             *    however, we only increase the demerit for values that
+             *    exceed the largest stem width.
+             */
+
+            FT_Pos  dist = pos2 - pos1;
+
+            FT_Pos  dist_demerit, score;
+
+
+            if ( max_width )
+            {
+              /* distance demerits are based on multiples of `max_width'; */
+              /* we scale by 1024 for getting more precision              */
+              FT_Pos  delta = ( dist << 10 ) / max_width - ( 1 << 10 );
+
+
+              if ( delta > 10000 )
+                dist_demerit = 32000;
+              else if ( delta > 0 )
+                dist_demerit = delta * delta / dist_score;
+              else
+                dist_demerit = 0;
+            }
+            else
+              dist_demerit = dist; /* default if no widths available */
+
+            score = dist_demerit + len_score / len;
+
+            /* and we search for the smallest score */
+            if ( score < seg1->score )
+            {
+              seg1->score = score;
+              seg1->link  = seg2;
+            }
+
+            if ( score < seg2->score )
+            {
+              seg2->score = score;
+              seg2->link  = seg1;
+            }
+          }
+        }
+      }
+    }
+
+    /* now compute the `serif' segments, cf. explanations in `afhints.h' */
+    for ( seg1 = segments; seg1 < segment_limit; seg1++ )
+    {
+      seg2 = seg1->link;
+
+      if ( seg2 )
+      {
+        if ( seg2->link != seg1 )
+        {
+          seg1->link  = 0;
+          seg1->serif = seg2->link;
+        }
+      }
+    }
+  }
+
+
+  /* Link segments to edges, using feature analysis for selection. */
+
+  FT_LOCAL_DEF( FT_Error )
+  af_latin_hints_compute_edges( AF_GlyphHints  hints,
+                                AF_Dimension   dim )
+  {
+    AF_AxisHints  axis   = &hints->axis[dim];
+    FT_Error      error  = FT_Err_Ok;
+    FT_Memory     memory = hints->memory;
+    AF_LatinAxis  laxis  = &((AF_LatinMetrics)hints->metrics)->axis[dim];
+
+    AF_StyleClass   style_class  = hints->metrics->style_class;
+    AF_ScriptClass  script_class = AF_SCRIPT_CLASSES_GET
+                                     [style_class->script];
+
+    FT_Bool  top_to_bottom_hinting = 0;
+
+    AF_Segment    segments      = axis->segments;
+    AF_Segment    segment_limit = segments + axis->num_segments;
+    AF_Segment    seg;
+
+#if 0
+    AF_Direction  up_dir;
+#endif
+    FT_Fixed      scale;
+    FT_Pos        edge_distance_threshold;
+    FT_Pos        segment_length_threshold;
+    FT_Pos        segment_width_threshold;
+
+
+    axis->num_edges = 0;
+
+    scale = ( dim == AF_DIMENSION_HORZ ) ? hints->x_scale
+                                         : hints->y_scale;
+
+#if 0
+    up_dir = ( dim == AF_DIMENSION_HORZ ) ? AF_DIR_UP
+                                          : AF_DIR_RIGHT;
+#endif
+
+    if ( dim == AF_DIMENSION_VERT )
+      top_to_bottom_hinting = script_class->top_to_bottom_hinting;
+
+    /*
+     *  We ignore all segments that are less than 1 pixel in length
+     *  to avoid many problems with serif fonts.  We compute the
+     *  corresponding threshold in font units.
+     */
+    if ( dim == AF_DIMENSION_HORZ )
+      segment_length_threshold = FT_DivFix( 64, hints->y_scale );
+    else
+      segment_length_threshold = 0;
+
+    /*
+     *  Similarly, we ignore segments that have a width delta
+     *  larger than 0.5px (i.e., a width larger than 1px).
+     */
+    segment_width_threshold = FT_DivFix( 32, scale );
+
+    /*********************************************************************/
+    /*                                                                   */
+    /* We begin by generating a sorted table of edges for the current    */
+    /* direction.  To do so, we simply scan each segment and try to find */
+    /* an edge in our table that corresponds to its position.            */
+    /*                                                                   */
+    /* If no edge is found, we create and insert a new edge in the       */
+    /* sorted table.  Otherwise, we simply add the segment to the edge's */
+    /* list which gets processed in the second step to compute the       */
+    /* edge's properties.                                                */
+    /*                                                                   */
+    /* Note that the table of edges is sorted along the segment/edge     */
+    /* position.                                                         */
+    /*                                                                   */
+    /*********************************************************************/
+
+    /* assure that edge distance threshold is at most 0.25px */
+    edge_distance_threshold = FT_MulFix( laxis->edge_distance_threshold,
+                                         scale );
+    if ( edge_distance_threshold > 64 / 4 )
+      edge_distance_threshold = 64 / 4;
+
+    edge_distance_threshold = FT_DivFix( edge_distance_threshold,
+                                         scale );
+
+    for ( seg = segments; seg < segment_limit; seg++ )
+    {
+      AF_Edge  found = NULL;
+      FT_Int   ee;
+
+
+      /* ignore too short segments, too wide ones, and, in this loop, */
+      /* one-point segments without a direction                       */
+      if ( seg->height < segment_length_threshold ||
+           seg->delta > segment_width_threshold   ||
+           seg->dir == AF_DIR_NONE                )
+        continue;
+
+      /* A special case for serif edges: If they are smaller than */
+      /* 1.5 pixels we ignore them.                               */
+      if ( seg->serif                                     &&
+           2 * seg->height < 3 * segment_length_threshold )
+        continue;
+
+      /* look for an edge corresponding to the segment */
+      for ( ee = 0; ee < axis->num_edges; ee++ )
+      {
+        AF_Edge  edge = axis->edges + ee;
+        FT_Pos   dist;
+
+
+        dist = seg->pos - edge->fpos;
+        if ( dist < 0 )
+          dist = -dist;
+
+        if ( dist < edge_distance_threshold && edge->dir == seg->dir )
+        {
+          found = edge;
+          break;
+        }
+      }
+
+      if ( !found )
+      {
+        AF_Edge  edge;
+
+
+        /* insert a new edge in the list and */
+        /* sort according to the position    */
+        error = af_axis_hints_new_edge( axis, seg->pos,
+                                        (AF_Direction)seg->dir,
+                                        top_to_bottom_hinting,
+                                        memory, &edge );
+        if ( error )
+          goto Exit;
+
+        /* add the segment to the new edge's list */
+        FT_ZERO( edge );
+
+        edge->first    = seg;
+        edge->last     = seg;
+        edge->dir      = seg->dir;
+        edge->fpos     = seg->pos;
+        edge->opos     = FT_MulFix( seg->pos, scale );
+        edge->pos      = edge->opos;
+        seg->edge_next = seg;
+      }
+      else
+      {
+        /* if an edge was found, simply add the segment to the edge's */
+        /* list                                                       */
+        seg->edge_next         = found->first;
+        found->last->edge_next = seg;
+        found->last            = seg;
+      }
+    }
+
+    /* we loop again over all segments to catch one-point segments   */
+    /* without a direction: if possible, link them to existing edges */
+    for ( seg = segments; seg < segment_limit; seg++ )
+    {
+      AF_Edge  found = NULL;
+      FT_Int   ee;
+
+
+      if ( seg->dir != AF_DIR_NONE )
+        continue;
+
+      /* look for an edge corresponding to the segment */
+      for ( ee = 0; ee < axis->num_edges; ee++ )
+      {
+        AF_Edge  edge = axis->edges + ee;
+        FT_Pos   dist;
+
+
+        dist = seg->pos - edge->fpos;
+        if ( dist < 0 )
+          dist = -dist;
+
+        if ( dist < edge_distance_threshold )
+        {
+          found = edge;
+          break;
+        }
+      }
+
+      /* one-point segments without a match are ignored */
+      if ( found )
+      {
+        seg->edge_next         = found->first;
+        found->last->edge_next = seg;
+        found->last            = seg;
+      }
+    }
+
+
+    /******************************************************************/
+    /*                                                                */
+    /* Good, we now compute each edge's properties according to the   */
+    /* segments found on its position.  Basically, these are          */
+    /*                                                                */
+    /*  - the edge's main direction                                   */
+    /*  - stem edge, serif edge or both (which defaults to stem then) */
+    /*  - rounded edge, straight or both (which defaults to straight) */
+    /*  - link for edge                                               */
+    /*                                                                */
+    /******************************************************************/
+
+    /* first of all, set the `edge' field in each segment -- this is */
+    /* required in order to compute edge links                       */
+
+    /*
+     * Note that removing this loop and setting the `edge' field of each
+     * segment directly in the code above slows down execution speed for
+     * some reasons on platforms like the Sun.
+     */
+    {
+      AF_Edge  edges      = axis->edges;
+      AF_Edge  edge_limit = edges + axis->num_edges;
+      AF_Edge  edge;
+
+
+      for ( edge = edges; edge < edge_limit; edge++ )
+      {
+        seg = edge->first;
+        if ( seg )
+          do
+          {
+            seg->edge = edge;
+            seg       = seg->edge_next;
+
+          } while ( seg != edge->first );
+      }
+
+      /* now compute each edge properties */
+      for ( edge = edges; edge < edge_limit; edge++ )
+      {
+        FT_Int  is_round    = 0;  /* does it contain round segments?    */
+        FT_Int  is_straight = 0;  /* does it contain straight segments? */
+#if 0
+        FT_Pos  ups         = 0;  /* number of upwards segments         */
+        FT_Pos  downs       = 0;  /* number of downwards segments       */
+#endif
+
+
+        seg = edge->first;
+
+        do
+        {
+          FT_Bool  is_serif;
+
+
+          /* check for roundness of segment */
+          if ( seg->flags & AF_EDGE_ROUND )
+            is_round++;
+          else
+            is_straight++;
+
+#if 0
+          /* check for segment direction */
+          if ( seg->dir == up_dir )
+            ups   += seg->max_coord - seg->min_coord;
+          else
+            downs += seg->max_coord - seg->min_coord;
+#endif
+
+          /* check for links -- if seg->serif is set, then seg->link must */
+          /* be ignored                                                   */
+          is_serif = (FT_Bool)( seg->serif               &&
+                                seg->serif->edge         &&
+                                seg->serif->edge != edge );
+
+          if ( ( seg->link && seg->link->edge != NULL ) || is_serif )
+          {
+            AF_Edge     edge2;
+            AF_Segment  seg2;
+
+
+            edge2 = edge->link;
+            seg2  = seg->link;
+
+            if ( is_serif )
+            {
+              seg2  = seg->serif;
+              edge2 = edge->serif;
+            }
+
+            if ( edge2 )
+            {
+              FT_Pos  edge_delta;
+              FT_Pos  seg_delta;
+
+
+              edge_delta = edge->fpos - edge2->fpos;
+              if ( edge_delta < 0 )
+                edge_delta = -edge_delta;
+
+              seg_delta = seg->pos - seg2->pos;
+              if ( seg_delta < 0 )
+                seg_delta = -seg_delta;
+
+              if ( seg_delta < edge_delta )
+                edge2 = seg2->edge;
+            }
+            else
+              edge2 = seg2->edge;
+
+            if ( is_serif )
+            {
+              edge->serif   = edge2;
+              edge2->flags |= AF_EDGE_SERIF;
+            }
+            else
+              edge->link  = edge2;
+          }
+
+          seg = seg->edge_next;
+
+        } while ( seg != edge->first );
+
+        /* set the round/straight flags */
+        edge->flags = AF_EDGE_NORMAL;
+
+        if ( is_round > 0 && is_round >= is_straight )
+          edge->flags |= AF_EDGE_ROUND;
+
+#if 0
+        /* set the edge's main direction */
+        edge->dir = AF_DIR_NONE;
+
+        if ( ups > downs )
+          edge->dir = (FT_Char)up_dir;
+
+        else if ( ups < downs )
+          edge->dir = (FT_Char)-up_dir;
+
+        else if ( ups == downs )
+          edge->dir = 0;  /* both up and down! */
+#endif
+
+        /* get rid of serifs if link is set                 */
+        /* XXX: This gets rid of many unpleasant artefacts! */
+        /*      Example: the `c' in cour.pfa at size 13     */
+
+        if ( edge->serif && edge->link )
+          edge->serif = NULL;
+      }
+    }
+
+  Exit:
+    return error;
+  }
+
+
+  /* Detect segments and edges for given dimension. */
+
+  FT_LOCAL_DEF( FT_Error )
+  af_latin_hints_detect_features( AF_GlyphHints  hints,
+                                  FT_UInt        width_count,
+                                  AF_WidthRec*   widths,
+                                  AF_Dimension   dim )
+  {
+    FT_Error  error;
+
+
+    error = af_latin_hints_compute_segments( hints, dim );
+    if ( !error )
+    {
+      af_latin_hints_link_segments( hints, width_count, widths, dim );
+
+      error = af_latin_hints_compute_edges( hints, dim );
+    }
+
+    return error;
+  }
+
+
+  /* Compute all edges which lie within blue zones. */
+
+  static void
+  af_latin_hints_compute_blue_edges( AF_GlyphHints    hints,
+                                     AF_LatinMetrics  metrics )
+  {
+    AF_AxisHints  axis       = &hints->axis[AF_DIMENSION_VERT];
+    AF_Edge       edge       = axis->edges;
+    AF_Edge       edge_limit = edge + axis->num_edges;
+    AF_LatinAxis  latin      = &metrics->axis[AF_DIMENSION_VERT];
+    FT_Fixed      scale      = latin->scale;
+
+
+    /* compute which blue zones are active, i.e. have their scaled */
+    /* size < 3/4 pixels                                           */
+
+    /* for each horizontal edge search the blue zone which is closest */
+    for ( ; edge < edge_limit; edge++ )
+    {
+      FT_UInt   bb;
+      AF_Width  best_blue            = NULL;
+      FT_Bool   best_blue_is_neutral = 0;
+      FT_Pos    best_dist;                 /* initial threshold */
+
+
+      /* compute the initial threshold as a fraction of the EM size */
+      /* (the value 40 is heuristic)                                */
+      best_dist = FT_MulFix( metrics->units_per_em / 40, scale );
+
+      /* assure a minimum distance of 0.5px */
+      if ( best_dist > 64 / 2 )
+        best_dist = 64 / 2;
+
+      for ( bb = 0; bb < latin->blue_count; bb++ )
+      {
+        AF_LatinBlue  blue = latin->blues + bb;
+        FT_Bool       is_top_blue, is_neutral_blue, is_major_dir;
+
+
+        /* skip inactive blue zones (i.e., those that are too large) */
+        if ( !( blue->flags & AF_LATIN_BLUE_ACTIVE ) )
+          continue;
+
+        /* if it is a top zone, check for right edges (against the major */
+        /* direction); if it is a bottom zone, check for left edges (in  */
+        /* the major direction) -- this assumes the TrueType convention  */
+        /* for the orientation of contours                               */
+        is_top_blue =
+          (FT_Byte)( ( blue->flags & ( AF_LATIN_BLUE_TOP     |
+                                       AF_LATIN_BLUE_SUB_TOP ) ) != 0 );
+        is_neutral_blue =
+          (FT_Byte)( ( blue->flags & AF_LATIN_BLUE_NEUTRAL ) != 0);
+        is_major_dir =
+          FT_BOOL( edge->dir == axis->major_dir );
+
+        /* neutral blue zones are handled for both directions */
+        if ( is_top_blue ^ is_major_dir || is_neutral_blue )
+        {
+          FT_Pos  dist;
+
+
+          /* first of all, compare it to the reference position */
+          dist = edge->fpos - blue->ref.org;
+          if ( dist < 0 )
+            dist = -dist;
+
+          dist = FT_MulFix( dist, scale );
+          if ( dist < best_dist )
+          {
+            best_dist            = dist;
+            best_blue            = &blue->ref;
+            best_blue_is_neutral = is_neutral_blue;
+          }
+
+          /* now compare it to the overshoot position and check whether */
+          /* the edge is rounded, and whether the edge is over the      */
+          /* reference position of a top zone, or under the reference   */
+          /* position of a bottom zone (provided we don't have a        */
+          /* neutral blue zone)                                         */
+          if ( edge->flags & AF_EDGE_ROUND &&
+               dist != 0                   &&
+               !is_neutral_blue            )
+          {
+            FT_Bool  is_under_ref = FT_BOOL( edge->fpos < blue->ref.org );
+
+
+            if ( is_top_blue ^ is_under_ref )
+            {
+              dist = edge->fpos - blue->shoot.org;
+              if ( dist < 0 )
+                dist = -dist;
+
+              dist = FT_MulFix( dist, scale );
+              if ( dist < best_dist )
+              {
+                best_dist            = dist;
+                best_blue            = &blue->shoot;
+                best_blue_is_neutral = is_neutral_blue;
+              }
+            }
+          }
+        }
+      }
+
+      if ( best_blue )
+      {
+        edge->blue_edge = best_blue;
+        if ( best_blue_is_neutral )
+          edge->flags |= AF_EDGE_NEUTRAL;
+      }
+    }
+  }
+
+
+  /* Initalize hinting engine. */
+
+  static FT_Error
+  af_latin_hints_init( AF_GlyphHints    hints,
+                       AF_LatinMetrics  metrics )
+  {
+    FT_Render_Mode  mode;
+    FT_UInt32       scaler_flags, other_flags;
+    FT_Face         face = metrics->root.scaler.face;
+
+
+    af_glyph_hints_rescale( hints, (AF_StyleMetrics)metrics );
+
+    /*
+     *  correct x_scale and y_scale if needed, since they may have
+     *  been modified by `af_latin_metrics_scale_dim' above
+     */
+    hints->x_scale = metrics->axis[AF_DIMENSION_HORZ].scale;
+    hints->x_delta = metrics->axis[AF_DIMENSION_HORZ].delta;
+    hints->y_scale = metrics->axis[AF_DIMENSION_VERT].scale;
+    hints->y_delta = metrics->axis[AF_DIMENSION_VERT].delta;
+
+    /* compute flags depending on render mode, etc. */
+    mode = metrics->root.scaler.render_mode;
+
+#if 0 /* #ifdef AF_CONFIG_OPTION_USE_WARPER */
+    if ( mode == FT_RENDER_MODE_LCD || mode == FT_RENDER_MODE_LCD_V )
+      metrics->root.scaler.render_mode = mode = FT_RENDER_MODE_NORMAL;
+#endif
+
+    scaler_flags = hints->scaler_flags;
+    other_flags  = 0;
+
+    /*
+     *  We snap the width of vertical stems for the monochrome and
+     *  horizontal LCD rendering targets only.
+     */
+    if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD )
+      other_flags |= AF_LATIN_HINTS_HORZ_SNAP;
+
+    /*
+     *  We snap the width of horizontal stems for the monochrome and
+     *  vertical LCD rendering targets only.
+     */
+    if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD_V )
+      other_flags |= AF_LATIN_HINTS_VERT_SNAP;
+
+    /*
+     *  We adjust stems to full pixels only if we don't use the `light' mode.
+     */
+    if ( mode != FT_RENDER_MODE_LIGHT )
+      other_flags |= AF_LATIN_HINTS_STEM_ADJUST;
+
+    if ( mode == FT_RENDER_MODE_MONO )
+      other_flags |= AF_LATIN_HINTS_MONO;
+
+    /*
+     *  In `light' hinting mode we disable horizontal hinting completely.
+     *  We also do it if the face is italic.
+     *
+     *  However, if warping is enabled (which only works in `light' hinting
+     *  mode), advance widths get adjusted, too.
+     */
+    if ( mode == FT_RENDER_MODE_LIGHT                      ||
+         ( face->style_flags & FT_STYLE_FLAG_ITALIC ) != 0 )
+      scaler_flags |= AF_SCALER_FLAG_NO_HORIZONTAL;
+
+#ifdef AF_CONFIG_OPTION_USE_WARPER
+    /* get (global) warper flag */
+    if ( !metrics->root.globals->module->warping )
+      scaler_flags |= AF_SCALER_FLAG_NO_WARPER;
+#endif
+
+    hints->scaler_flags = scaler_flags;
+    hints->other_flags  = other_flags;
+
+    return FT_Err_Ok;
+  }
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*****                                                               *****/
+  /*****        L A T I N   G L Y P H   G R I D - F I T T I N G        *****/
+  /*****                                                               *****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+  /* Snap a given width in scaled coordinates to one of the */
+  /* current standard widths.                               */
+
+  static FT_Pos
+  af_latin_snap_width( AF_Width  widths,
+                       FT_UInt   count,
+                       FT_Pos    width )
+  {
+    FT_UInt  n;
+    FT_Pos   best      = 64 + 32 + 2;
+    FT_Pos   reference = width;
+    FT_Pos   scaled;
+
+
+    for ( n = 0; n < count; n++ )
+    {
+      FT_Pos  w;
+      FT_Pos  dist;
+
+
+      w = widths[n].cur;
+      dist = width - w;
+      if ( dist < 0 )
+        dist = -dist;
+      if ( dist < best )
+      {
+        best      = dist;
+        reference = w;
+      }
+    }
+
+    scaled = FT_PIX_ROUND( reference );
+
+    if ( width >= reference )
+    {
+      if ( width < scaled + 48 )
+        width = reference;
+    }
+    else
+    {
+      if ( width > scaled - 48 )
+        width = reference;
+    }
+
+    return width;
+  }
+
+
+  /* Compute the snapped width of a given stem, ignoring very thin ones. */
+  /* There is a lot of voodoo in this function; changing the hard-coded  */
+  /* parameters influence the whole hinting process.                     */
+
+  static FT_Pos
+  af_latin_compute_stem_width( AF_GlyphHints  hints,
+                               AF_Dimension   dim,
+                               FT_Pos         width,
+                               FT_Pos         base_delta,
+                               FT_UInt        base_flags,
+                               FT_UInt        stem_flags )
+  {
+    AF_LatinMetrics  metrics  = (AF_LatinMetrics)hints->metrics;
+    AF_LatinAxis     axis     = &metrics->axis[dim];
+    FT_Pos           dist     = width;
+    FT_Int           sign     = 0;
+    FT_Int           vertical = ( dim == AF_DIMENSION_VERT );
+
+
+    if ( !AF_LATIN_HINTS_DO_STEM_ADJUST( hints ) ||
+         axis->extra_light                       )
+      return width;
+
+    if ( dist < 0 )
+    {
+      dist = -width;
+      sign = 1;
+    }
+
+    if ( (  vertical && !AF_LATIN_HINTS_DO_VERT_SNAP( hints ) ) ||
+         ( !vertical && !AF_LATIN_HINTS_DO_HORZ_SNAP( hints ) ) )
+    {
+      /* smooth hinting process: very lightly quantize the stem width */
+
+      /* leave the widths of serifs alone */
+      if ( ( stem_flags & AF_EDGE_SERIF ) &&
+           vertical                       &&
+           ( dist < 3 * 64 )              )
+        goto Done_Width;
+
+      else if ( base_flags & AF_EDGE_ROUND )
+      {
+        if ( dist < 80 )
+          dist = 64;
+      }
+      else if ( dist < 56 )
+        dist = 56;
+
+      if ( axis->width_count > 0 )
+      {
+        FT_Pos  delta;
+
+
+        /* compare to standard width */
+        delta = dist - axis->widths[0].cur;
+
+        if ( delta < 0 )
+          delta = -delta;
+
+        if ( delta < 40 )
+        {
+          dist = axis->widths[0].cur;
+          if ( dist < 48 )
+            dist = 48;
+
+          goto Done_Width;
+        }
+
+        if ( dist < 3 * 64 )
+        {
+          delta  = dist & 63;
+          dist  &= -64;
+
+          if ( delta < 10 )
+            dist += delta;
+
+          else if ( delta < 32 )
+            dist += 10;
+
+          else if ( delta < 54 )
+            dist += 54;
+
+          else
+            dist += delta;
+        }
+        else
+        {
+          /* A stem's end position depends on two values: the start        */
+          /* position and the stem length.  The former gets usually        */
+          /* rounded to the grid, while the latter gets rounded also if it */
+          /* exceeds a certain length (see below in this function).  This  */
+          /* `double rounding' can lead to a great difference to the       */
+          /* original, unhinted position; this normally doesn't matter for */
+          /* large PPEM values, but for small sizes it can easily make     */
+          /* outlines collide.  For this reason, we adjust the stem length */
+          /* by a small amount depending on the PPEM value in case the     */
+          /* former and latter rounding both point into the same           */
+          /* direction.                                                    */
+
+          FT_Pos  bdelta = 0;
+
+
+          if ( ( ( width > 0 ) && ( base_delta > 0 ) ) ||
+               ( ( width < 0 ) && ( base_delta < 0 ) ) )
+          {
+            FT_UInt  ppem = metrics->root.scaler.face->size->metrics.x_ppem;
+
+
+            if ( ppem < 10 )
+              bdelta = base_delta;
+            else if ( ppem < 30 )
+              bdelta = ( base_delta * (FT_Pos)( 30 - ppem ) ) / 20;
+
+            if ( bdelta < 0 )
+              bdelta = -bdelta;
+          }
+
+          dist = ( dist - bdelta + 32 ) & ~63;
+        }
+      }
+    }
+    else
+    {
+      /* strong hinting process: snap the stem width to integer pixels */
+
+      FT_Pos  org_dist = dist;
+
+
+      dist = af_latin_snap_width( axis->widths, axis->width_count, dist );
+
+      if ( vertical )
+      {
+        /* in the case of vertical hinting, always round */
+        /* the stem heights to integer pixels            */
+
+        if ( dist >= 64 )
+          dist = ( dist + 16 ) & ~63;
+        else
+          dist = 64;
+      }
+      else
+      {
+        if ( AF_LATIN_HINTS_DO_MONO( hints ) )
+        {
+          /* monochrome horizontal hinting: snap widths to integer pixels */
+          /* with a different threshold                                   */
+
+          if ( dist < 64 )
+            dist = 64;
+          else
+            dist = ( dist + 32 ) & ~63;
+        }
+        else
+        {
+          /* for horizontal anti-aliased hinting, we adopt a more subtle */
+          /* approach: we strengthen small stems, round stems whose size */
+          /* is between 1 and 2 pixels to an integer, otherwise nothing  */
+
+          if ( dist < 48 )
+            dist = ( dist + 64 ) >> 1;
+
+          else if ( dist < 128 )
+          {
+            /* We only round to an integer width if the corresponding */
+            /* distortion is less than 1/4 pixel.  Otherwise this     */
+            /* makes everything worse since the diagonals, which are  */
+            /* not hinted, appear a lot bolder or thinner than the    */
+            /* vertical stems.                                        */
+
+            FT_Pos  delta;
+
+
+            dist = ( dist + 22 ) & ~63;
+            delta = dist - org_dist;
+            if ( delta < 0 )
+              delta = -delta;
+
+            if ( delta >= 16 )
+            {
+              dist = org_dist;
+              if ( dist < 48 )
+                dist = ( dist + 64 ) >> 1;
+            }
+          }
+          else
+            /* round otherwise to prevent color fringes in LCD mode */
+            dist = ( dist + 32 ) & ~63;
+        }
+      }
+    }
+
+  Done_Width:
+    if ( sign )
+      dist = -dist;
+
+    return dist;
+  }
+
+
+  /* Align one stem edge relative to the previous stem edge. */
+
+  static void
+  af_latin_align_linked_edge( AF_GlyphHints  hints,
+                              AF_Dimension   dim,
+                              AF_Edge        base_edge,
+                              AF_Edge        stem_edge )
+  {
+    FT_Pos  dist, base_delta;
+    FT_Pos  fitted_width;
+
+
+    dist       = stem_edge->opos - base_edge->opos;
+    base_delta = base_edge->pos - base_edge->opos;
+
+    fitted_width = af_latin_compute_stem_width( hints, dim,
+                                                dist, base_delta,
+                                                base_edge->flags,
+                                                stem_edge->flags );
+
+
+    stem_edge->pos = base_edge->pos + fitted_width;
+
+    FT_TRACE5(( "  LINK: edge %d (opos=%.2f) linked to %.2f,"
+                " dist was %.2f, now %.2f\n",
+                stem_edge - hints->axis[dim].edges, stem_edge->opos / 64.0,
+                stem_edge->pos / 64.0, dist / 64.0, fitted_width / 64.0 ));
+  }
+
+
+  /* Shift the coordinates of the `serif' edge by the same amount */
+  /* as the corresponding `base' edge has been moved already.     */
+
+  static void
+  af_latin_align_serif_edge( AF_GlyphHints  hints,
+                             AF_Edge        base,
+                             AF_Edge        serif )
+  {
+    FT_UNUSED( hints );
+
+    serif->pos = base->pos + ( serif->opos - base->opos );
+  }
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****                    E D G E   H I N T I N G                      ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /* The main grid-fitting routine. */
+
+  static void
+  af_latin_hint_edges( AF_GlyphHints  hints,
+                       AF_Dimension   dim )
+  {
+    AF_AxisHints  axis       = &hints->axis[dim];
+    AF_Edge       edges      = axis->edges;
+    AF_Edge       edge_limit = edges + axis->num_edges;
+    FT_PtrDist    n_edges;
+    AF_Edge       edge;
+    AF_Edge       anchor     = NULL;
+    FT_Int        has_serifs = 0;
+
+    AF_StyleClass   style_class  = hints->metrics->style_class;
+    AF_ScriptClass  script_class = AF_SCRIPT_CLASSES_GET
+                                     [style_class->script];
+
+    FT_Bool  top_to_bottom_hinting = 0;
+
+#ifdef FT_DEBUG_LEVEL_TRACE
+    FT_UInt  num_actions = 0;
+#endif
+
+
+    FT_TRACE5(( "latin %s edge hinting (style `%s')\n",
+                dim == AF_DIMENSION_VERT ? "horizontal" : "vertical",
+                af_style_names[hints->metrics->style_class->style] ));
+
+    if ( dim == AF_DIMENSION_VERT )
+      top_to_bottom_hinting = script_class->top_to_bottom_hinting;
+
+    /* we begin by aligning all stems relative to the blue zone */
+    /* if needed -- that's only for horizontal edges            */
+
+    if ( dim == AF_DIMENSION_VERT && AF_HINTS_DO_BLUES( hints ) )
+    {
+      for ( edge = edges; edge < edge_limit; edge++ )
+      {
+        AF_Width  blue;
+        AF_Edge   edge1, edge2; /* these edges form the stem to check */
+
+
+        if ( edge->flags & AF_EDGE_DONE )
+          continue;
+
+        edge1 = NULL;
+        edge2 = edge->link;
+
+        /*
+         *  If a stem contains both a neutral and a non-neutral blue zone,
+         *  skip the neutral one.  Otherwise, outlines with different
+         *  directions might be incorrectly aligned at the same vertical
+         *  position.
+         *
+         *  If we have two neutral blue zones, skip one of them.
+         *
+         */
+        if ( edge->blue_edge && edge2 && edge2->blue_edge )
+        {
+          FT_Byte  neutral  = edge->flags  & AF_EDGE_NEUTRAL;
+          FT_Byte  neutral2 = edge2->flags & AF_EDGE_NEUTRAL;
+
+
+          if ( neutral2 )
+          {
+            edge2->blue_edge = NULL;
+            edge2->flags    &= ~AF_EDGE_NEUTRAL;
+          }
+          else if ( neutral )
+          {
+            edge->blue_edge = NULL;
+            edge->flags    &= ~AF_EDGE_NEUTRAL;
+          }
+        }
+
+        blue = edge->blue_edge;
+        if ( blue )
+          edge1 = edge;
+
+        /* flip edges if the other edge is aligned to a blue zone */
+        else if ( edge2 && edge2->blue_edge )
+        {
+          blue  = edge2->blue_edge;
+          edge1 = edge2;
+          edge2 = edge;
+        }
+
+        if ( !edge1 )
+          continue;
+
+#ifdef FT_DEBUG_LEVEL_TRACE
+        if ( !anchor )
+          FT_TRACE5(( "  BLUE_ANCHOR: edge %d (opos=%.2f) snapped to %.2f,"
+                      " was %.2f (anchor=edge %d)\n",
+                      edge1 - edges, edge1->opos / 64.0, blue->fit / 64.0,
+                      edge1->pos / 64.0, edge - edges ));
+        else
+          FT_TRACE5(( "  BLUE: edge %d (opos=%.2f) snapped to %.2f,"
+                      " was %.2f\n",
+                      edge1 - edges, edge1->opos / 64.0, blue->fit / 64.0,
+                      edge1->pos / 64.0 ));
+
+        num_actions++;
+#endif
+
+        edge1->pos    = blue->fit;
+        edge1->flags |= AF_EDGE_DONE;
+
+        if ( edge2 && !edge2->blue_edge )
+        {
+          af_latin_align_linked_edge( hints, dim, edge1, edge2 );
+          edge2->flags |= AF_EDGE_DONE;
+
+#ifdef FT_DEBUG_LEVEL_TRACE
+          num_actions++;
+#endif
+        }
+
+        if ( !anchor )
+          anchor = edge;
+      }
+    }
+
+    /* now we align all other stem edges, trying to maintain the */
+    /* relative order of stems in the glyph                      */
+    for ( edge = edges; edge < edge_limit; edge++ )
+    {
+      AF_Edge  edge2;
+
+
+      if ( edge->flags & AF_EDGE_DONE )
+        continue;
+
+      /* skip all non-stem edges */
+      edge2 = edge->link;
+      if ( !edge2 )
+      {
+        has_serifs++;
+        continue;
+      }
+
+      /* now align the stem */
+
+      /* this should not happen, but it's better to be safe */
+      if ( edge2->blue_edge )
+      {
+        FT_TRACE5(( "  ASSERTION FAILED for edge %d\n", edge2 - edges ));
+
+        af_latin_align_linked_edge( hints, dim, edge2, edge );
+        edge->flags |= AF_EDGE_DONE;
+
+#ifdef FT_DEBUG_LEVEL_TRACE
+        num_actions++;
+#endif
+        continue;
+      }
+
+      if ( !anchor )
+      {
+        /* if we reach this if clause, no stem has been aligned yet */
+
+        FT_Pos  org_len, org_center, cur_len;
+        FT_Pos  cur_pos1, error1, error2, u_off, d_off;
+
+
+        org_len = edge2->opos - edge->opos;
+        cur_len = af_latin_compute_stem_width( hints, dim,
+                                               org_len, 0,
+                                               edge->flags,
+                                               edge2->flags );
+
+        /* some voodoo to specially round edges for small stem widths; */
+        /* the idea is to align the center of a stem, then shifting    */
+        /* the stem edges to suitable positions                        */
+        if ( cur_len <= 64 )
+        {
+          /* width <= 1px */
+          u_off = 32;
+          d_off = 32;
+        }
+        else
+        {
+          /* 1px < width < 1.5px */
+          u_off = 38;
+          d_off = 26;
+        }
+
+        if ( cur_len < 96 )
+        {
+          org_center = edge->opos + ( org_len >> 1 );
+          cur_pos1   = FT_PIX_ROUND( org_center );
+
+          error1 = org_center - ( cur_pos1 - u_off );
+          if ( error1 < 0 )
+            error1 = -error1;
+
+          error2 = org_center - ( cur_pos1 + d_off );
+          if ( error2 < 0 )
+            error2 = -error2;
+
+          if ( error1 < error2 )
+            cur_pos1 -= u_off;
+          else
+            cur_pos1 += d_off;
+
+          edge->pos  = cur_pos1 - cur_len / 2;
+          edge2->pos = edge->pos + cur_len;
+        }
+        else
+          edge->pos = FT_PIX_ROUND( edge->opos );
+
+        anchor       = edge;
+        edge->flags |= AF_EDGE_DONE;
+
+        FT_TRACE5(( "  ANCHOR: edge %d (opos=%.2f) and %d (opos=%.2f)"
+                    " snapped to %.2f and %.2f\n",
+                    edge - edges, edge->opos / 64.0,
+                    edge2 - edges, edge2->opos / 64.0,
+                    edge->pos / 64.0, edge2->pos / 64.0 ));
+
+        af_latin_align_linked_edge( hints, dim, edge, edge2 );
+
+#ifdef FT_DEBUG_LEVEL_TRACE
+        num_actions += 2;
+#endif
+      }
+      else
+      {
+        FT_Pos  org_pos, org_len, org_center, cur_len;
+        FT_Pos  cur_pos1, cur_pos2, delta1, delta2;
+
+
+        org_pos    = anchor->pos + ( edge->opos - anchor->opos );
+        org_len    = edge2->opos - edge->opos;
+        org_center = org_pos + ( org_len >> 1 );
+
+        cur_len = af_latin_compute_stem_width( hints, dim,
+                                               org_len, 0,
+                                               edge->flags,
+                                               edge2->flags );
+
+        if ( edge2->flags & AF_EDGE_DONE )
+        {
+          FT_TRACE5(( "  ADJUST: edge %d (pos=%.2f) moved to %.2f\n",
+                      edge - edges, edge->pos / 64.0,
+                      ( edge2->pos - cur_len ) / 64.0 ));
+
+          edge->pos = edge2->pos - cur_len;
+        }
+
+        else if ( cur_len < 96 )
+        {
+          FT_Pos  u_off, d_off;
+
+
+          cur_pos1 = FT_PIX_ROUND( org_center );
+
+          if ( cur_len <= 64 )
+          {
+            u_off = 32;
+            d_off = 32;
+          }
+          else
+          {
+            u_off = 38;
+            d_off = 26;
+          }
+
+          delta1 = org_center - ( cur_pos1 - u_off );
+          if ( delta1 < 0 )
+            delta1 = -delta1;
+
+          delta2 = org_center - ( cur_pos1 + d_off );
+          if ( delta2 < 0 )
+            delta2 = -delta2;
+
+          if ( delta1 < delta2 )
+            cur_pos1 -= u_off;
+          else
+            cur_pos1 += d_off;
+
+          edge->pos  = cur_pos1 - cur_len / 2;
+          edge2->pos = cur_pos1 + cur_len / 2;
+
+          FT_TRACE5(( "  STEM: edge %d (opos=%.2f) linked to %d (opos=%.2f)"
+                      " snapped to %.2f and %.2f\n",
+                      edge - edges, edge->opos / 64.0,
+                      edge2 - edges, edge2->opos / 64.0,
+                      edge->pos / 64.0, edge2->pos / 64.0 ));
+        }
+
+        else
+        {
+          org_pos    = anchor->pos + ( edge->opos - anchor->opos );
+          org_len    = edge2->opos - edge->opos;
+          org_center = org_pos + ( org_len >> 1 );
+
+          cur_len    = af_latin_compute_stem_width( hints, dim,
+                                                    org_len, 0,
+                                                    edge->flags,
+                                                    edge2->flags );
+
+          cur_pos1 = FT_PIX_ROUND( org_pos );
+          delta1   = cur_pos1 + ( cur_len >> 1 ) - org_center;
+          if ( delta1 < 0 )
+            delta1 = -delta1;
+
+          cur_pos2 = FT_PIX_ROUND( org_pos + org_len ) - cur_len;
+          delta2   = cur_pos2 + ( cur_len >> 1 ) - org_center;
+          if ( delta2 < 0 )
+            delta2 = -delta2;
+
+          edge->pos  = ( delta1 < delta2 ) ? cur_pos1 : cur_pos2;
+          edge2->pos = edge->pos + cur_len;
+
+          FT_TRACE5(( "  STEM: edge %d (opos=%.2f) linked to %d (opos=%.2f)"
+                      " snapped to %.2f and %.2f\n",
+                      edge - edges, edge->opos / 64.0,
+                      edge2 - edges, edge2->opos / 64.0,
+                      edge->pos / 64.0, edge2->pos / 64.0 ));
+        }
+
+#ifdef FT_DEBUG_LEVEL_TRACE
+        num_actions++;
+#endif
+
+        edge->flags  |= AF_EDGE_DONE;
+        edge2->flags |= AF_EDGE_DONE;
+
+        if ( edge > edges                                             &&
+             ( top_to_bottom_hinting ? ( edge->pos > edge[-1].pos )
+                                     : ( edge->pos < edge[-1].pos ) ) )
+        {
+          /* don't move if stem would (almost) disappear otherwise; */
+          /* the ad-hoc value 16 corresponds to 1/4px               */
+          if ( edge->link && FT_ABS( edge->link->pos - edge[-1].pos ) > 16 )
+          {
+#ifdef FT_DEBUG_LEVEL_TRACE
+            FT_TRACE5(( "  BOUND: edge %d (pos=%.2f) moved to %.2f\n",
+                        edge - edges,
+                        edge->pos / 64.0,
+                        edge[-1].pos / 64.0 ));
+
+            num_actions++;
+#endif
+
+            edge->pos = edge[-1].pos;
+          }
+        }
+      }
+    }
+
+    /* make sure that lowercase m's maintain their symmetry */
+
+    /* In general, lowercase m's have six vertical edges if they are sans */
+    /* serif, or twelve if they are with serifs.  This implementation is  */
+    /* based on that assumption, and seems to work very well with most    */
+    /* faces.  However, if for a certain face this assumption is not      */
+    /* true, the m is just rendered like before.  In addition, any stem   */
+    /* correction will only be applied to symmetrical glyphs (even if the */
+    /* glyph is not an m), so the potential for unwanted distortion is    */
+    /* relatively low.                                                    */
+
+    /* We don't handle horizontal edges since we can't easily assure that */
+    /* the third (lowest) stem aligns with the base line; it might end up */
+    /* one pixel higher or lower.                                         */
+
+    n_edges = edge_limit - edges;
+    if ( dim == AF_DIMENSION_HORZ && ( n_edges == 6 || n_edges == 12 ) )
+    {
+      AF_Edge  edge1, edge2, edge3;
+      FT_Pos   dist1, dist2, span, delta;
+
+
+      if ( n_edges == 6 )
+      {
+        edge1 = edges;
+        edge2 = edges + 2;
+        edge3 = edges + 4;
+      }
+      else
+      {
+        edge1 = edges + 1;
+        edge2 = edges + 5;
+        edge3 = edges + 9;
+      }
+
+      dist1 = edge2->opos - edge1->opos;
+      dist2 = edge3->opos - edge2->opos;
+
+      span = dist1 - dist2;
+      if ( span < 0 )
+        span = -span;
+
+      if ( span < 8 )
+      {
+        delta = edge3->pos - ( 2 * edge2->pos - edge1->pos );
+        edge3->pos -= delta;
+        if ( edge3->link )
+          edge3->link->pos -= delta;
+
+        /* move the serifs along with the stem */
+        if ( n_edges == 12 )
+        {
+          ( edges + 8 )->pos -= delta;
+          ( edges + 11 )->pos -= delta;
+        }
+
+        edge3->flags |= AF_EDGE_DONE;
+        if ( edge3->link )
+          edge3->link->flags |= AF_EDGE_DONE;
+      }
+    }
+
+    if ( has_serifs || !anchor )
+    {
+      /*
+       *  now hint the remaining edges (serifs and single) in order
+       *  to complete our processing
+       */
+      for ( edge = edges; edge < edge_limit; edge++ )
+      {
+        FT_Pos  delta;
+
+
+        if ( edge->flags & AF_EDGE_DONE )
+          continue;
+
+        delta = 1000;
+
+        if ( edge->serif )
+        {
+          delta = edge->serif->opos - edge->opos;
+          if ( delta < 0 )
+            delta = -delta;
+        }
+
+        if ( delta < 64 + 16 )
+        {
+          af_latin_align_serif_edge( hints, edge->serif, edge );
+          FT_TRACE5(( "  SERIF: edge %d (opos=%.2f) serif to %d (opos=%.2f)"
+                      " aligned to %.2f\n",
+                      edge - edges, edge->opos / 64.0,
+                      edge->serif - edges, edge->serif->opos / 64.0,
+                      edge->pos / 64.0 ));
+        }
+        else if ( !anchor )
+        {
+          edge->pos = FT_PIX_ROUND( edge->opos );
+          anchor    = edge;
+          FT_TRACE5(( "  SERIF_ANCHOR: edge %d (opos=%.2f)"
+                      " snapped to %.2f\n",
+                      edge-edges, edge->opos / 64.0, edge->pos / 64.0 ));
+        }
+        else
+        {
+          AF_Edge  before, after;
+
+
+          for ( before = edge - 1; before >= edges; before-- )
+            if ( before->flags & AF_EDGE_DONE )
+              break;
+
+          for ( after = edge + 1; after < edge_limit; after++ )
+            if ( after->flags & AF_EDGE_DONE )
+              break;
+
+          if ( before >= edges && before < edge   &&
+               after < edge_limit && after > edge )
+          {
+            if ( after->opos == before->opos )
+              edge->pos = before->pos;
+            else
+              edge->pos = before->pos +
+                          FT_MulDiv( edge->opos - before->opos,
+                                     after->pos - before->pos,
+                                     after->opos - before->opos );
+
+            FT_TRACE5(( "  SERIF_LINK1: edge %d (opos=%.2f) snapped to %.2f"
+                        " from %d (opos=%.2f)\n",
+                        edge - edges, edge->opos / 64.0,
+                        edge->pos / 64.0,
+                        before - edges, before->opos / 64.0 ));
+          }
+          else
+          {
+            edge->pos = anchor->pos +
+                        ( ( edge->opos - anchor->opos + 16 ) & ~31 );
+            FT_TRACE5(( "  SERIF_LINK2: edge %d (opos=%.2f)"
+                        " snapped to %.2f\n",
+                        edge - edges, edge->opos / 64.0, edge->pos / 64.0 ));
+          }
+        }
+
+#ifdef FT_DEBUG_LEVEL_TRACE
+        num_actions++;
+#endif
+        edge->flags |= AF_EDGE_DONE;
+
+        if ( edge > edges                                             &&
+             ( top_to_bottom_hinting ? ( edge->pos > edge[-1].pos )
+                                     : ( edge->pos < edge[-1].pos ) ) )
+        {
+          /* don't move if stem would (almost) disappear otherwise; */
+          /* the ad-hoc value 16 corresponds to 1/4px               */
+          if ( edge->link && FT_ABS( edge->link->pos - edge[-1].pos ) > 16 )
+          {
+#ifdef FT_DEBUG_LEVEL_TRACE
+            FT_TRACE5(( "  BOUND: edge %d (pos=%.2f) moved to %.2f\n",
+                        edge - edges,
+                        edge->pos / 64.0,
+                        edge[-1].pos / 64.0 ));
+
+            num_actions++;
+#endif
+            edge->pos = edge[-1].pos;
+          }
+        }
+
+        if ( edge + 1 < edge_limit                                   &&
+             edge[1].flags & AF_EDGE_DONE                            &&
+             ( top_to_bottom_hinting ? ( edge->pos < edge[1].pos )
+                                     : ( edge->pos > edge[1].pos ) ) )
+        {
+          /* don't move if stem would (almost) disappear otherwise; */
+          /* the ad-hoc value 16 corresponds to 1/4px               */
+          if ( edge->link && FT_ABS( edge->link->pos - edge[-1].pos ) > 16 )
+          {
+#ifdef FT_DEBUG_LEVEL_TRACE
+            FT_TRACE5(( "  BOUND: edge %d (pos=%.2f) moved to %.2f\n",
+                        edge - edges,
+                        edge->pos / 64.0,
+                        edge[1].pos / 64.0 ));
+
+            num_actions++;
+#endif
+
+            edge->pos = edge[1].pos;
+          }
+        }
+      }
+    }
+
+#ifdef FT_DEBUG_LEVEL_TRACE
+    if ( !num_actions )
+      FT_TRACE5(( "  (none)\n" ));
+    FT_TRACE5(( "\n" ));
+#endif
+  }
+
+
+  /* Apply the complete hinting algorithm to a latin glyph. */
+
+  static FT_Error
+  af_latin_hints_apply( FT_UInt          glyph_index,
+                        AF_GlyphHints    hints,
+                        FT_Outline*      outline,
+                        AF_LatinMetrics  metrics )
+  {
+    FT_Error  error;
+    int       dim;
+
+    AF_LatinAxis  axis;
+
+
+    error = af_glyph_hints_reload( hints, outline );
+    if ( error )
+      goto Exit;
+
+    /* analyze glyph outline */
+#ifdef AF_CONFIG_OPTION_USE_WARPER
+    if ( ( metrics->root.scaler.render_mode == FT_RENDER_MODE_LIGHT &&
+           AF_HINTS_DO_WARP( hints )                                ) ||
+         AF_HINTS_DO_HORIZONTAL( hints )                              )
+#else
+    if ( AF_HINTS_DO_HORIZONTAL( hints ) )
+#endif
+    {
+      axis  = &metrics->axis[AF_DIMENSION_HORZ];
+      error = af_latin_hints_detect_features( hints,
+                                              axis->width_count,
+                                              axis->widths,
+                                              AF_DIMENSION_HORZ );
+      if ( error )
+        goto Exit;
+    }
+
+    if ( AF_HINTS_DO_VERTICAL( hints ) )
+    {
+      axis  = &metrics->axis[AF_DIMENSION_VERT];
+      error = af_latin_hints_detect_features( hints,
+                                              axis->width_count,
+                                              axis->widths,
+                                              AF_DIMENSION_VERT );
+      if ( error )
+        goto Exit;
+
+      /* apply blue zones to base characters only */
+      if ( !( metrics->root.globals->glyph_styles[glyph_index] & AF_NONBASE ) )
+        af_latin_hints_compute_blue_edges( hints, metrics );
+    }
+
+    /* grid-fit the outline */
+    for ( dim = 0; dim < AF_DIMENSION_MAX; dim++ )
+    {
+#ifdef AF_CONFIG_OPTION_USE_WARPER
+      if ( dim == AF_DIMENSION_HORZ                                 &&
+           metrics->root.scaler.render_mode == FT_RENDER_MODE_LIGHT &&
+           AF_HINTS_DO_WARP( hints )                                )
+      {
+        AF_WarperRec  warper;
+        FT_Fixed      scale;
+        FT_Pos        delta;
+
+
+        af_warper_compute( &warper, hints, (AF_Dimension)dim,
+                           &scale, &delta );
+        af_glyph_hints_scale_dim( hints, (AF_Dimension)dim,
+                                  scale, delta );
+        continue;
+      }
+#endif /* AF_CONFIG_OPTION_USE_WARPER */
+
+      if ( ( dim == AF_DIMENSION_HORZ && AF_HINTS_DO_HORIZONTAL( hints ) ) ||
+           ( dim == AF_DIMENSION_VERT && AF_HINTS_DO_VERTICAL( hints ) )   )
+      {
+        af_latin_hint_edges( hints, (AF_Dimension)dim );
+        af_glyph_hints_align_edge_points( hints, (AF_Dimension)dim );
+        af_glyph_hints_align_strong_points( hints, (AF_Dimension)dim );
+        af_glyph_hints_align_weak_points( hints, (AF_Dimension)dim );
+      }
+    }
+
+    af_glyph_hints_save( hints, outline );
+
+  Exit:
+    return error;
+  }
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*****                                                               *****/
+  /*****              L A T I N   S C R I P T   C L A S S              *****/
+  /*****                                                               *****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  AF_DEFINE_WRITING_SYSTEM_CLASS(
+    af_latin_writing_system_class,
+
+    AF_WRITING_SYSTEM_LATIN,
+
+    sizeof ( AF_LatinMetricsRec ),
+
+    (AF_WritingSystem_InitMetricsFunc) af_latin_metrics_init,
+    (AF_WritingSystem_ScaleMetricsFunc)af_latin_metrics_scale,
+    (AF_WritingSystem_DoneMetricsFunc) NULL,
+    (AF_WritingSystem_GetStdWidthsFunc)af_latin_get_standard_widths,
+
+    (AF_WritingSystem_InitHintsFunc)   af_latin_hints_init,
+    (AF_WritingSystem_ApplyHintsFunc)  af_latin_hints_apply
+  )
+
+
+/* END */
diff -ruN freetype-2.7-orig/src/autofit/aflatin.h freetype-2.7/src/autofit/aflatin.h
--- freetype-2.7-orig/src/autofit/aflatin.h	2016-03-15 07:53:53.000000000 +0100
+++ freetype-2.7/src/autofit/aflatin.h	2016-09-09 16:01:22.465167416 +0200
@@ -64,6 +64,9 @@
 
 #define AF_LATIN_MAX_WIDTHS  16
 
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    extern FT_Pos infinality_cur_width;
+#endif
 
 #define AF_LATIN_BLUE_ACTIVE      ( 1U << 0 ) /* zone height is <= 3/4px   */
 #define AF_LATIN_BLUE_TOP         ( 1U << 1 ) /* we have a top blue zone   */
diff -ruN freetype-2.7-orig/src/autofit/afmodule.c freetype-2.7/src/autofit/afmodule.c
--- freetype-2.7-orig/src/autofit/afmodule.c	2016-08-26 11:45:36.000000000 +0200
+++ freetype-2.7/src/autofit/afmodule.c	2016-09-09 16:01:22.465167416 +0200
@@ -22,6 +22,10 @@
 #include "aferrors.h"
 #include "afpic.h"
 
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+#include "../base/ftinf.h"
+#endif
+
 #ifdef FT_DEBUG_AUTOFIT
 
 #ifndef FT_MAKE_OPTION_SINGLE_OBJECT
@@ -464,6 +468,9 @@
     module->warping           = 0;
 #endif
     module->no_stem_darkening = TRUE;
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    if(ftinf) module->no_stem_darkening = !ftinf->stem_darkening_autofit;
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
 
     module->darken_params[0]  = CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1;
     module->darken_params[1]  = CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y1;
diff -ruN freetype-2.7-orig/src/autofit/afmodule.c.orig freetype-2.7/src/autofit/afmodule.c.orig
--- freetype-2.7-orig/src/autofit/afmodule.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ freetype-2.7/src/autofit/afmodule.c.orig	2016-08-26 11:45:36.000000000 +0200
@@ -0,0 +1,578 @@
+/***************************************************************************/
+/*                                                                         */
+/*  afmodule.c                                                             */
+/*                                                                         */
+/*    Auto-fitter module implementation (body).                            */
+/*                                                                         */
+/*  Copyright 2003-2016 by                                                 */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#include "afglobal.h"
+#include "afmodule.h"
+#include "afloader.h"
+#include "aferrors.h"
+#include "afpic.h"
+
+#ifdef FT_DEBUG_AUTOFIT
+
+#ifndef FT_MAKE_OPTION_SINGLE_OBJECT
+
+#ifdef __cplusplus
+  extern "C" {
+#endif
+  extern void
+  af_glyph_hints_dump_segments( AF_GlyphHints  hints,
+                                FT_Bool        to_stdout );
+  extern void
+  af_glyph_hints_dump_points( AF_GlyphHints  hints,
+                              FT_Bool        to_stdout );
+  extern void
+  af_glyph_hints_dump_edges( AF_GlyphHints  hints,
+                             FT_Bool        to_stdout );
+#ifdef __cplusplus
+  }
+#endif
+
+#endif
+
+  int  _af_debug_disable_horz_hints;
+  int  _af_debug_disable_vert_hints;
+  int  _af_debug_disable_blue_hints;
+
+  /* we use a global object instead of a local one for debugging */
+  AF_GlyphHintsRec  _af_debug_hints_rec[1];
+
+  void*  _af_debug_hints = _af_debug_hints_rec;
+#endif
+
+#include FT_INTERNAL_OBJECTS_H
+#include FT_INTERNAL_DEBUG_H
+#include FT_AUTOHINTER_H
+#include FT_SERVICE_PROPERTIES_H
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
+  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
+  /* messages during execution.                                            */
+  /*                                                                       */
+#undef  FT_COMPONENT
+#define FT_COMPONENT  trace_afmodule
+
+
+  static FT_Error
+  af_property_get_face_globals( FT_Face          face,
+                                AF_FaceGlobals*  aglobals,
+                                AF_Module        module )
+  {
+    FT_Error        error = FT_Err_Ok;
+    AF_FaceGlobals  globals;
+
+
+    if ( !face )
+      return FT_THROW( Invalid_Face_Handle );
+
+    globals = (AF_FaceGlobals)face->autohint.data;
+    if ( !globals )
+    {
+      /* trigger computation of the global style data */
+      /* in case it hasn't been done yet              */
+      error = af_face_globals_new( face, &globals, module );
+      if ( !error )
+      {
+        face->autohint.data =
+          (FT_Pointer)globals;
+        face->autohint.finalizer =
+          (FT_Generic_Finalizer)af_face_globals_free;
+      }
+    }
+
+    if ( !error )
+      *aglobals = globals;
+
+    return error;
+  }
+
+
+  static FT_Error
+  af_property_set( FT_Module    ft_module,
+                   const char*  property_name,
+                   const void*  value,
+                   FT_Bool      value_is_string )
+  {
+    FT_Error   error  = FT_Err_Ok;
+    AF_Module  module = (AF_Module)ft_module;
+
+#ifndef FT_CONFIG_OPTION_ENVIRONMENT_PROPERTIES
+    FT_UNUSED( value_is_string );
+#endif
+
+
+    if ( !ft_strcmp( property_name, "fallback-script" ) )
+    {
+      FT_UInt*  fallback_script;
+      FT_UInt   ss;
+
+
+#ifdef FT_CONFIG_OPTION_ENVIRONMENT_PROPERTIES
+      if ( value_is_string )
+        return FT_THROW( Invalid_Argument );
+#endif
+
+      fallback_script = (FT_UInt*)value;
+
+      /* We translate the fallback script to a fallback style that uses */
+      /* `fallback-script' as its script and `AF_COVERAGE_NONE' as its  */
+      /* coverage value.                                                */
+      for ( ss = 0; AF_STYLE_CLASSES_GET[ss]; ss++ )
+      {
+        AF_StyleClass  style_class = AF_STYLE_CLASSES_GET[ss];
+
+
+        if ( (FT_UInt)style_class->script == *fallback_script &&
+             style_class->coverage == AF_COVERAGE_DEFAULT     )
+        {
+          module->fallback_style = ss;
+          break;
+        }
+      }
+
+      if ( !AF_STYLE_CLASSES_GET[ss] )
+      {
+        FT_TRACE0(( "af_property_set: Invalid value %d for property `%s'\n",
+                    fallback_script, property_name ));
+        return FT_THROW( Invalid_Argument );
+      }
+
+      return error;
+    }
+    else if ( !ft_strcmp( property_name, "default-script" ) )
+    {
+      FT_UInt*  default_script;
+
+
+#ifdef FT_CONFIG_OPTION_ENVIRONMENT_PROPERTIES
+      if ( value_is_string )
+        return FT_THROW( Invalid_Argument );
+#endif
+
+      default_script = (FT_UInt*)value;
+
+      module->default_script = *default_script;
+
+      return error;
+    }
+    else if ( !ft_strcmp( property_name, "increase-x-height" ) )
+    {
+      FT_Prop_IncreaseXHeight*  prop;
+      AF_FaceGlobals            globals;
+
+
+#ifdef FT_CONFIG_OPTION_ENVIRONMENT_PROPERTIES
+      if ( value_is_string )
+        return FT_THROW( Invalid_Argument );
+#endif
+
+      prop = (FT_Prop_IncreaseXHeight*)value;
+
+      error = af_property_get_face_globals( prop->face, &globals, module );
+      if ( !error )
+        globals->increase_x_height = prop->limit;
+
+      return error;
+    }
+#ifdef AF_CONFIG_OPTION_USE_WARPER
+    else if ( !ft_strcmp( property_name, "warping" ) )
+    {
+#ifdef FT_CONFIG_OPTION_ENVIRONMENT_PROPERTIES
+      if ( value_is_string )
+      {
+        const char*  s = (const char*)value;
+        long         w = ft_strtol( s, NULL, 10 );
+
+
+        if ( w == 0 )
+          module->warping = 0;
+        else if ( w == 1 )
+          module->warping = 1;
+        else
+          return FT_THROW( Invalid_Argument );
+      }
+      else
+#endif
+      {
+        FT_Bool*  warping = (FT_Bool*)value;
+
+
+        module->warping = *warping;
+      }
+
+      return error;
+    }
+#endif /* AF_CONFIG_OPTION_USE_WARPER */
+    else if ( !ft_strcmp( property_name, "darkening-parameters" ) )
+    {
+      FT_Int*  darken_params;
+      FT_Int   x1, y1, x2, y2, x3, y3, x4, y4;
+
+#ifdef FT_CONFIG_OPTION_ENVIRONMENT_PROPERTIES
+      FT_Int   dp[8];
+
+
+      if ( value_is_string )
+      {
+        const char*  s = (const char*)value;
+        char*        ep;
+        int          i;
+
+
+        /* eight comma-separated numbers */
+        for ( i = 0; i < 7; i++ )
+        {
+          dp[i] = (FT_Int)ft_strtol( s, &ep, 10 );
+          if ( *ep != ',' || s == ep )
+            return FT_THROW( Invalid_Argument );
+
+          s = ep + 1;
+        }
+
+        dp[7] = (FT_Int)ft_strtol( s, &ep, 10 );
+        if ( !( *ep == '\0' || *ep == ' ' ) || s == ep )
+          return FT_THROW( Invalid_Argument );
+
+        darken_params = dp;
+      }
+      else
+#endif
+        darken_params = (FT_Int*)value;
+
+      x1 = darken_params[0];
+      y1 = darken_params[1];
+      x2 = darken_params[2];
+      y2 = darken_params[3];
+      x3 = darken_params[4];
+      y3 = darken_params[5];
+      x4 = darken_params[6];
+      y4 = darken_params[7];
+
+      if ( x1 < 0   || x2 < 0   || x3 < 0   || x4 < 0   ||
+           y1 < 0   || y2 < 0   || y3 < 0   || y4 < 0   ||
+           x1 > x2  || x2 > x3  || x3 > x4              ||
+           y1 > 500 || y2 > 500 || y3 > 500 || y4 > 500 )
+        return FT_THROW( Invalid_Argument );
+
+      module->darken_params[0] = x1;
+      module->darken_params[1] = y1;
+      module->darken_params[2] = x2;
+      module->darken_params[3] = y2;
+      module->darken_params[4] = x3;
+      module->darken_params[5] = y3;
+      module->darken_params[6] = x4;
+      module->darken_params[7] = y4;
+
+      return error;
+    }
+    else if ( !ft_strcmp( property_name, "no-stem-darkening" ) )
+    {
+#ifdef FT_CONFIG_OPTION_ENVIRONMENT_PROPERTIES
+      if ( value_is_string )
+      {
+        const char*  s   = (const char*)value;
+        long         nsd = ft_strtol( s, NULL, 10 );
+
+
+        if ( nsd == 0 )
+          module->no_stem_darkening = 0;
+        else if ( nsd == 1 )
+          module->no_stem_darkening = 1;
+        else
+          return FT_THROW( Invalid_Argument );
+      }
+      else
+#endif
+      {
+        FT_Bool*  no_stem_darkening = (FT_Bool*)value;
+
+
+        module->no_stem_darkening = *no_stem_darkening;
+      }
+
+      return error;
+    }
+
+    FT_TRACE0(( "af_property_set: missing property `%s'\n",
+                property_name ));
+    return FT_THROW( Missing_Property );
+  }
+
+
+  static FT_Error
+  af_property_get( FT_Module    ft_module,
+                   const char*  property_name,
+                   void*        value )
+  {
+    FT_Error   error          = FT_Err_Ok;
+    AF_Module  module         = (AF_Module)ft_module;
+    FT_UInt    fallback_style = module->fallback_style;
+    FT_UInt    default_script = module->default_script;
+#ifdef AF_CONFIG_OPTION_USE_WARPER
+    FT_Bool    warping        = module->warping;
+#endif
+
+
+    if ( !ft_strcmp( property_name, "glyph-to-script-map" ) )
+    {
+      FT_Prop_GlyphToScriptMap*  prop = (FT_Prop_GlyphToScriptMap*)value;
+      AF_FaceGlobals             globals;
+
+
+      error = af_property_get_face_globals( prop->face, &globals, module );
+      if ( !error )
+        prop->map = globals->glyph_styles;
+
+      return error;
+    }
+    else if ( !ft_strcmp( property_name, "fallback-script" ) )
+    {
+      FT_UInt*  val = (FT_UInt*)value;
+
+      AF_StyleClass  style_class = AF_STYLE_CLASSES_GET[fallback_style];
+
+
+      *val = style_class->script;
+
+      return error;
+    }
+    else if ( !ft_strcmp( property_name, "default-script" ) )
+    {
+      FT_UInt*  val = (FT_UInt*)value;
+
+
+      *val = default_script;
+
+      return error;
+    }
+    else if ( !ft_strcmp( property_name, "increase-x-height" ) )
+    {
+      FT_Prop_IncreaseXHeight*  prop = (FT_Prop_IncreaseXHeight*)value;
+      AF_FaceGlobals            globals;
+
+
+      error = af_property_get_face_globals( prop->face, &globals, module );
+      if ( !error )
+        prop->limit = globals->increase_x_height;
+
+      return error;
+    }
+#ifdef AF_CONFIG_OPTION_USE_WARPER
+    else if ( !ft_strcmp( property_name, "warping" ) )
+    {
+      FT_Bool*  val = (FT_Bool*)value;
+
+
+      *val = warping;
+
+      return error;
+    }
+#endif /* AF_CONFIG_OPTION_USE_WARPER */
+    else if ( !ft_strcmp( property_name, "darkening-parameters" ) )
+    {
+      FT_Int*  darken_params = module->darken_params;
+      FT_Int*  val           = (FT_Int*)value;
+
+
+      val[0] = darken_params[0];
+      val[1] = darken_params[1];
+      val[2] = darken_params[2];
+      val[3] = darken_params[3];
+      val[4] = darken_params[4];
+      val[5] = darken_params[5];
+      val[6] = darken_params[6];
+      val[7] = darken_params[7];
+
+      return error;
+    }
+    else if ( !ft_strcmp( property_name, "no-stem-darkening" ) )
+    {
+      FT_Bool   no_stem_darkening = module->no_stem_darkening;
+      FT_Bool*  val               = (FT_Bool*)value;
+
+
+      *val = no_stem_darkening;
+
+      return error;
+    }
+
+    FT_TRACE0(( "af_property_get: missing property `%s'\n",
+                property_name ));
+    return FT_THROW( Missing_Property );
+  }
+
+
+  FT_DEFINE_SERVICE_PROPERTIESREC(
+    af_service_properties,
+    (FT_Properties_SetFunc)af_property_set,        /* set_property */
+    (FT_Properties_GetFunc)af_property_get )       /* get_property */
+
+
+  FT_DEFINE_SERVICEDESCREC1(
+    af_services,
+    FT_SERVICE_ID_PROPERTIES, &AF_SERVICE_PROPERTIES_GET )
+
+
+  FT_CALLBACK_DEF( FT_Module_Interface )
+  af_get_interface( FT_Module    module,
+                    const char*  module_interface )
+  {
+    /* AF_SERVICES_GET dereferences `library' in PIC mode */
+#ifdef FT_CONFIG_OPTION_PIC
+    FT_Library  library;
+
+
+    if ( !module )
+      return NULL;
+    library = module->library;
+    if ( !library )
+      return NULL;
+#else
+    FT_UNUSED( module );
+#endif
+
+    return ft_service_list_lookup( AF_SERVICES_GET, module_interface );
+  }
+
+
+  FT_CALLBACK_DEF( FT_Error )
+  af_autofitter_init( FT_Module  ft_module )      /* AF_Module */
+  {
+    AF_Module  module = (AF_Module)ft_module;
+
+
+    module->fallback_style    = AF_STYLE_FALLBACK;
+    module->default_script    = AF_SCRIPT_DEFAULT;
+#ifdef AF_CONFIG_OPTION_USE_WARPER
+    module->warping           = 0;
+#endif
+    module->no_stem_darkening = TRUE;
+
+    module->darken_params[0]  = CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1;
+    module->darken_params[1]  = CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y1;
+    module->darken_params[2]  = CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2;
+    module->darken_params[3]  = CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y2;
+    module->darken_params[4]  = CFF_CONFIG_OPTION_DARKENING_PARAMETER_X3;
+    module->darken_params[5]  = CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y3;
+    module->darken_params[6]  = CFF_CONFIG_OPTION_DARKENING_PARAMETER_X4;
+    module->darken_params[7]  = CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y4;
+
+    return FT_Err_Ok;
+  }
+
+
+  FT_CALLBACK_DEF( void )
+  af_autofitter_done( FT_Module  ft_module )      /* AF_Module */
+  {
+    FT_UNUSED( ft_module );
+
+#ifdef FT_DEBUG_AUTOFIT
+    if ( _af_debug_hints_rec->memory )
+      af_glyph_hints_done( _af_debug_hints_rec );
+#endif
+  }
+
+
+  FT_CALLBACK_DEF( FT_Error )
+  af_autofitter_load_glyph( AF_Module     module,
+                            FT_GlyphSlot  slot,
+                            FT_Size       size,
+                            FT_UInt       glyph_index,
+                            FT_Int32      load_flags )
+  {
+    FT_Error   error  = FT_Err_Ok;
+    FT_Memory  memory = module->root.library->memory;
+
+#ifdef FT_DEBUG_AUTOFIT
+
+    /* in debug mode, we use a global object that survives this routine */
+
+    AF_GlyphHints  hints = _af_debug_hints_rec;
+    AF_LoaderRec   loader[1];
+
+    FT_UNUSED( size );
+
+
+    if ( hints->memory )
+      af_glyph_hints_done( hints );
+
+    af_glyph_hints_init( hints, memory );
+    af_loader_init( loader, hints );
+
+    error = af_loader_load_glyph( loader, module, slot->face,
+                                  glyph_index, load_flags );
+
+    af_glyph_hints_dump_points( hints, 0 );
+    af_glyph_hints_dump_segments( hints, 0 );
+    af_glyph_hints_dump_edges( hints, 0 );
+
+    af_loader_done( loader );
+
+    return error;
+
+#else /* !FT_DEBUG_AUTOFIT */
+
+    AF_GlyphHintsRec  hints[1];
+    AF_LoaderRec      loader[1];
+
+    FT_UNUSED( size );
+
+
+    af_glyph_hints_init( hints, memory );
+    af_loader_init( loader, hints );
+
+    error = af_loader_load_glyph( loader, module, slot->face,
+                                  glyph_index, load_flags );
+
+    af_loader_done( loader );
+    af_glyph_hints_done( hints );
+
+    return error;
+
+#endif /* !FT_DEBUG_AUTOFIT */
+  }
+
+
+  FT_DEFINE_AUTOHINTER_INTERFACE(
+    af_autofitter_interface,
+    NULL,                                                    /* reset_face */
+    NULL,                                              /* get_global_hints */
+    NULL,                                             /* done_global_hints */
+    (FT_AutoHinter_GlyphLoadFunc)af_autofitter_load_glyph )  /* load_glyph */
+
+
+  FT_DEFINE_MODULE(
+    autofit_module_class,
+
+    FT_MODULE_HINTER,
+    sizeof ( AF_ModuleRec ),
+
+    "autofitter",
+    0x10000L,   /* version 1.0 of the autofitter  */
+    0x20000L,   /* requires FreeType 2.0 or above */
+
+    (const void*)&AF_INTERFACE_GET,
+
+    (FT_Module_Constructor)af_autofitter_init,
+    (FT_Module_Destructor) af_autofitter_done,
+    (FT_Module_Requester)  af_get_interface )
+
+
+/* END */
diff -ruN freetype-2.7-orig/src/base/ftbase.c freetype-2.7/src/base/ftbase.c
--- freetype-2.7-orig/src/base/ftbase.c	2016-02-03 19:13:58.000000000 +0100
+++ freetype-2.7/src/base/ftbase.c	2016-09-09 16:01:22.465167416 +0200
@@ -34,6 +34,9 @@
 #include "ftstream.c"
 #include "fttrigon.c"
 #include "ftutil.c"
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+#include "ftinf.c"
+#endif
 
 #ifdef FT_MACINTOSH
 #include "ftmac.c"
diff -ruN freetype-2.7-orig/src/base/ftinf.c freetype-2.7/src/base/ftinf.c
--- freetype-2.7-orig/src/base/ftinf.c	1970-01-01 01:00:00.000000000 +0100
+++ freetype-2.7/src/base/ftinf.c	2016-09-09 16:01:22.465167416 +0200
@@ -0,0 +1,363 @@
+#include <stdlib.h>
+#include "ftinf.h"
+#define true  1
+#define false 0
+
+#define on  1
+#define off 0
+#define end (-128)
+
+#define sw2pv 18  /* STEM_WIDTH_2_PPEM */
+#define maxp 100  /* MAX_PPEM */
+
+typedef signed char pv;         /* ppm and values type */
+/* the arrays start with existence flag + values */
+typedef struct sa_rules_s {
+    const char *name;
+    pv always_use_100[1+4+1];
+    pv brightness[1+2+1];
+    pv contrast[1+2+1];
+    pv edge_detection[1+4+1];
+    pv m[1+4+1];
+    pv bearing_correction[1+2+1];
+    pv spacing[1+5+1];
+    pv start[1+5+1];
+    pv stem_scaling[1+6+1];
+    pv stem_translating[1+2+1];
+    pv stem_translating_only[1+10+1];
+    pv stem_widths[1+4];        /* these end with maxp */
+    pv synthesize_stems[1+2+1];
+} sa_rules_t;
+
+#pragma GCC diagnostic ignored "-Wpedantic" /* C99 struct initializer tags are needed */
+#pragma GCC diagnostic ignored "-Wunused-function"
+
+const ftinf_t *ftinf;
+/* final settings, updated from environment */
+ftinf_t _env;
+
+/* rules and hashing function */
+#include "ftinf_rh.c"
+
+/* rules selection */
+void ftinf_fill_stem_values( Stem_Data *stem_values,
+                             const char *family, int ppem, int use_known ){
+    /* set the defaults */
+    stem_values->bearing_correction = TRUE;
+    stem_values->brightness = 0.0;
+    stem_values->contrast = 0.0;
+    stem_values->edge_detection = FALSE;
+    stem_values->m = -1;
+    stem_values->stem_scaling = -1;
+    stem_values->stem_spacing = -1;
+    stem_values->stem_start = -1;
+    stem_values->stem_translating = 0;
+    stem_values->stem_translating_only = -1024;
+    stem_values->stem_width = -1;
+    stem_values->synth_stems = FALSE;
+    stem_values->use_100 = FALSE;
+    /* pick from known rules if requested and they exist for current family */
+    if( !use_known )
+        return;
+    else {
+        const sa_rules_t *r=ftinf_rules( family );
+        int i;
+        if( r==NULL ) return;
+        if( r->stem_widths[0]==on )
+            for( i=1; r->stem_widths[i]!=maxp; ++i )
+                if( ppem < r->stem_widths[i] ){
+                    stem_values->stem_width = i-1;
+                    break;
+                }
+
+        if( r->stem_scaling[0]==on )
+            for( i=1; r->stem_scaling[i]!=end; i+=2 )
+                if( ppem==r->stem_scaling[i] ){
+                    stem_values->stem_scaling = r->stem_scaling[i+1];
+                    break;
+                }
+
+        if( r->m[0]==on )
+            for( i=1; r->m[i]!=end; i+=2 )
+                if( ppem==r->m[i] ){
+                    stem_values->m = r->m[i+1];
+                    break;
+                }
+
+        if( r->stem_translating_only[0]==on )
+            for( i=1; r->stem_translating_only[i]!=end; i+=2 )
+                if( ppem==r->stem_translating_only[i] || r->stem_translating_only[i]==0 ){
+                    stem_values->stem_translating_only = r->stem_translating_only[i+1];
+                    break;
+                }
+
+        if( r->stem_translating[0]==on )
+            for( i=1; r->stem_translating[i]!=end; i+=2 )
+                if( ppem==r->stem_translating[i] || r->stem_translating[i]==0 ){
+                    stem_values->stem_translating = r->stem_translating[i+1];
+                    break;
+                }
+
+        if( r->always_use_100[0]==on )
+            for( i=1; r->always_use_100[i]!=end; i+=2 )
+                if( ppem>=r->always_use_100[i] && ppem<=r->always_use_100[i+1] ){
+                    stem_values->use_100 = TRUE;
+                    break;
+                }
+
+        if( r->synthesize_stems[0]==on )
+            for( i=1; r->synthesize_stems[i]!=end; i+=2 )
+                if( ppem>=r->synthesize_stems[i] && ppem<=r->synthesize_stems[i+1] ){
+                    stem_values->synth_stems = TRUE;
+                    break;
+                }
+
+        if( r->edge_detection[0]==on )
+            for( i=1; r->edge_detection[i]!=end; i+=2 )
+                if( ppem>=r->edge_detection[i] && ppem<=r->edge_detection[i+1] ){
+                    stem_values->edge_detection = TRUE;
+                    break;
+                }
+
+        if( r->bearing_correction[0]==on )
+            for( i=1; r->bearing_correction[i]!=end; i+=2 )
+                if( ppem>=r->bearing_correction[i] && ppem<=r->bearing_correction[i+1] ){
+                    stem_values->bearing_correction = FALSE;
+                    break;
+                }
+
+#if(0)
+        if( r->brightness[0]==on )
+            for( i=1; r->brightness[i]!=end; i+=2 )
+                if( ppem==r->brightness[i]||r->brightness[i]==0 ){
+                    stem_values->brightness=r->brightness[i+1]*(1.0f/300.0f);
+                    break;
+                }
+
+        if( r->contrast[0]==on )
+            for( i=1; r->contrast[i]!=end; i+=2 )
+                if( ppem==r->contrast[i]||r->contrast[i]==0 ){
+                    stem_values->contrast=r->contrast[i+1]*(1.0f/300.0f);
+                    break;
+                }
+        if( r->spacing[0]==on ){
+            /* not used by original code */
+        }
+        if( r->start[0]==on ){
+            /* not used by original code */
+        }
+#endif
+    }
+    return;
+}
+
+void ftinf_get_bc( const char *family, int ppem, float *brightness, float *contrast ){
+    const sa_rules_t *r=ftinf_rules( family );
+    *brightness=0;
+    *contrast=0;
+    if( r ){
+        int i;
+        if( r->brightness[0]==on )
+            for( i=1; r->brightness[i]!=end; i+=2 )
+                if( ppem==r->brightness[i]||r->brightness[i]==0 ){
+                    *brightness=r->brightness[i+1]*(1.0f/300.0f);
+                    break;
+                }
+
+        if( r->contrast[0]==on )
+            for( i=1; r->contrast[i]!=end; i+=2 )
+                if( ppem==r->contrast[i]||r->contrast[i]==0 ){
+                    *contrast=r->contrast[i+1]*(1.0f/300.0f);
+                    break;
+                }
+    }
+    return;
+}
+
+static int
+bool_val( const char *s ){
+    if ( s != NULL )
+        return strcasecmp(s, "true") == 0
+            || strcasecmp(s, "1") == 0
+            || strcasecmp(s, "on") == 0
+            || strcasecmp(s, "yes") ==0;
+    else
+        return 0;
+}
+
+static int
+int_val( const char *s, int min, int max ){
+    int val;
+    sscanf ( s, "%d", &val );
+    if ( val > max )
+        val = max;
+    else if ( val < min )
+        val = min;
+    return val;
+}
+
+/* settings and hashing function */
+#include "ftinf_sh.c"
+
+/*
+  Get active Infinality settings
+ */
+void ftinf_env(){
+    const char *s;
+    ftinf=ftinf_settings( getenv( "INFINALITY_FT" ) );
+
+    if( ftinf==NULL ){
+        ftinf=ftinf_settings( "ultimate3" );
+        /* this should always succeed */
+#if(0)
+        if( ftinf==NULL ){
+            /* put an error here */
+            exit(-1);
+        }
+#endif
+    }
+    _env=ftinf[0];      /* copy as defaults */
+
+    /* check if custom environment values are set and update with them */
+    s=getenv( "INFINALITY_FT_AUTOHINT_INCREASE_GLYPH_HEIGHTS" );
+    if( s ) _env.autohint_increase_glyph_heights=bool_val( s );
+    s=getenv( "INFINALITY_FT_AUTOHINT_SNAP_STEM_HEIGHT" );
+    if( s ) _env.autohint_snap_stem_height=int_val( s, 0, 100 );
+    s=getenv( "INFINALITY_FT_USE_VARIOUS_TWEAKS" );
+    if( s ) _env.use_various_tweaks=bool_val( s );
+    s=getenv( "INFINALITY_FT_USE_KNOWN_SETTINGS_ON_SELECTED_FONTS" );
+    if( s ) _env.use_known_settings_on_selected_fonts=bool_val(s);
+#if(0)                          /* not used (naming error also) */
+    s=getenv( "INFINALITY_FT_AUTOHINT_MINIMUM_STEM_WIDTH" );
+    if( s ) _env.autohint_minimum_stem_height=int_val( s, 0, 100 );
+#endif
+    s=getenv( "INFINALITY_FT_STEM_SNAPPING_SLIDING_SCALE" );
+    if( s ) sscanf( s, "%d", &_env.stem_snapping_sliding_scale );
+    s=getenv( "INFINALITY_FT_STEM_ALIGNMENT_STRENGTH" );
+    if( s ) sscanf( s, "%d", &_env.stem_alignment_strength );
+    s=getenv( "INFINALITY_FT_STEM_DARKENING_AUTOFIT" );
+    if( s ) _env.stem_darkening_autofit=bool_val( s );
+    s=getenv( "INFINALITY_FT_STEM_DARKENING_CFF" );
+    if( s ) _env.stem_darkening_cff=bool_val( s );
+    s=getenv( "INFINALITY_FT_STEM_FITTING_STRENGTH" );
+    if( s ) sscanf( s, "%d", &_env.stem_fitting_strength );
+    s=getenv( "INFINALITY_FT_CHROMEOS_STYLE_SHARPENING_STRENGTH" );
+    if( s ) _env.chromeos_style_sharpening_strength=int_val( s, 0, 100 );
+    s=getenv( "INFINALITY_FT_BRIGHTNESS" );
+    if( s ) sscanf( s, "%d", &_env.brightness );
+    s=getenv( "INFINALITY_FT_CONTRAST" );
+    if( s ) sscanf( s, "%d", &_env.contrast );
+    s=getenv( "INFINALITY_FT_WINDOWS_STYLE_SHARPENING_STRENGTH" );
+    if( s ) _env.windows_style_sharpening_strength=int_val( s, 0, 100 );
+    s=getenv( "INFINALITY_FT_GAMMA_CORRECTION" );
+    if( s ){
+        float *f=_env.gamma_correction;
+        sscanf ( s, "%f %f", &f[0], &f[1] );
+        if( f[1] < 1.0f ) f[1]=1.0f;
+    }
+    s=getenv( "INFINALITY_FT_FRINGE_FILTER_STRENGTH" );
+    if( s ) sscanf( s, "%d", &_env.fringe_filter_strength );
+    s=getenv( "INFINALITY_FT_GRAYSCALE_FILTER_STRENGTH" );
+    if( s ) sscanf( s, "%d", &_env.grayscale_filter_strength );
+    s=getenv( "INFINALITY_FT_AUTOHINT_HORIZONTAL_STEM_DARKEN_STRENGTH" );
+    if( s ) sscanf( s, "%d", &_env.autohint_horizontal_stem_darken_strength );
+    s=getenv( "INFINALITY_FT_AUTOHINT_VERTICAL_STEM_DARKEN_STRENGTH" );
+    if( s ) sscanf( s, "%d", &_env.autohint_vertical_stem_darken_strength );
+    s=getenv( "INFINALITY_FT_GLOBAL_EMBOLDEN_X_VALUE" );
+    if( s ) sscanf( s, "%d", &_env.global_embolden_x_value );
+    s=getenv( "INFINALITY_FT_GLOBAL_EMBOLDEN_Y_VALUE" );
+    if( s ) sscanf( s, "%d", &_env.global_embolden_y_value );
+    s=getenv( "INFINALITY_FT_BOLD_EMBOLDEN_X_VALUE" );
+    if( s ) sscanf( s, "%d", &_env.bold_embolden_x_value );
+    s=getenv( "INFINALITY_FT_BOLD_EMBOLDEN_Y_VALUE" );
+    if( s ) sscanf( s, "%d", &_env.bold_embolden_y_value );
+    s=getenv( "INFINALITY_FT_FILTER_PARAMS" );
+    if( s ) {
+        int *f=_env.filter_params;
+        if( sscanf( s, "%d %d %d %d %d", f+1, f+2, f+3, f+4, f+5 )==5 )
+            f[0]=on;
+        else
+            f[0]=off;           /* FIXME: put a warning? */
+    }
+    /* do the range verifications as in original code */
+    if ( _env.stem_snapping_sliding_scale > maxp )
+        _env.stem_snapping_sliding_scale = 0;
+    else if ( _env.stem_snapping_sliding_scale < 0 )
+        _env.stem_snapping_sliding_scale = 0;
+    if (_env.stem_snapping_sliding_scale < 11 &&
+        _env.stem_snapping_sliding_scale > 0  )
+        _env.stem_snapping_sliding_scale = 11;
+
+    if ( _env.stem_alignment_strength > 100 )
+        _env.stem_alignment_strength = 100;
+    else if ( _env.stem_alignment_strength < 0 )
+        _env.stem_alignment_strength = 0;
+
+    if ( _env.stem_fitting_strength > 100 )
+        _env.stem_fitting_strength = 100;
+    else if ( _env.stem_fitting_strength < 0 )
+        _env.stem_fitting_strength = 0;
+
+    if ( _env.chromeos_style_sharpening_strength > 100 )
+        _env.chromeos_style_sharpening_strength = 100;
+    else if ( _env.chromeos_style_sharpening_strength < 0 )
+        _env.chromeos_style_sharpening_strength = 0;
+
+    if ( _env.brightness > 100 )
+        _env.brightness = 100;
+    else if ( _env.brightness < -100 )
+        _env.brightness = 0;
+
+    if ( _env.contrast > 100 )
+        _env.contrast = 100;
+    else if ( _env.contrast < -100 )
+        _env.contrast = 0;
+
+    if ( _env.windows_style_sharpening_strength > 100 )
+        _env.windows_style_sharpening_strength = 100;
+    else if ( _env.windows_style_sharpening_strength < 0 )
+        _env.windows_style_sharpening_strength = 0;
+
+    if ( _env.fringe_filter_strength > 100 )
+        _env.fringe_filter_strength = 100;
+    else if ( _env.fringe_filter_strength < 0 )
+        _env.fringe_filter_strength = 0;
+
+    if ( _env.grayscale_filter_strength > 100 )
+        _env.grayscale_filter_strength = 100;
+    else if ( _env.grayscale_filter_strength < 0 )
+        _env.grayscale_filter_strength = 0;
+
+    if ( _env.autohint_horizontal_stem_darken_strength > 100 )
+        _env.autohint_horizontal_stem_darken_strength = 100;
+    else if ( _env.autohint_horizontal_stem_darken_strength < 0 )
+        _env.autohint_horizontal_stem_darken_strength = 0;
+
+    if ( _env.autohint_vertical_stem_darken_strength > 100 )
+        _env.autohint_vertical_stem_darken_strength = 100;
+    else if ( _env.autohint_horizontal_stem_darken_strength < 0 )
+        _env.autohint_vertical_stem_darken_strength = 0;
+
+    if ( _env.global_embolden_x_value > 128 )
+        _env.global_embolden_x_value = 128;
+    else if ( _env.global_embolden_x_value < -128 )
+        _env.global_embolden_x_value = -128;
+
+    if ( _env.global_embolden_y_value > 128 )
+        _env.global_embolden_y_value = 128;
+    else if ( _env.global_embolden_y_value < -128 )
+          _env.global_embolden_y_value = -128;
+
+    if ( _env.bold_embolden_x_value > 128 )
+        _env.bold_embolden_x_value = 128;
+    else if (_env.bold_embolden_x_value < -128 )
+        _env.bold_embolden_x_value = -128;
+
+    if ( _env.bold_embolden_y_value > 128 )
+        _env.bold_embolden_y_value = 128;
+    else if ( _env.bold_embolden_y_value < -128 )
+        _env.bold_embolden_y_value = -128;
+
+    /* point to the combined and checked settings */
+    ftinf=&_env;
+}
diff -ruN freetype-2.7-orig/src/base/ftinf.h freetype-2.7/src/base/ftinf.h
--- freetype-2.7-orig/src/base/ftinf.h	1970-01-01 01:00:00.000000000 +0100
+++ freetype-2.7/src/base/ftinf.h	2016-09-09 16:01:22.465167416 +0200
@@ -0,0 +1,66 @@
+#ifndef _FTINF_H_
+#define _FTINF_H_
+/*
+    Stem snapping rules
+    (base freetype typedefs assumed already included)
+ */
+typedef struct
+{
+    FT_Int       stem_width;
+    FT_Int       stem_spacing;
+    FT_Int       stem_start;
+    FT_Int       stem_scaling;
+    FT_Int       stem_translating_only;
+    FT_Int       stem_translating;
+    float        brightness;
+    float        contrast;
+    FT_Bool      use_100;
+    FT_Bool      synth_stems;
+    FT_Bool      edge_detection;
+    FT_Bool      bearing_correction;
+    FT_Int       m;
+} Stem_Data;
+
+/*
+  Infinality settings
+ */
+typedef struct ftinf_s {
+    const char *name;
+    int autohint_horizontal_stem_darken_strength;
+    int autohint_snap_stem_height;
+    int autohint_increase_glyph_heights;
+    int autohint_vertical_stem_darken_strength;
+    int bold_embolden_x_value;
+    int bold_embolden_y_value;
+    int brightness;
+    int chromeos_style_sharpening_strength;
+    int contrast;
+    int filter_params[6];       /* 1st one used as existence flag */
+    int fringe_filter_strength;
+    float gamma_correction[2];
+    int global_embolden_x_value;
+    int global_embolden_y_value;
+    int grayscale_filter_strength;
+    int stem_alignment_strength;
+    int stem_darkening_autofit;
+    int stem_darkening_cff;
+    int stem_fitting_strength;
+    int stem_snapping_sliding_scale;
+    int use_known_settings_on_selected_fonts;
+    int use_various_tweaks;
+    int windows_style_sharpening_strength;
+} ftinf_t;
+
+extern FT_Pos infinality_cur_width; /* defined in aflatin.c */
+
+extern const ftinf_t *ftinf;    /* active settings */
+
+extern void ftinf_fill_stem_values( Stem_Data *stem_values,
+                                    const char *family, int ppem, int use_known );
+extern void ftinf_get_bc( const char *family, int ppem,
+                          float *brightness, float *contrast );
+
+/* get values from environment (FIXME: maybe update with using user files) */
+extern void ftinf_env();
+
+#endif
diff -ruN freetype-2.7-orig/src/base/ftinf_rh.c freetype-2.7/src/base/ftinf_rh.c
--- freetype-2.7-orig/src/base/ftinf_rh.c	1970-01-01 01:00:00.000000000 +0100
+++ freetype-2.7/src/base/ftinf_rh.c	2016-09-09 16:01:22.465167416 +0200
@@ -0,0 +1,626 @@
+/* ANSI-C code produced by gperf version 3.1 */
+/* Command-line: gperf --output-file=ftinf_rh.c ftinf_rh.gperf  */
+/* Computed positions: -k'1,$' */
+
+#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
+      && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
+      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
+      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
+      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
+      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
+      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
+      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
+      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
+      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
+      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
+      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
+      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
+      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
+      && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
+      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
+      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
+      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
+      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
+      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
+      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
+      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
+      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
+/* The character set is not based on ISO-646.  */
+#error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
+#endif
+
+#line 9 "ftinf_rh.gperf"
+
+#include <ctype.h>
+static const struct sa_rules_s* _rules_get( const char*str, unsigned len );
+/* maximum key range = 82, duplicates = 0 */
+
+#ifdef __GNUC__
+__inline
+#else
+#ifdef __cplusplus
+inline
+#endif
+#endif
+static unsigned int
+_rules_hash (register const char *str, register unsigned int len)
+{
+  static const unsigned char asso_values[] =
+    {
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85,  0, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85,  5, 45,  5,
+      35, 25, 35, 35, 50, 45, 85, 85,  0, 25,
+      40,  5,  0, 85, 50, 20, 20,  0, 10, 10,
+      85, 10, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85
+    };
+  return len + asso_values[(unsigned char)str[len - 1]] + asso_values[(unsigned char)str[0]];
+}
+
+#ifdef __GNUC__
+__inline
+#if defined __GNUC_STDC_INLINE__ || defined __GNUC_GNU_INLINE__
+__attribute__ ((__gnu_inline__))
+#endif
+#endif
+const struct sa_rules_s *
+_rules_get (register const char *str, register unsigned int len)
+{
+  enum
+    {
+      TOTAL_KEYWORDS = 58,
+      MIN_WORD_LENGTH = 3,
+      MAX_WORD_LENGTH = 24,
+      MIN_HASH_VALUE = 3,
+      MAX_HASH_VALUE = 84
+    };
+
+  static const struct sa_rules_s wordlist[] =
+    {
+#line 15 "ftinf_rh.gperf"
+{   .name="---",
+    .synthesize_stems={on, 13, 13, end}
+},
+#line 253 "ftinf_rh.gperf"
+{   .name="ubuntu",
+    .always_use_100={on, 12, 13, 15, 15, end}
+},
+#line 31 "ftinf_rh.gperf"
+{   .name="arial",
+    .always_use_100={on, 0, maxp, end},
+    .edge_detection={on, 11, 11, 13, 13, end},
+    .spacing={on, 10, 11, 23, 25, 30, end},
+    .start={on, 11, 18, 23, 30, 30, end},
+    .stem_translating={on, 11, 32, end},
+    .stem_translating_only={on, 10, 16, 8, 32, 9, 32, 16, -24, end}
+},
+#line 87 "ftinf_rh.gperf"
+{   .name="corbel",
+    .stem_translating_only={on, 10, 16, end},
+    .stem_widths={on, 10, 21, maxp}
+},
+#line 71 "ftinf_rh.gperf"
+{   .name="canwell",
+    .stem_scaling={on, 13, 0, end}
+},
+#line 216 "ftinf_rh.gperf"
+{   .name="pragmata",
+    .always_use_100={on, 0, maxp, end}
+},
+#line 67 "ftinf_rh.gperf"
+{   .name="cantarell",
+    .stem_translating_only={on, 11, 0, 12, 0, end},
+    .stem_widths={on, 10, 22, maxp,}
+},
+#line 39 "ftinf_rh.gperf"
+{   .name="arimo",
+    .always_use_100={on, 0, maxp, end},
+    .stem_translating={on, 11, 32, end},
+    .stem_translating_only={on, 10, 8, 8, 32, 9, 32, end}
+},
+#line 207 "ftinf_rh.gperf"
+{   .name="optima",
+    .brightness={on, 0, -20, end},
+    .contrast={on, 0, 25, end},
+    .stem_scaling={on, 17, 1, end},
+    .stem_translating_only={on, 10, 0, 11, 0, 12, 0, end}
+},
+#line 63 "ftinf_rh.gperf"
+{   .name="candara",
+    .stem_scaling={on, 14, 1, 17, 1, end},
+    .stem_translating_only={on, 10, 16, end}
+},
+#line 77 "ftinf_rh.gperf"
+{   .name="comfortaa",
+    .stem_widths={on, 10, 19, 22, maxp},
+    .stem_scaling={on, 11, 0, end}
+},
+#line 161 "ftinf_rh.gperf"
+{   .name="liberation mono",
+    .always_use_100={on, 0, maxp, end}
+},
+#line 18 "ftinf_rh.gperf"
+{   .name="andale mono",
+    .always_use_100={on, 0, maxp, end},
+    .stem_scaling={on, 11, 1, end},
+    .stem_widths={on, 10, 21, maxp,}
+},
+#line 256 "ftinf_rh.gperf"
+{   .name="verdana",
+    .always_use_100={on, 0, 14, 16, maxp, end},
+    .stem_scaling={on, 12, 1, 15, 1, end},
+    .stem_translating_only={on, 8, 16, 15, 16, 14, 32, 18, 32, 19, 24, end}
+},
+#line 74 "ftinf_rh.gperf"
+{   .name="century gothic",
+    .stem_widths={on, 10, 22, maxp,}
+},
+#line 91 "ftinf_rh.gperf"
+{   .name="courier new",
+    .always_use_100={on, 12, 12, end},
+    .edge_detection={on, 10, 12, end},
+    .m={on, 13, 1, 14, 1, end}
+},
+#line 23 "ftinf_rh.gperf"
+{   .name="arial narrow",
+    .stem_widths={on, 10, 21, maxp,}
+},
+#line 185 "ftinf_rh.gperf"
+{   .name="luxi sans",
+    .always_use_100={on, 13, 13, end},
+    .stem_widths={on, 10, 17, sw2pv, maxp,}
+},
+#line 225 "ftinf_rh.gperf"
+{   .name="samba",
+    .stem_scaling={on, 11, 0, end}
+},
+#line 233 "ftinf_rh.gperf"
+{   .name="tahoma",
+    .always_use_100={on, 11, 11, 14, maxp, end},
+    .edge_detection={on, 11, 11, end},
+    .spacing={on, 10, 12, 18, 18, 30, end},
+    .start={on, 14, 17, 30, 100, 100, end},
+    .stem_translating={on, 11, 32, end},
+    .stem_translating_only={on, 7, 32, 8, 32, 9, 32, end},
+},
+#line 164 "ftinf_rh.gperf"
+{   .name="liberation sans narrow",
+    .stem_widths={on,10, 22, maxp,}
+},
+#line 81 "ftinf_rh.gperf"
+{   .name="consolas",
+    .always_use_100={on, 0, maxp, end},
+    .stem_translating_only={on, 8, 32, 9, 32, end},
+    .stem_widths={on, 10, 20, maxp,},
+    .stem_scaling={on, 11, 1, end}
+},
+#line 203 "ftinf_rh.gperf"
+{   .name="open sans",
+    .stem_translating_only={on, 10, 16, 9, 16, end},
+    .stem_widths={on, 10, 20, maxp,}
+},
+#line 167 "ftinf_rh.gperf"
+{   .name="liberation sans",
+    .edge_detection={on, 11, 11, end},
+    .stem_translating={on, 11, 32, end},
+    .stem_translating_only={on, 10, 8, 8, 32, 9, 32, end},
+    .stem_widths={on,10, 19, maxp,}
+},
+#line 193 "ftinf_rh.gperf"
+{   .name="monaco",
+    .always_use_100={on, 0, maxp, end}
+},
+#line 101 "ftinf_rh.gperf"
+{   .name="cousine",
+    .always_use_100={on, 0, maxp, end}
+},
+#line 176 "ftinf_rh.gperf"
+{   .name="lucida grande",
+    .stem_scaling={on, 13, 1, end},
+    .stem_translating_only={on, 13, 24, 14, 24, 8, 16, 9, 16, end},
+    .stem_widths={on, 10, 16, sw2pv, maxp},
+},
+#line 173 "ftinf_rh.gperf"
+{   .name="lucida console",
+    .always_use_100={on, 0, maxp, end}
+},
+#line 196 "ftinf_rh.gperf"
+{   .name="myriad pro",
+    .stem_scaling={on, 14, 1, 17, 1, end},
+    .stem_translating_only={on, 10, 16, 11, 0, 9, 16, end}
+},
+#line 26 "ftinf_rh.gperf"
+{   .name="arial unicode ms",
+    .always_use_100={on, 0, maxp, end},
+    .stem_translating={on, 11, 32, end},
+    .stem_translating_only={on, 10, 16, 8, 32, 9, 32, end}
+},
+#line 213 "ftinf_rh.gperf"
+{   .name="palatino linotype",
+    .edge_detection={on, 0, 100, end}
+},
+#line 181 "ftinf_rh.gperf"
+{   .name="lucida sans unicode",
+    .stem_translating_only={on, 13, 24, 14, 24, 8, 16, 9, 16, end},
+    .stem_widths={on,10, 16, sw2pv, maxp,}
+},
+#line 140 "ftinf_rh.gperf"
+{   .name="futura",
+    .stem_widths={on, 10, 14, sw2pv, maxp,}
+},
+#line 147 "ftinf_rh.gperf"
+{   .name="georgia",
+    .stem_translating_only={on, 13, 16, 14, 16, 15, 0, end}
+},
+#line 125 "ftinf_rh.gperf"
+{   .name="freemono",
+    .always_use_100={on, 0, maxp, end}
+},
+#line 200 "ftinf_rh.gperf"
+{   .name="nina",
+    .stem_scaling={on, 11, 0, 12, 0, 13, 0, end}
+},
+#line 121 "ftinf_rh.gperf"
+{   .name="essential pragmatapro",
+    .always_use_100={on, 0, maxp, end},
+    .m={on, 13, 0, 14, 0, end}
+},
+#line 247 "ftinf_rh.gperf"
+{   .name="trebuchet ms",
+    .always_use_100={on, 13, 13, end},
+    .stem_scaling={on, 13, 0, 17, 0, 20, 1, end},
+    .stem_translating_only={on, 10, 16, 11, 0, 8, 32, 9, 32, end},
+    .stem_widths={on, 10, 17, sw2pv, maxp,}
+},
+#line 114 "ftinf_rh.gperf"
+{   .name="droid sans mono",
+    .m={on, 12, 0, end}
+},
+#line 104 "ftinf_rh.gperf"
+{   .name="dejavu sans mono",
+    .always_use_100={on, 0, maxp, end},
+    .stem_translating_only={on, 7, 16, 8, 32, 9, 16, end}
+},
+#line 57 "ftinf_rh.gperf"
+{   .name="calibri",
+    .always_use_100={on, 23, maxp, end},
+    .stem_scaling={on, 15, 1, 17, 1, 18, 1, end},
+    .stem_translating_only={on, 10, 16, 15, 0, end},
+    .stem_widths={on, 1, 10, 19, maxp,}
+},
+#line 156 "ftinf_rh.gperf"
+{   .name="inconsolata",
+    .stem_scaling={on, 12, 1, 15, 1, end},
+    .stem_translating_only={on, 10, 24, 9, 32, end},
+    .stem_widths={on, 10, 23, maxp,},
+},
+#line 96 "ftinf_rh.gperf"
+{   .name="courier",
+    .always_use_100={on, 0, maxp, end},
+    .m={on, 13, 1, 14, 1, end},
+    .stem_translating_only={on, 13, 16, 15, 0, end}
+},
+#line 128 "ftinf_rh.gperf"
+{   .name="freesans",
+    .always_use_100={on, 0, maxp, end},
+    .edge_detection={on, 11, 11, 13, 13, end},
+    .spacing={on, 10, 12, 18, 18, 30, end},
+    .start={on, 10, 18, 18, 25, 30, end},
+    .stem_scaling={on, 16, 0, end},
+    .stem_translating={on, 11, 32, end},
+    .stem_translating_only={on, 10, 16, 9, 8, end}
+},
+#line 150 "ftinf_rh.gperf"
+{   .name="gill sans",
+    .stem_widths={on, 10, 17, sw2pv, maxp,}
+},
+#line 117 "ftinf_rh.gperf"
+{   .name="droid sans",
+    .always_use_100={on, 12, 12, 15, 15, end},
+    .stem_translating_only={on, 8, 16, 9, 16, end}
+},
+#line 108 "ftinf_rh.gperf"
+{   .name="dejavu sans",
+    .always_use_100={on, 10, 14, 16, 17, end},
+    .m={on, 12, 0, end},
+    .stem_scaling={on, 12, 1, end},
+    .stem_translating_only={on, 8, 16, 15, -20, end}
+},
+#line 219 "ftinf_rh.gperf"
+{   .name="raleway",
+    .stem_scaling={on, 15, 0, end}
+},
+#line 153 "ftinf_rh.gperf"
+{   .name="helvetica cy",
+    .stem_widths={on, 10, 23, maxp,}
+},
+#line 228 "ftinf_rh.gperf"
+{   .name="segoe ui",
+    .always_use_100={on, 11, 12, 14, 14, end},
+    .stem_translating_only={on, 10, 0, 7, 32, 8, 16, 9, 24, end},
+    .stem_widths={on, 10, 23, maxp,}
+},
+#line 48 "ftinf_rh.gperf"
+{   .name="bitstream vera sans mono",
+    .always_use_100={on, 0, maxp, end}
+},
+#line 241 "ftinf_rh.gperf"
+{   .name="times new roman",
+    .always_use_100={on, 14, 14, 16, 16, end},
+    .bearing_correction={0, 100, end},
+    .stem_scaling={on, 17, 1, end},
+    .stem_translating_only={on, 17, 8, end}
+},
+#line 222 "ftinf_rh.gperf"
+{   .name="rokkitt",
+    .stem_widths={on, 10, 21, maxp,}
+},
+#line 143 "ftinf_rh.gperf"
+{   .name="garamond",
+    .brightness={on, 0, -20, end},
+    .contrast={on, 0, 25, end}
+},
+#line 137 "ftinf_rh.gperf"
+{   .name="freeserif",
+    .stem_scaling={on, 13, 1, 17, 1, end}
+},
+#line 189 "ftinf_rh.gperf"
+{   .name="microsoft sans serif",
+    .always_use_100={on, 0, maxp, end},
+    .stem_translating_only={on, 10, 16, 8, 32, 9, 32, end}
+},
+#line 44 "ftinf_rh.gperf"
+{   .name="baskerville",
+    .brightness={on, 0, -20, end},
+    .contrast={on, 0, 25, end}
+},
+#line 51 "ftinf_rh.gperf"
+{   .name="bitstream vera sans",
+    .always_use_100={on, 10, 14, 16, 17, end},
+    .m={on, 12, 0, end},
+    .stem_scaling={on ,12, 1, end},
+    .stem_translating_only={on, 8, 16, end}
+}
+    };
+
+  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
+    {
+      register int key = _rules_hash (str, len);
+
+      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
+        {
+          register const struct sa_rules_s *resword;
+
+          switch (key - 3)
+            {
+              case 0:
+                resword = &wordlist[0];
+                goto compare;
+              case 3:
+                resword = &wordlist[1];
+                goto compare;
+              case 7:
+                resword = &wordlist[2];
+                goto compare;
+              case 8:
+                resword = &wordlist[3];
+                goto compare;
+              case 9:
+                resword = &wordlist[4];
+                goto compare;
+              case 10:
+                resword = &wordlist[5];
+                goto compare;
+              case 11:
+                resword = &wordlist[6];
+                goto compare;
+              case 12:
+                resword = &wordlist[7];
+                goto compare;
+              case 13:
+                resword = &wordlist[8];
+                goto compare;
+              case 14:
+                resword = &wordlist[9];
+                goto compare;
+              case 16:
+                resword = &wordlist[10];
+                goto compare;
+              case 17:
+                resword = &wordlist[11];
+                goto compare;
+              case 18:
+                resword = &wordlist[12];
+                goto compare;
+              case 19:
+                resword = &wordlist[13];
+                goto compare;
+              case 21:
+                resword = &wordlist[14];
+                goto compare;
+              case 23:
+                resword = &wordlist[15];
+                goto compare;
+              case 24:
+                resword = &wordlist[16];
+                goto compare;
+              case 26:
+                resword = &wordlist[17];
+                goto compare;
+              case 27:
+                resword = &wordlist[18];
+                goto compare;
+              case 28:
+                resword = &wordlist[19];
+                goto compare;
+              case 29:
+                resword = &wordlist[20];
+                goto compare;
+              case 30:
+                resword = &wordlist[21];
+                goto compare;
+              case 31:
+                resword = &wordlist[22];
+                goto compare;
+              case 32:
+                resword = &wordlist[23];
+                goto compare;
+              case 33:
+                resword = &wordlist[24];
+                goto compare;
+              case 34:
+                resword = &wordlist[25];
+                goto compare;
+              case 35:
+                resword = &wordlist[26];
+                goto compare;
+              case 36:
+                resword = &wordlist[27];
+                goto compare;
+              case 37:
+                resword = &wordlist[28];
+                goto compare;
+              case 38:
+                resword = &wordlist[29];
+                goto compare;
+              case 39:
+                resword = &wordlist[30];
+                goto compare;
+              case 41:
+                resword = &wordlist[31];
+                goto compare;
+              case 43:
+                resword = &wordlist[32];
+                goto compare;
+              case 44:
+                resword = &wordlist[33];
+                goto compare;
+              case 45:
+                resword = &wordlist[34];
+                goto compare;
+              case 46:
+                resword = &wordlist[35];
+                goto compare;
+              case 48:
+                resword = &wordlist[36];
+                goto compare;
+              case 49:
+                resword = &wordlist[37];
+                goto compare;
+              case 52:
+                resword = &wordlist[38];
+                goto compare;
+              case 53:
+                resword = &wordlist[39];
+                goto compare;
+              case 54:
+                resword = &wordlist[40];
+                goto compare;
+              case 58:
+                resword = &wordlist[41];
+                goto compare;
+              case 59:
+                resword = &wordlist[42];
+                goto compare;
+              case 60:
+                resword = &wordlist[43];
+                goto compare;
+              case 61:
+                resword = &wordlist[44];
+                goto compare;
+              case 62:
+                resword = &wordlist[45];
+                goto compare;
+              case 63:
+                resword = &wordlist[46];
+                goto compare;
+              case 64:
+                resword = &wordlist[47];
+                goto compare;
+              case 69:
+                resword = &wordlist[48];
+                goto compare;
+              case 70:
+                resword = &wordlist[49];
+                goto compare;
+              case 71:
+                resword = &wordlist[50];
+                goto compare;
+              case 72:
+                resword = &wordlist[51];
+                goto compare;
+              case 74:
+                resword = &wordlist[52];
+                goto compare;
+              case 75:
+                resword = &wordlist[53];
+                goto compare;
+              case 76:
+                resword = &wordlist[54];
+                goto compare;
+              case 77:
+                resword = &wordlist[55];
+                goto compare;
+              case 78:
+                resword = &wordlist[56];
+                goto compare;
+              case 81:
+                resword = &wordlist[57];
+                goto compare;
+            }
+          return 0;
+        compare:
+          {
+            register const char *s = resword->name;
+
+            if (*str == *s && !strcmp (str + 1, s + 1))
+              return resword;
+          }
+        }
+    }
+  return 0;
+}
+#line 261 "ftinf_rh.gperf"
+
+
+static const sa_rules_t*
+ftinf_rules( const char *name ){
+    if( name ){
+        enum {
+            max_wlen=31
+        };
+        char buf[max_wlen+1];
+        int len=strlen( name );
+        if( len <= max_wlen ){
+            int i;
+            for( i=0; i<len; ++i )
+                buf[i]=tolower( name[i] );
+            buf[len]='\0';
+            return _rules_get( buf, len );
+        }
+    }
+    return NULL;
+}
+/*
+   gperf --output-file=ftinf_rh.c ftinf_rh.gperf
+*/
diff -ruN freetype-2.7-orig/src/base/ftinf_rh.gperf freetype-2.7/src/base/ftinf_rh.gperf
--- freetype-2.7-orig/src/base/ftinf_rh.gperf	1970-01-01 01:00:00.000000000 +0100
+++ freetype-2.7/src/base/ftinf_rh.gperf	2016-09-09 16:01:22.465167416 +0200
@@ -0,0 +1,283 @@
+%struct-type
+%define slot-name name
+%enum
+%switch=1
+%readonly-tables
+%omit-struct-type
+%define lookup-function-name  _rules_get
+%define hash-function-name _rules_hash
+%{
+#include <ctype.h>
+static const struct sa_rules_s* _rules_get( const char*str, unsigned len );
+%}
+struct sa_rules_s;
+%%
+{   .name="---",
+    .synthesize_stems={on, 13, 13, end}
+},
+{   .name="andale mono",
+    .always_use_100={on, 0, maxp, end},
+    .stem_scaling={on, 11, 1, end},
+    .stem_widths={on, 10, 21, maxp,}
+},
+{   .name="arial narrow",
+    .stem_widths={on, 10, 21, maxp,}
+},
+{   .name="arial unicode ms",
+    .always_use_100={on, 0, maxp, end},
+    .stem_translating={on, 11, 32, end},
+    .stem_translating_only={on, 10, 16, 8, 32, 9, 32, end}
+},
+{   .name="arial",
+    .always_use_100={on, 0, maxp, end},
+    .edge_detection={on, 11, 11, 13, 13, end},
+    .spacing={on, 10, 11, 23, 25, 30, end},
+    .start={on, 11, 18, 23, 30, 30, end},
+    .stem_translating={on, 11, 32, end},
+    .stem_translating_only={on, 10, 16, 8, 32, 9, 32, 16, -24, end}
+},
+{   .name="arimo",
+    .always_use_100={on, 0, maxp, end},
+    .stem_translating={on, 11, 32, end},
+    .stem_translating_only={on, 10, 8, 8, 32, 9, 32, end}
+},
+{   .name="baskerville",
+    .brightness={on, 0, -20, end},
+    .contrast={on, 0, 25, end}
+},
+{   .name="bitstream vera sans mono",
+    .always_use_100={on, 0, maxp, end}
+},
+{   .name="bitstream vera sans",
+    .always_use_100={on, 10, 14, 16, 17, end},
+    .m={on, 12, 0, end},
+    .stem_scaling={on ,12, 1, end},
+    .stem_translating_only={on, 8, 16, end}
+},
+{   .name="calibri",
+    .always_use_100={on, 23, maxp, end},
+    .stem_scaling={on, 15, 1, 17, 1, 18, 1, end},
+    .stem_translating_only={on, 10, 16, 15, 0, end},
+    .stem_widths={on, 1, 10, 19, maxp,}
+},
+{   .name="candara",
+    .stem_scaling={on, 14, 1, 17, 1, end},
+    .stem_translating_only={on, 10, 16, end}
+},
+{   .name="cantarell",
+    .stem_translating_only={on, 11, 0, 12, 0, end},
+    .stem_widths={on, 10, 22, maxp,}
+},
+{   .name="canwell",
+    .stem_scaling={on, 13, 0, end}
+},
+{   .name="century gothic",
+    .stem_widths={on, 10, 22, maxp,}
+},
+{   .name="comfortaa",
+    .stem_widths={on, 10, 19, 22, maxp},
+    .stem_scaling={on, 11, 0, end}
+},
+{   .name="consolas",
+    .always_use_100={on, 0, maxp, end},
+    .stem_translating_only={on, 8, 32, 9, 32, end},
+    .stem_widths={on, 10, 20, maxp,},
+    .stem_scaling={on, 11, 1, end}
+},
+{   .name="corbel",
+    .stem_translating_only={on, 10, 16, end},
+    .stem_widths={on, 10, 21, maxp}
+},
+{   .name="courier new",
+    .always_use_100={on, 12, 12, end},
+    .edge_detection={on, 10, 12, end},
+    .m={on, 13, 1, 14, 1, end}
+},
+{   .name="courier",
+    .always_use_100={on, 0, maxp, end},
+    .m={on, 13, 1, 14, 1, end},
+    .stem_translating_only={on, 13, 16, 15, 0, end}
+},
+{   .name="cousine",
+    .always_use_100={on, 0, maxp, end}
+},
+{   .name="dejavu sans mono",
+    .always_use_100={on, 0, maxp, end},
+    .stem_translating_only={on, 7, 16, 8, 32, 9, 16, end}
+},
+{   .name="dejavu sans",
+    .always_use_100={on, 10, 14, 16, 17, end},
+    .m={on, 12, 0, end},
+    .stem_scaling={on, 12, 1, end},
+    .stem_translating_only={on, 8, 16, 15, -20, end}
+},
+{   .name="droid sans mono",
+    .m={on, 12, 0, end}
+},
+{   .name="droid sans",
+    .always_use_100={on, 12, 12, 15, 15, end},
+    .stem_translating_only={on, 8, 16, 9, 16, end}
+},
+{   .name="essential pragmatapro",
+    .always_use_100={on, 0, maxp, end},
+    .m={on, 13, 0, 14, 0, end}
+},
+{   .name="freemono",
+    .always_use_100={on, 0, maxp, end}
+},
+{   .name="freesans",
+    .always_use_100={on, 0, maxp, end},
+    .edge_detection={on, 11, 11, 13, 13, end},
+    .spacing={on, 10, 12, 18, 18, 30, end},
+    .start={on, 10, 18, 18, 25, 30, end},
+    .stem_scaling={on, 16, 0, end},
+    .stem_translating={on, 11, 32, end},
+    .stem_translating_only={on, 10, 16, 9, 8, end}
+},
+{   .name="freeserif",
+    .stem_scaling={on, 13, 1, 17, 1, end}
+},
+{   .name="futura",
+    .stem_widths={on, 10, 14, sw2pv, maxp,}
+},
+{   .name="garamond",
+    .brightness={on, 0, -20, end},
+    .contrast={on, 0, 25, end}
+},
+{   .name="georgia",
+    .stem_translating_only={on, 13, 16, 14, 16, 15, 0, end}
+},
+{   .name="gill sans",
+    .stem_widths={on, 10, 17, sw2pv, maxp,}
+},
+{   .name="helvetica cy",
+    .stem_widths={on, 10, 23, maxp,}
+},
+{   .name="inconsolata",
+    .stem_scaling={on, 12, 1, 15, 1, end},
+    .stem_translating_only={on, 10, 24, 9, 32, end},
+    .stem_widths={on, 10, 23, maxp,},
+},
+{   .name="liberation mono",
+    .always_use_100={on, 0, maxp, end}
+},
+{   .name="liberation sans narrow",
+    .stem_widths={on,10, 22, maxp,}
+},
+{   .name="liberation sans",
+    .edge_detection={on, 11, 11, end},
+    .stem_translating={on, 11, 32, end},
+    .stem_translating_only={on, 10, 8, 8, 32, 9, 32, end},
+    .stem_widths={on,10, 19, maxp,}
+},
+{   .name="lucida console",
+    .always_use_100={on, 0, maxp, end}
+},
+{   .name="lucida grande",
+    .stem_scaling={on, 13, 1, end},
+    .stem_translating_only={on, 13, 24, 14, 24, 8, 16, 9, 16, end},
+    .stem_widths={on, 10, 16, sw2pv, maxp},
+},
+{   .name="lucida sans unicode",
+    .stem_translating_only={on, 13, 24, 14, 24, 8, 16, 9, 16, end},
+    .stem_widths={on,10, 16, sw2pv, maxp,}
+},
+{   .name="luxi sans",
+    .always_use_100={on, 13, 13, end},
+    .stem_widths={on, 10, 17, sw2pv, maxp,}
+},
+{   .name="microsoft sans serif",
+    .always_use_100={on, 0, maxp, end},
+    .stem_translating_only={on, 10, 16, 8, 32, 9, 32, end}
+},
+{   .name="monaco",
+    .always_use_100={on, 0, maxp, end}
+},
+{   .name="myriad pro",
+    .stem_scaling={on, 14, 1, 17, 1, end},
+    .stem_translating_only={on, 10, 16, 11, 0, 9, 16, end}
+},
+{   .name="nina",
+    .stem_scaling={on, 11, 0, 12, 0, 13, 0, end}
+},
+{   .name="open sans",
+    .stem_translating_only={on, 10, 16, 9, 16, end},
+    .stem_widths={on, 10, 20, maxp,}
+},
+{   .name="optima",
+    .brightness={on, 0, -20, end},
+    .contrast={on, 0, 25, end},
+    .stem_scaling={on, 17, 1, end},
+    .stem_translating_only={on, 10, 0, 11, 0, 12, 0, end}
+},
+{   .name="palatino linotype",
+    .edge_detection={on, 0, 100, end}
+},
+{   .name="pragmata",
+    .always_use_100={on, 0, maxp, end}
+},
+{   .name="raleway",
+    .stem_scaling={on, 15, 0, end}
+},
+{   .name="rokkitt",
+    .stem_widths={on, 10, 21, maxp,}
+},
+{   .name="samba",
+    .stem_scaling={on, 11, 0, end}
+},
+{   .name="segoe ui",
+    .always_use_100={on, 11, 12, 14, 14, end},
+    .stem_translating_only={on, 10, 0, 7, 32, 8, 16, 9, 24, end},
+    .stem_widths={on, 10, 23, maxp,}
+},
+{   .name="tahoma",
+    .always_use_100={on, 11, 11, 14, maxp, end},
+    .edge_detection={on, 11, 11, end},
+    .spacing={on, 10, 12, 18, 18, 30, end},
+    .start={on, 14, 17, 30, 100, 100, end},
+    .stem_translating={on, 11, 32, end},
+    .stem_translating_only={on, 7, 32, 8, 32, 9, 32, end},
+},
+{   .name="times new roman",
+    .always_use_100={on, 14, 14, 16, 16, end},
+    .bearing_correction={0, 100, end},
+    .stem_scaling={on, 17, 1, end},
+    .stem_translating_only={on, 17, 8, end}
+},
+{   .name="trebuchet ms",
+    .always_use_100={on, 13, 13, end},
+    .stem_scaling={on, 13, 0, 17, 0, 20, 1, end},
+    .stem_translating_only={on, 10, 16, 11, 0, 8, 32, 9, 32, end},
+    .stem_widths={on, 10, 17, sw2pv, maxp,}
+},
+{   .name="ubuntu",
+    .always_use_100={on, 12, 13, 15, 15, end}
+},
+{   .name="verdana",
+    .always_use_100={on, 0, 14, 16, maxp, end},
+    .stem_scaling={on, 12, 1, 15, 1, end},
+    .stem_translating_only={on, 8, 16, 15, 16, 14, 32, 18, 32, 19, 24, end}
+},
+%%
+
+static const sa_rules_t*
+ftinf_rules( const char *name ){
+    if( name ){
+        enum {
+            max_wlen=31
+        };
+        char buf[max_wlen+1];
+        int len=strlen( name );
+        if( len <= max_wlen ){
+            int i;
+            for( i=0; i<len; ++i )
+                buf[i]=tolower( name[i] );
+            buf[len]='\0';
+            return _rules_get( buf, len );
+        }
+    }
+    return NULL;
+}
+/*
+   gperf --output-file=ftinf_rh.c ftinf_rh.gperf
+*/
diff -ruN freetype-2.7-orig/src/base/ftinf_sh.c freetype-2.7/src/base/ftinf_sh.c
--- freetype-2.7-orig/src/base/ftinf_sh.c	1970-01-01 01:00:00.000000000 +0100
+++ freetype-2.7/src/base/ftinf_sh.c	2016-09-09 16:01:22.465167416 +0200
@@ -0,0 +1,463 @@
+/* ANSI-C code produced by gperf version 3.1 */
+/* Command-line: gperf --output-file=ftinf_sh.c ftinf_sh.gperf  */
+/* Computed positions: -k'1,$' */
+
+#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
+      && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
+      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
+      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
+      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
+      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
+      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
+      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
+      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
+      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
+      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
+      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
+      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
+      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
+      && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
+      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
+      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
+      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
+      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
+      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
+      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
+      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
+      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
+/* The character set is not based on ISO-646.  */
+#error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
+#endif
+
+#line 9 "ftinf_sh.gperf"
+
+#include <ctype.h>
+static const struct ftinf_s* _settings_get( const char*str, unsigned len);
+/* maximum key range = 37, duplicates = 0 */
+
+#ifdef __GNUC__
+__inline
+#else
+#ifdef __cplusplus
+inline
+#endif
+#endif
+static unsigned int
+_settings_hash (register const char *str, register unsigned int len)
+{
+  static const unsigned char asso_values[] =
+    {
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 13,
+       8, 30, 25, 20, 40, 10, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40,  5, 40,  0,
+       0,  0, 40, 40, 10,  0, 40, 40, 15,  5,
+      10,  0, 10, 40, 40,  0,  0,  0,  0,  0,
+       0,  0, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40
+    };
+  return len + asso_values[(unsigned char)str[len - 1]] + asso_values[(unsigned char)str[0]];
+}
+
+#ifdef __GNUC__
+__inline
+#if defined __GNUC_STDC_INLINE__ || defined __GNUC_GNU_INLINE__
+__attribute__ ((__gnu_inline__))
+#endif
+#endif
+const struct ftinf_s *
+_settings_get (register const char *str, register unsigned int len)
+{
+  enum
+    {
+      TOTAL_KEYWORDS = 22,
+      MIN_WORD_LENGTH = 3,
+      MAX_WORD_LENGTH = 14,
+      MIN_HASH_VALUE = 3,
+      MAX_HASH_VALUE = 39
+    };
+
+  static const struct ftinf_s wordlist[] =
+    {
+#line 76 "ftinf_sh.gperf"
+{   .name="osx",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_vertical_stem_darken_strength=25,
+    .bold_embolden_x_value=16,
+    .brightness=10,
+    .contrast=20,
+    .filter_params={on, 3, 32, 38, 32, 3},
+    .gamma_correction={1000, 80},
+    .global_embolden_y_value=8,
+    .grayscale_filter_strength=25,
+},
+#line 37 "ftinf_sh.gperf"
+{   .name="ipad",
+    .filter_params={on, 0, 0, 100, 0, 0},
+    .gamma_correction={1000, 80},
+    .grayscale_filter_strength=100
+},
+#line 114 "ftinf_sh.gperf"
+{   .name="shove",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_increase_glyph_heights=true,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .filter_params={on, 11, 22, 38, 22, 11},
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=100,
+    .stem_fitting_strength=100,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true
+},
+#line 126 "ftinf_sh.gperf"
+{   .name="ubuntu",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_vertical_stem_darken_strength=25,
+    .brightness=-10,
+    .contrast=15,
+    .filter_params={on, 11, 22, 38, 22, 11},
+    .gamma_correction={1000, 80},
+    .use_various_tweaks=true
+},
+#line 27 "ftinf_sh.gperf"
+{   .name="classic",
+    .autohint_increase_glyph_heights=true,
+    .autohint_snap_stem_height=100,
+    .filter_params={on, 6, 25, 38, 25, 6},
+    .gamma_correction={0, 100},
+    .use_various_tweaks=true
+},
+#line 34 "ftinf_sh.gperf"
+{   .name="disabled",
+    .gamma_correction={0, 100},
+},
+#line 100 "ftinf_sh.gperf"
+{   .name="sharpened",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_increase_glyph_heights=true,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .filter_params={on, 11, 22, 38, 22, 11},
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=25,
+    .stem_fitting_strength=25,
+    .stem_snapping_sliding_scale=40,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=65
+},
+#line 42 "ftinf_sh.gperf"
+{   .name="infinality",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_increase_glyph_heights=true,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .filter_params={on, 11, 22, 38, 22, 11},
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=25,
+    .stem_fitting_strength=25,
+    .stem_snapping_sliding_scale=40,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=5
+},
+#line 15 "ftinf_sh.gperf"
+{   .name="custom",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .filter_params={on, 8, 24, 48, 24, 8},
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=75,
+    .stem_fitting_strength=50,
+    .stem_snapping_sliding_scale=30,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true
+},
+#line 180 "ftinf_sh.gperf"
+{   .name="vanilla",
+    .filter_params={on, 6, 25, 38, 25, 6},
+    .gamma_correction={0, 100},
+},
+#line 184 "ftinf_sh.gperf"
+{   .name="windows7light",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .contrast=20,
+    .filter_params={on, 20, 25, 38, 25, 05},
+    .fringe_filter_strength=100,
+    .gamma_correction={1000, 160},
+    .stem_snapping_sliding_scale=30,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=100
+},
+#line 226 "ftinf_sh.gperf"
+{   .name="windowsxplight",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .brightness=20,
+    .contrast=30,
+    .filter_params={on, 6, 25, 44, 25, 6},
+    .fringe_filter_strength=100,
+    .gamma_correction={1000, 120},
+    .stem_alignment_strength=15,
+    .stem_fitting_strength=15,
+    .stem_snapping_sliding_scale=30,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=65
+},
+#line 64 "ftinf_sh.gperf"
+{   .name="nudge",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_increase_glyph_heights=true,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .filter_params={on, 11, 22, 38, 22, 11},
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=25,
+    .stem_fitting_strength=15,
+    .stem_snapping_sliding_scale=30,
+    .use_various_tweaks=true,
+},
+#line 144 "ftinf_sh.gperf"
+{   .name="ultimate2",
+    .filter_params={on, 6, 22, 36, 22, 6},
+    .fringe_filter_strength=25,
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=15,
+    .stem_fitting_strength=15,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=25
+},
+#line 197 "ftinf_sh.gperf"
+{   .name="windows7",
+    .filter_params={on, 20, 25, 42, 25, 06},
+    .fringe_filter_strength=100,
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_vertical_stem_darken_strength=25,
+    .windows_style_sharpening_strength=65,
+    .gamma_correction={1000, 120},
+    .brightness=10,
+    .contrast=20,
+    .use_various_tweaks=true,
+    .autohint_snap_stem_height=100,
+    .use_known_settings_on_selected_fonts=true,
+},
+#line 210 "ftinf_sh.gperf"
+{   .name="windowsxp",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .brightness=10,
+    .contrast=20,
+    .filter_params={on, 6, 25, 44, 25, 6},
+    .fringe_filter_strength=100,
+    .gamma_correction={1000, 120},
+    .stem_alignment_strength=15,
+    .stem_fitting_strength=15,
+    .stem_snapping_sliding_scale=30,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=65
+},
+#line 56 "ftinf_sh.gperf"
+{   .name="linux",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .filter_params={on, 6, 25, 44, 25, 6},
+    .gamma_correction={0, 100},
+    .use_various_tweaks=true
+},
+#line 135 "ftinf_sh.gperf"
+{   .name="ultimate1",
+    .filter_params={on, 4, 22, 38, 22, 4},
+    .fringe_filter_strength=25,
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=15,
+    .stem_fitting_strength=15,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=25
+},
+#line 87 "ftinf_sh.gperf"
+{   .name="push",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_increase_glyph_heights=true,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .filter_params={on, 11, 22, 38, 22, 11},
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=75,
+    .stem_fitting_strength=50,
+    .stem_snapping_sliding_scale=30,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true
+},
+#line 171 "ftinf_sh.gperf"
+{   .name="ultimate5",
+    .filter_params={on, 12, 28, 42, 28, 12},
+    .fringe_filter_strength=25,
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=15,
+    .stem_fitting_strength=15,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=25
+},
+#line 162 "ftinf_sh.gperf"
+{   .name="ultimate4",
+    .filter_params={on, 10, 25, 37, 25, 10},
+    .fringe_filter_strength=25,
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=15,
+    .stem_fitting_strength=15,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=25
+},
+#line 153 "ftinf_sh.gperf"
+{   .name="ultimate3",
+    .filter_params={on, 8, 24, 36, 24, 8},
+    .fringe_filter_strength=25,
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=15,
+    .stem_fitting_strength=15,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=25
+}
+    };
+
+  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
+    {
+      register int key = _settings_hash (str, len);
+
+      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
+        {
+          register const struct ftinf_s *resword;
+
+          switch (key - 3)
+            {
+              case 0:
+                resword = &wordlist[0];
+                goto compare;
+              case 1:
+                resword = &wordlist[1];
+                goto compare;
+              case 2:
+                resword = &wordlist[2];
+                goto compare;
+              case 3:
+                resword = &wordlist[3];
+                goto compare;
+              case 4:
+                resword = &wordlist[4];
+                goto compare;
+              case 5:
+                resword = &wordlist[5];
+                goto compare;
+              case 6:
+                resword = &wordlist[6];
+                goto compare;
+              case 7:
+                resword = &wordlist[7];
+                goto compare;
+              case 8:
+                resword = &wordlist[8];
+                goto compare;
+              case 9:
+                resword = &wordlist[9];
+                goto compare;
+              case 10:
+                resword = &wordlist[10];
+                goto compare;
+              case 11:
+                resword = &wordlist[11];
+                goto compare;
+              case 12:
+                resword = &wordlist[12];
+                goto compare;
+              case 14:
+                resword = &wordlist[13];
+                goto compare;
+              case 15:
+                resword = &wordlist[14];
+                goto compare;
+              case 16:
+                resword = &wordlist[15];
+                goto compare;
+              case 17:
+                resword = &wordlist[16];
+                goto compare;
+              case 19:
+                resword = &wordlist[17];
+                goto compare;
+              case 21:
+                resword = &wordlist[18];
+                goto compare;
+              case 26:
+                resword = &wordlist[19];
+                goto compare;
+              case 31:
+                resword = &wordlist[20];
+                goto compare;
+              case 36:
+                resword = &wordlist[21];
+                goto compare;
+            }
+          return 0;
+        compare:
+          {
+            register const char *s = resword->name;
+
+            if (*str == *s && !strcmp (str + 1, s + 1))
+              return resword;
+          }
+        }
+    }
+  return 0;
+}
+#line 242 "ftinf_sh.gperf"
+
+
+static const ftinf_t*
+ftinf_settings( const char *name ){
+    if( name ){
+        enum {
+            max_wlen=31
+        };
+        char buf[max_wlen+1];
+        int len=strlen( name );
+        if( len <= max_wlen ){
+            int i;
+            for( i=0; i<len; ++i )
+                buf[i]=tolower( name[i] );
+            buf[len]='\0';
+            return _settings_get( buf, len );
+        }
+    }
+    return NULL;
+}
+/*
+   gperf --output-file=ftinf_sh.c ftinf_sh.gperf
+*/
diff -ruN freetype-2.7-orig/src/base/ftinf_sh.gperf freetype-2.7/src/base/ftinf_sh.gperf
--- freetype-2.7-orig/src/base/ftinf_sh.gperf	1970-01-01 01:00:00.000000000 +0100
+++ freetype-2.7/src/base/ftinf_sh.gperf	2016-09-09 16:01:22.465167416 +0200
@@ -0,0 +1,264 @@
+%struct-type
+%define slot-name name
+%enum
+%switch=1
+%readonly-tables
+%omit-struct-type
+%define lookup-function-name   _settings_get
+%define hash-function-name _settings_hash
+%{
+#include <ctype.h>
+static const struct ftinf_s* _settings_get( const char*str, unsigned len);
+%}
+struct ftinf_s;
+%%
+{   .name="custom",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .filter_params={on, 8, 24, 48, 24, 8},
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=75,
+    .stem_fitting_strength=50,
+    .stem_snapping_sliding_scale=30,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true
+},
+{   .name="classic",
+    .autohint_increase_glyph_heights=true,
+    .autohint_snap_stem_height=100,
+    .filter_params={on, 6, 25, 38, 25, 6},
+    .gamma_correction={0, 100},
+    .use_various_tweaks=true
+},
+{   .name="disabled",
+    .gamma_correction={0, 100},
+},
+{   .name="ipad",
+    .filter_params={on, 0, 0, 100, 0, 0},
+    .gamma_correction={1000, 80},
+    .grayscale_filter_strength=100
+},
+{   .name="infinality",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_increase_glyph_heights=true,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .filter_params={on, 11, 22, 38, 22, 11},
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=25,
+    .stem_fitting_strength=25,
+    .stem_snapping_sliding_scale=40,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=5
+},
+{   .name="linux",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .filter_params={on, 6, 25, 44, 25, 6},
+    .gamma_correction={0, 100},
+    .use_various_tweaks=true
+},
+{   .name="nudge",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_increase_glyph_heights=true,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .filter_params={on, 11, 22, 38, 22, 11},
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=25,
+    .stem_fitting_strength=15,
+    .stem_snapping_sliding_scale=30,
+    .use_various_tweaks=true,
+},
+{   .name="osx",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_vertical_stem_darken_strength=25,
+    .bold_embolden_x_value=16,
+    .brightness=10,
+    .contrast=20,
+    .filter_params={on, 3, 32, 38, 32, 3},
+    .gamma_correction={1000, 80},
+    .global_embolden_y_value=8,
+    .grayscale_filter_strength=25,
+},
+{   .name="push",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_increase_glyph_heights=true,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .filter_params={on, 11, 22, 38, 22, 11},
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=75,
+    .stem_fitting_strength=50,
+    .stem_snapping_sliding_scale=30,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true
+},
+{   .name="sharpened",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_increase_glyph_heights=true,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .filter_params={on, 11, 22, 38, 22, 11},
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=25,
+    .stem_fitting_strength=25,
+    .stem_snapping_sliding_scale=40,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=65
+},
+{   .name="shove",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_increase_glyph_heights=true,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .filter_params={on, 11, 22, 38, 22, 11},
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=100,
+    .stem_fitting_strength=100,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true
+},
+{   .name="ubuntu",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_vertical_stem_darken_strength=25,
+    .brightness=-10,
+    .contrast=15,
+    .filter_params={on, 11, 22, 38, 22, 11},
+    .gamma_correction={1000, 80},
+    .use_various_tweaks=true
+},
+{   .name="ultimate1",
+    .filter_params={on, 4, 22, 38, 22, 4},
+    .fringe_filter_strength=25,
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=15,
+    .stem_fitting_strength=15,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=25
+},
+{   .name="ultimate2",
+    .filter_params={on, 6, 22, 36, 22, 6},
+    .fringe_filter_strength=25,
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=15,
+    .stem_fitting_strength=15,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=25
+},
+{   .name="ultimate3",
+    .filter_params={on, 8, 24, 36, 24, 8},
+    .fringe_filter_strength=25,
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=15,
+    .stem_fitting_strength=15,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=25
+},
+{   .name="ultimate4",
+    .filter_params={on, 10, 25, 37, 25, 10},
+    .fringe_filter_strength=25,
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=15,
+    .stem_fitting_strength=15,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=25
+},
+{   .name="ultimate5",
+    .filter_params={on, 12, 28, 42, 28, 12},
+    .fringe_filter_strength=25,
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=15,
+    .stem_fitting_strength=15,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=25
+},
+{   .name="vanilla",
+    .filter_params={on, 6, 25, 38, 25, 6},
+    .gamma_correction={0, 100},
+},
+{   .name="windows7light",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .contrast=20,
+    .filter_params={on, 20, 25, 38, 25, 05},
+    .fringe_filter_strength=100,
+    .gamma_correction={1000, 160},
+    .stem_snapping_sliding_scale=30,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=100
+},
+{   .name="windows7",
+    .filter_params={on, 20, 25, 42, 25, 06},
+    .fringe_filter_strength=100,
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_vertical_stem_darken_strength=25,
+    .windows_style_sharpening_strength=65,
+    .gamma_correction={1000, 120},
+    .brightness=10,
+    .contrast=20,
+    .use_various_tweaks=true,
+    .autohint_snap_stem_height=100,
+    .use_known_settings_on_selected_fonts=true,
+},
+{   .name="windowsxp",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .brightness=10,
+    .contrast=20,
+    .filter_params={on, 6, 25, 44, 25, 6},
+    .fringe_filter_strength=100,
+    .gamma_correction={1000, 120},
+    .stem_alignment_strength=15,
+    .stem_fitting_strength=15,
+    .stem_snapping_sliding_scale=30,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=65
+},
+{   .name="windowsxplight",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .brightness=20,
+    .contrast=30,
+    .filter_params={on, 6, 25, 44, 25, 6},
+    .fringe_filter_strength=100,
+    .gamma_correction={1000, 120},
+    .stem_alignment_strength=15,
+    .stem_fitting_strength=15,
+    .stem_snapping_sliding_scale=30,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=65
+},
+%%
+
+static const ftinf_t*
+ftinf_settings( const char *name ){
+    if( name ){
+        enum {
+            max_wlen=31
+        };
+        char buf[max_wlen+1];
+        int len=strlen( name );
+        if( len <= max_wlen ){
+            int i;
+            for( i=0; i<len; ++i )
+                buf[i]=tolower( name[i] );
+            buf[len]='\0';
+            return _settings_get( buf, len );
+        }
+    }
+    return NULL;
+}
+/*
+   gperf --output-file=ftinf_sh.c ftinf_sh.gperf
+*/
diff -ruN freetype-2.7-orig/src/base/ftinit.c freetype-2.7/src/base/ftinit.c
--- freetype-2.7-orig/src/base/ftinit.c	2016-08-26 11:45:36.000000000 +0200
+++ freetype-2.7/src/base/ftinit.c	2016-09-09 16:07:57.804936162 +0200
@@ -43,7 +43,9 @@
 #include FT_INTERNAL_DEBUG_H
 #include FT_MODULE_H
 #include "basepic.h"
-
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+#include "ftinf.h"
+#endif
 
   /*************************************************************************/
   /*                                                                       */
@@ -362,11 +364,14 @@
     error = FT_New_Library( memory, alibrary );
     if ( error )
       FT_Done_Memory( memory );
-    else
+    else {
       FT_Add_Default_Modules( *alibrary );
-
-    ft_set_default_properties( *alibrary );
-
+      ft_set_default_properties( *alibrary );
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+	/* get Infinality settings */
+	ftinf_env();
+#endif
+    }
     return error;
   }
 
diff -ruN freetype-2.7-orig/src/base/ftinit.c.orig freetype-2.7/src/base/ftinit.c.orig
--- freetype-2.7-orig/src/base/ftinit.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ freetype-2.7/src/base/ftinit.c.orig	2016-08-26 11:45:36.000000000 +0200
@@ -0,0 +1,397 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftinit.c                                                               */
+/*                                                                         */
+/*    FreeType initialization layer (body).                                */
+/*                                                                         */
+/*  Copyright 1996-2016 by                                                 */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+  /*************************************************************************/
+  /*                                                                       */
+  /*  The purpose of this file is to implement the following two           */
+  /*  functions:                                                           */
+  /*                                                                       */
+  /*  FT_Add_Default_Modules():                                            */
+  /*     This function is used to add the set of default modules to a      */
+  /*     fresh new library object.  The set is taken from the header file  */
+  /*     `freetype/config/ftmodule.h'.  See the document `FreeType 2.0     */
+  /*     Build System' for more information.                               */
+  /*                                                                       */
+  /*  FT_Init_FreeType():                                                  */
+  /*     This function creates a system object for the current platform,   */
+  /*     builds a library out of it, then calls FT_Default_Drivers().      */
+  /*                                                                       */
+  /*  Note that even if FT_Init_FreeType() uses the implementation of the  */
+  /*  system object defined at build time, client applications are still   */
+  /*  able to provide their own `ftsystem.c'.                              */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+#include <ft2build.h>
+#include FT_CONFIG_CONFIG_H
+#include FT_INTERNAL_OBJECTS_H
+#include FT_INTERNAL_DEBUG_H
+#include FT_MODULE_H
+#include "basepic.h"
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
+  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
+  /* messages during execution.                                            */
+  /*                                                                       */
+#undef  FT_COMPONENT
+#define FT_COMPONENT  trace_init
+
+
+#ifndef FT_CONFIG_OPTION_PIC
+
+
+#undef  FT_USE_MODULE
+#ifdef __cplusplus
+#define FT_USE_MODULE( type, x )  extern "C" const type  x;
+#else
+#define FT_USE_MODULE( type, x )  extern const type  x;
+#endif
+
+#include FT_CONFIG_MODULES_H
+
+#undef  FT_USE_MODULE
+#define FT_USE_MODULE( type, x )  (const FT_Module_Class*)&(x),
+
+  static
+  const FT_Module_Class*  const ft_default_modules[] =
+  {
+#include FT_CONFIG_MODULES_H
+    0
+  };
+
+
+#else /* FT_CONFIG_OPTION_PIC */
+
+
+#ifdef __cplusplus
+#define FT_EXTERNC  extern "C"
+#else
+#define FT_EXTERNC  extern
+#endif
+
+  /* declare the module's class creation/destruction functions */
+#undef  FT_USE_MODULE
+#define FT_USE_MODULE( type, x )                            \
+  FT_EXTERNC FT_Error                                       \
+  FT_Create_Class_ ## x( FT_Library         library,        \
+                         FT_Module_Class*  *output_class ); \
+  FT_EXTERNC void                                           \
+  FT_Destroy_Class_ ## x( FT_Library        library,        \
+                          FT_Module_Class*  clazz );
+
+#include FT_CONFIG_MODULES_H
+
+  /* count all module classes */
+#undef  FT_USE_MODULE
+#define FT_USE_MODULE( type, x )  MODULE_CLASS_ ## x,
+
+  enum
+  {
+#include FT_CONFIG_MODULES_H
+    FT_NUM_MODULE_CLASSES
+  };
+
+  /* destroy all module classes */
+#undef  FT_USE_MODULE
+#define FT_USE_MODULE( type, x )                   \
+  if ( classes[i] )                                \
+  {                                                \
+    FT_Destroy_Class_ ## x( library, classes[i] ); \
+  }                                                \
+  i++;
+
+
+  FT_BASE_DEF( void )
+  ft_destroy_default_module_classes( FT_Library  library )
+  {
+    FT_Module_Class*  *classes;
+    FT_Memory          memory;
+    FT_UInt            i;
+    BasePIC*           pic_container = (BasePIC*)library->pic_container.base;
+
+
+    if ( !pic_container->default_module_classes )
+      return;
+
+    memory  = library->memory;
+    classes = pic_container->default_module_classes;
+    i       = 0;
+
+#include FT_CONFIG_MODULES_H
+
+    FT_FREE( classes );
+    pic_container->default_module_classes = NULL;
+  }
+
+
+  /* initialize all module classes and the pointer table */
+#undef  FT_USE_MODULE
+#define FT_USE_MODULE( type, x )                     \
+  error = FT_Create_Class_ ## x( library, &clazz );  \
+  if ( error )                                       \
+    goto Exit;                                       \
+  classes[i++] = clazz;
+
+
+  FT_BASE_DEF( FT_Error )
+  ft_create_default_module_classes( FT_Library  library )
+  {
+    FT_Error           error;
+    FT_Memory          memory;
+    FT_Module_Class*  *classes = NULL;
+    FT_Module_Class*   clazz;
+    FT_UInt            i;
+    BasePIC*           pic_container = (BasePIC*)library->pic_container.base;
+
+
+    memory = library->memory;
+
+    pic_container->default_module_classes = NULL;
+
+    if ( FT_ALLOC( classes, sizeof ( FT_Module_Class* ) *
+                              ( FT_NUM_MODULE_CLASSES + 1 ) ) )
+      return error;
+
+    /* initialize all pointers to 0, especially the last one */
+    for ( i = 0; i < FT_NUM_MODULE_CLASSES; i++ )
+      classes[i] = NULL;
+    classes[FT_NUM_MODULE_CLASSES] = NULL;
+
+    i = 0;
+
+#include FT_CONFIG_MODULES_H
+
+  Exit:
+    if ( error )
+      ft_destroy_default_module_classes( library );
+    else
+      pic_container->default_module_classes = classes;
+
+    return error;
+  }
+
+
+#endif /* FT_CONFIG_OPTION_PIC */
+
+
+  /* documentation is in ftmodapi.h */
+
+  FT_EXPORT_DEF( void )
+  FT_Add_Default_Modules( FT_Library  library )
+  {
+    FT_Error                       error;
+    const FT_Module_Class* const*  cur;
+
+
+    /* FT_DEFAULT_MODULES_GET dereferences `library' in PIC mode */
+#ifdef FT_CONFIG_OPTION_PIC
+    if ( !library )
+      return;
+#endif
+
+    /* GCC 4.6 warns the type difference:
+     *   FT_Module_Class** != const FT_Module_Class* const*
+     */
+    cur = (const FT_Module_Class* const*)FT_DEFAULT_MODULES_GET;
+
+    /* test for valid `library' delayed to FT_Add_Module() */
+    while ( *cur )
+    {
+      error = FT_Add_Module( library, *cur );
+      /* notify errors, but don't stop */
+      if ( error )
+        FT_TRACE0(( "FT_Add_Default_Module:"
+                    " Cannot install `%s', error = 0x%x\n",
+                    (*cur)->module_name, error ));
+      cur++;
+    }
+  }
+
+
+#ifdef FT_CONFIG_OPTION_ENVIRONMENT_PROPERTIES
+
+#define MAX_LENGTH  128
+
+  /*
+   * Set default properties derived from the `FREETYPE_PROPERTIES'
+   * environment variable.
+   *
+   * `FREETYPE_PROPERTIES' has the following syntax form (broken here into
+   * multiple lines for better readability)
+   *
+   *   <optional whitespace>
+   *   <module-name1> ':'
+   *   <property-name1> '=' <property-value1>
+   *   <whitespace>
+   *   <module-name2> ':'
+   *   <property-name2> '=' <property-value2>
+   *   ...
+   *
+   * Example:
+   *
+   *   FREETYPE_PROPERTIES=truetype:interpreter-version=35 \
+   *                       cff:no-stem-darkening=1 \
+   *                       autofitter:warping=1
+   *
+   */
+
+  static void
+  ft_set_default_properties( FT_Library  library )
+  {
+    const char*  env;
+    const char*  p;
+    const char*  q;
+
+    char  module_name[MAX_LENGTH + 1];
+    char  property_name[MAX_LENGTH + 1];
+    char  property_value[MAX_LENGTH + 1];
+
+    int  i;
+
+
+    env = ft_getenv( "FREETYPE_PROPERTIES" );
+    if ( !env )
+      return;
+
+    for ( p = env; *p; p++ )
+    {
+      /* skip leading whitespace and separators */
+      if ( *p == ' ' || *p == '\t' )
+        continue;
+
+      /* read module name, followed by `:' */
+      q = p;
+      for ( i = 0; i < MAX_LENGTH; i++ )
+      {
+        if ( !*p || *p == ':' )
+          break;
+        module_name[i] = *p++;
+      }
+      module_name[i] = '\0';
+
+      if ( !*p || *p != ':' || p == q )
+        break;
+
+      /* read property name, followed by `=' */
+      q = ++p;
+      for ( i = 0; i < MAX_LENGTH; i++ )
+      {
+        if ( !*p || *p == '=' )
+          break;
+        property_name[i] = *p++;
+      }
+      property_name[i] = '\0';
+
+      if ( !*p || *p != '=' || p == q )
+        break;
+
+      /* read property value, followed by whitespace (if any) */
+      q = ++p;
+      for ( i = 0; i < MAX_LENGTH; i++ )
+      {
+        if ( !*p || *p == ' ' || *p == '\t' )
+          break;
+        property_value[i] = *p++;
+      }
+      property_value[i] = '\0';
+
+      if ( !( *p == '\0' || *p == ' ' || *p == '\t' ) || p == q )
+        break;
+
+      /* we completely ignore errors */
+      ft_property_string_set( library,
+                              module_name,
+                              property_name,
+                              property_value );
+    }
+  }
+
+#else
+
+  static void
+  ft_set_default_properties( FT_Library  library )
+  {
+    FT_UNUSED( library );
+  }
+
+#endif
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_Init_FreeType( FT_Library  *alibrary )
+  {
+    FT_Error   error;
+    FT_Memory  memory;
+
+
+    /* check of `alibrary' delayed to `FT_New_Library' */
+
+    /* First of all, allocate a new system object -- this function is part */
+    /* of the system-specific component, i.e. `ftsystem.c'.                */
+
+    memory = FT_New_Memory();
+    if ( !memory )
+    {
+      FT_ERROR(( "FT_Init_FreeType: cannot find memory manager\n" ));
+      return FT_THROW( Unimplemented_Feature );
+    }
+
+    /* build a library out of it, then fill it with the set of */
+    /* default drivers.                                        */
+
+    error = FT_New_Library( memory, alibrary );
+    if ( error )
+      FT_Done_Memory( memory );
+    else
+      FT_Add_Default_Modules( *alibrary );
+
+    ft_set_default_properties( *alibrary );
+
+    return error;
+  }
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_Done_FreeType( FT_Library  library )
+  {
+    FT_Memory  memory;
+
+
+    if ( !library )
+      return FT_THROW( Invalid_Library_Handle );
+
+    memory = library->memory;
+
+    /* Discard the library object */
+    FT_Done_Library( library );
+
+    /* discard memory manager */
+    FT_Done_Memory( memory );
+
+    return FT_Err_Ok;
+  }
+
+
+/* END */
diff -ruN freetype-2.7-orig/src/base/ftlcdfil.c freetype-2.7/src/base/ftlcdfil.c
--- freetype-2.7-orig/src/base/ftlcdfil.c	2016-02-03 19:13:58.000000000 +0100
+++ freetype-2.7/src/base/ftlcdfil.c	2016-09-09 16:01:22.465167416 +0200
@@ -22,7 +22,10 @@
 #include FT_LCD_FILTER_H
 #include FT_IMAGE_H
 #include FT_INTERNAL_OBJECTS_H
-
+#include <math.h>
+#include <string.h>
+#include <strings.h>
+#include "ftinf.h"
 
 #ifdef FT_CONFIG_OPTION_SUBPIXEL_RENDERING
 
@@ -307,11 +310,36 @@
   FT_Library_SetLcdFilter( FT_Library    library,
                            FT_LcdFilter  filter )
   {
-    static const FT_Byte  default_filter[5] =
-                            { 0x08, 0x4d, 0x56, 0x4d, 0x08 };
     static const FT_Byte  light_filter[5] =
                             { 0x00, 0x55, 0x56, 0x55, 0x00 };
-
+#ifndef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    static const FT_Byte  default_filter[5] =
+                            { 0x08, 0x4d, 0x56, 0x4d, 0x08 };
+#else
+    FT_Byte default_filter[5];
+    if( ftinf && ftinf->filter_params[0] )
+    {
+        const int *f=ftinf->filter_params;
+        /* Assume we were given integers [0-100] get them to [0-255] */
+        int val; /* 2611=2.55*1024 */
+        val=(f[1]*2611+512)>>10; if( val > 255 ) val=255;
+        default_filter[0] = (FT_Byte) val;
+        val=(f[2]*2611+512)>>10; if( val > 255 ) val=255;
+        default_filter[1] = (FT_Byte) val;
+        val=(f[3]*2611+512)>>10; if( val > 255 ) val=255;
+        default_filter[2] = (FT_Byte) val;
+        val=(f[4]*2611+512)>>10; if( val > 255 ) val=255;
+        default_filter[3] = (FT_Byte) val;
+        val=(f[5]*2611+512)>>10; if( val > 255 ) val=255;
+        default_filter[4] = (FT_Byte) val;
+    } else {
+        default_filter[0]=0x08;
+        default_filter[1]=0x4d;
+        default_filter[2]=0x56;
+        default_filter[3]=0x4d;
+        default_filter[4]=0x08;
+    }
+#endif
 
     if ( !library )
       return FT_THROW( Invalid_Library_Handle );
diff -ruN freetype-2.7-orig/src/base/ftobjs.c freetype-2.7/src/base/ftobjs.c
--- freetype-2.7-orig/src/base/ftobjs.c	2016-09-04 11:42:16.000000000 +0200
+++ freetype-2.7/src/base/ftobjs.c	2016-09-09 16:01:22.465167416 +0200
@@ -40,7 +40,9 @@
 #ifdef FT_CONFIG_OPTION_MAC_FONTS
 #include "ftbase.h"
 #endif
-
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+#include "ftinf.h"
+#endif
 
 #ifdef FT_DEBUG_LEVEL_TRACE
 
@@ -78,6 +80,11 @@
 
 #define GRID_FIT_METRICS
 
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+#include <strings.h>
+#include <stdlib.h>
+#include "../autofit/aflatin.h"
+#endif
 
   FT_BASE_DEF( FT_Pointer )
   ft_service_list_lookup( FT_ServiceDesc  service_descriptors,
@@ -554,6 +561,25 @@
   ft_lookup_glyph_renderer( FT_GlyphSlot  slot );
 
 
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+  static void
+  ft_glyphslot_enlarge_metrics( FT_GlyphSlot slot,
+                                FT_Render_Mode mode )
+  {
+    FT_Glyph_Metrics*  metrics = &slot->metrics;
+    FT_Pos enlarge_cbox = 0;
+
+
+    /* enlarge for grayscale rendering */
+    if ( mode == FT_RENDER_MODE_NORMAL )
+      enlarge_cbox = 64;
+
+    metrics->horiBearingX -= enlarge_cbox;
+    metrics->width += 2 * enlarge_cbox;
+  }
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
+
+
 #ifdef GRID_FIT_METRICS
   static void
   ft_glyphslot_grid_fit_metrics( FT_GlyphSlot  slot,
@@ -612,8 +638,18 @@
     FT_Bool       autohint = FALSE;
     FT_Module     hinter;
     TT_Face       ttface = (TT_Face)face;
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
 
+    FT_Bool use_various_tweaks = FALSE;
+    if( ftinf ) use_various_tweaks=ftinf->use_various_tweaks;
 
+    /* Force autohint if no tt instructions */
+    /* NOTE:  NEEDS TO BE RUN LATER IN CODE???? */
+    /*if ( use_various_tweaks                             &&
+         ttface->num_locations                          &&
+         ttface->max_profile.maxSizeOfInstructions == 0 )
+      load_flags |= FT_LOAD_FORCE_AUTOHINT;*/
+#endif
     if ( !face || !face->size || !face->glyph )
       return FT_THROW( Invalid_Face_Handle );
 
@@ -701,6 +737,18 @@
     {
       FT_AutoHinter_Interface  hinting;
 
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+      if ( use_various_tweaks )
+      {
+        /* Force slight hinting over full hinting always */
+        load_flags &= ~FT_LOAD_TARGET_LCD;
+        load_flags &= ~FT_LOAD_TARGET_LCD_V;
+        load_flags &= ~FT_LOAD_TARGET_MONO;
+        load_flags &= ~FT_LOAD_TARGET_NORMAL;
+        load_flags |= FT_LOAD_TARGET_LIGHT;
+        /*printf("%d ", load_flags);*/
+      }
+#endif
 
       /* try to load embedded bitmaps first if available            */
       /*                                                            */
@@ -746,6 +794,18 @@
       if ( error )
         goto Exit;
 
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+      infinality_cur_width = 0;
+
+      {
+        /* fix for sdl_ttf */
+        FT_Render_Mode  mode = FT_LOAD_TARGET_MODE( load_flags );
+
+        if ( slot->format == FT_GLYPH_FORMAT_OUTLINE )
+          ft_glyphslot_enlarge_metrics( slot, mode );
+      }
+#endif
+
       if ( slot->format == FT_GLYPH_FORMAT_OUTLINE )
       {
         /* check that the loaded outline is correct */
@@ -4785,6 +4845,11 @@
     /* That's ok now */
     *alibrary = library;
 
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    /* get Infinality settings */
+    ftinf_env();
+#endif
+
     return FT_Err_Ok;
 
 #ifdef FT_CONFIG_OPTION_PIC
diff -ruN freetype-2.7-orig/src/base/ftobjs.c.orig freetype-2.7/src/base/ftobjs.c.orig
--- freetype-2.7-orig/src/base/ftobjs.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ freetype-2.7/src/base/ftobjs.c.orig	2016-09-04 11:42:16.000000000 +0200
@@ -0,0 +1,5017 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftobjs.c                                                               */
+/*                                                                         */
+/*    The FreeType private base classes (body).                            */
+/*                                                                         */
+/*  Copyright 1996-2016 by                                                 */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#include <ft2build.h>
+#include FT_LIST_H
+#include FT_OUTLINE_H
+#include FT_INTERNAL_VALIDATE_H
+#include FT_INTERNAL_OBJECTS_H
+#include FT_INTERNAL_DEBUG_H
+#include FT_INTERNAL_RFORK_H
+#include FT_INTERNAL_STREAM_H
+#include FT_INTERNAL_SFNT_H    /* for SFNT_Load_Table_Func */
+#include FT_TRUETYPE_TABLES_H
+#include FT_TRUETYPE_TAGS_H
+#include FT_TRUETYPE_IDS_H
+
+#include FT_SERVICE_PROPERTIES_H
+#include FT_SERVICE_SFNT_H
+#include FT_SERVICE_POSTSCRIPT_NAME_H
+#include FT_SERVICE_GLYPH_DICT_H
+#include FT_SERVICE_TT_CMAP_H
+#include FT_SERVICE_KERNING_H
+#include FT_SERVICE_TRUETYPE_ENGINE_H
+
+#ifdef FT_CONFIG_OPTION_MAC_FONTS
+#include "ftbase.h"
+#endif
+
+
+#ifdef FT_DEBUG_LEVEL_TRACE
+
+#include FT_BITMAP_H
+
+#if defined( _MSC_VER )      /* Visual C++ (and Intel C++)   */
+  /* We disable the warning `conversion from XXX to YYY,     */
+  /* possible loss of data' in order to compile cleanly with */
+  /* the maximum level of warnings: `md5.c' is non-FreeType  */
+  /* code, and it gets used during development builds only.  */
+#pragma warning( push )
+#pragma warning( disable : 4244 )
+#endif /* _MSC_VER */
+
+  /* It's easiest to include `md5.c' directly.  However, since OpenSSL */
+  /* also provides the same functions, there might be conflicts if     */
+  /* both FreeType and OpenSSL are built as static libraries.  For     */
+  /* this reason, we put the MD5 stuff into the `FT_' namespace.       */
+#define MD5_u32plus  FT_MD5_u32plus
+#define MD5_CTX      FT_MD5_CTX
+#define MD5_Init     FT_MD5_Init
+#define MD5_Update   FT_MD5_Update
+#define MD5_Final    FT_MD5_Final
+
+#undef  HAVE_OPENSSL
+
+#include "md5.c"
+
+#if defined( _MSC_VER )
+#pragma warning( pop )
+#endif
+
+#endif /* FT_DEBUG_LEVEL_TRACE */
+
+
+#define GRID_FIT_METRICS
+
+
+  FT_BASE_DEF( FT_Pointer )
+  ft_service_list_lookup( FT_ServiceDesc  service_descriptors,
+                          const char*     service_id )
+  {
+    FT_Pointer      result = NULL;
+    FT_ServiceDesc  desc   = service_descriptors;
+
+
+    if ( desc && service_id )
+    {
+      for ( ; desc->serv_id != NULL; desc++ )
+      {
+        if ( ft_strcmp( desc->serv_id, service_id ) == 0 )
+        {
+          result = (FT_Pointer)desc->serv_data;
+          break;
+        }
+      }
+    }
+
+    return result;
+  }
+
+
+  FT_BASE_DEF( void )
+  ft_validator_init( FT_Validator        valid,
+                     const FT_Byte*      base,
+                     const FT_Byte*      limit,
+                     FT_ValidationLevel  level )
+  {
+    valid->base  = base;
+    valid->limit = limit;
+    valid->level = level;
+    valid->error = FT_Err_Ok;
+  }
+
+
+  FT_BASE_DEF( FT_Int )
+  ft_validator_run( FT_Validator  valid )
+  {
+    /* This function doesn't work!  None should call it. */
+    FT_UNUSED( valid );
+
+    return -1;
+  }
+
+
+  FT_BASE_DEF( void )
+  ft_validator_error( FT_Validator  valid,
+                      FT_Error      error )
+  {
+    /* since the cast below also disables the compiler's */
+    /* type check, we introduce a dummy variable, which  */
+    /* will be optimized away                            */
+    volatile ft_jmp_buf* jump_buffer = &valid->jump_buffer;
+
+
+    valid->error = error;
+
+    /* throw away volatileness; use `jump_buffer' or the  */
+    /* compiler may warn about an unused local variable   */
+    ft_longjmp( *(ft_jmp_buf*) jump_buffer, 1 );
+  }
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****                                                                 ****/
+  /****                           S T R E A M                           ****/
+  /****                                                                 ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /* create a new input stream from an FT_Open_Args structure */
+  /*                                                          */
+  FT_BASE_DEF( FT_Error )
+  FT_Stream_New( FT_Library           library,
+                 const FT_Open_Args*  args,
+                 FT_Stream           *astream )
+  {
+    FT_Error   error;
+    FT_Memory  memory;
+    FT_Stream  stream = NULL;
+
+
+    *astream = NULL;
+
+    if ( !library )
+      return FT_THROW( Invalid_Library_Handle );
+
+    if ( !args )
+      return FT_THROW( Invalid_Argument );
+
+    memory = library->memory;
+
+    if ( FT_NEW( stream ) )
+      goto Exit;
+
+    stream->memory = memory;
+
+    if ( args->flags & FT_OPEN_MEMORY )
+    {
+      /* create a memory-based stream */
+      FT_Stream_OpenMemory( stream,
+                            (const FT_Byte*)args->memory_base,
+                            (FT_ULong)args->memory_size );
+    }
+
+#ifndef FT_CONFIG_OPTION_DISABLE_STREAM_SUPPORT
+
+    else if ( args->flags & FT_OPEN_PATHNAME )
+    {
+      /* create a normal system stream */
+      error = FT_Stream_Open( stream, args->pathname );
+      stream->pathname.pointer = args->pathname;
+    }
+    else if ( ( args->flags & FT_OPEN_STREAM ) && args->stream )
+    {
+      /* use an existing, user-provided stream */
+
+      /* in this case, we do not need to allocate a new stream object */
+      /* since the caller is responsible for closing it himself       */
+      FT_FREE( stream );
+      stream = args->stream;
+    }
+
+#endif
+
+    else
+      error = FT_THROW( Invalid_Argument );
+
+    if ( error )
+      FT_FREE( stream );
+    else
+      stream->memory = memory;  /* just to be certain */
+
+    *astream = stream;
+
+  Exit:
+    return error;
+  }
+
+
+  FT_BASE_DEF( void )
+  FT_Stream_Free( FT_Stream  stream,
+                  FT_Int     external )
+  {
+    if ( stream )
+    {
+      FT_Memory  memory = stream->memory;
+
+
+      FT_Stream_Close( stream );
+
+      if ( !external )
+        FT_FREE( stream );
+    }
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
+  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
+  /* messages during execution.                                            */
+  /*                                                                       */
+#undef  FT_COMPONENT
+#define FT_COMPONENT  trace_objs
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****                                                                 ****/
+  /****               FACE, SIZE & GLYPH SLOT OBJECTS                   ****/
+  /****                                                                 ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  static FT_Error
+  ft_glyphslot_init( FT_GlyphSlot  slot )
+  {
+    FT_Driver         driver   = slot->face->driver;
+    FT_Driver_Class   clazz    = driver->clazz;
+    FT_Memory         memory   = driver->root.memory;
+    FT_Error          error    = FT_Err_Ok;
+    FT_Slot_Internal  internal = NULL;
+
+
+    slot->library = driver->root.library;
+
+    if ( FT_NEW( internal ) )
+      goto Exit;
+
+    slot->internal = internal;
+
+    if ( FT_DRIVER_USES_OUTLINES( driver ) )
+      error = FT_GlyphLoader_New( memory, &internal->loader );
+
+    if ( !error && clazz->init_slot )
+      error = clazz->init_slot( slot );
+
+  Exit:
+    return error;
+  }
+
+
+  FT_BASE_DEF( void )
+  ft_glyphslot_free_bitmap( FT_GlyphSlot  slot )
+  {
+    if ( slot->internal && ( slot->internal->flags & FT_GLYPH_OWN_BITMAP ) )
+    {
+      FT_Memory  memory = FT_FACE_MEMORY( slot->face );
+
+
+      FT_FREE( slot->bitmap.buffer );
+      slot->internal->flags &= ~FT_GLYPH_OWN_BITMAP;
+    }
+    else
+    {
+      /* assume that the bitmap buffer was stolen or not */
+      /* allocated from the heap                         */
+      slot->bitmap.buffer = NULL;
+    }
+  }
+
+
+  FT_BASE_DEF( void )
+  ft_glyphslot_set_bitmap( FT_GlyphSlot  slot,
+                           FT_Byte*      buffer )
+  {
+    ft_glyphslot_free_bitmap( slot );
+
+    slot->bitmap.buffer = buffer;
+
+    FT_ASSERT( (slot->internal->flags & FT_GLYPH_OWN_BITMAP) == 0 );
+  }
+
+
+  FT_BASE_DEF( FT_Error )
+  ft_glyphslot_alloc_bitmap( FT_GlyphSlot  slot,
+                             FT_ULong      size )
+  {
+    FT_Memory  memory = FT_FACE_MEMORY( slot->face );
+    FT_Error   error;
+
+
+    if ( slot->internal->flags & FT_GLYPH_OWN_BITMAP )
+      FT_FREE( slot->bitmap.buffer );
+    else
+      slot->internal->flags |= FT_GLYPH_OWN_BITMAP;
+
+    (void)FT_ALLOC( slot->bitmap.buffer, size );
+    return error;
+  }
+
+
+  static void
+  ft_glyphslot_clear( FT_GlyphSlot  slot )
+  {
+    /* free bitmap if needed */
+    ft_glyphslot_free_bitmap( slot );
+
+    /* clear all public fields in the glyph slot */
+    FT_ZERO( &slot->metrics );
+    FT_ZERO( &slot->outline );
+
+    slot->bitmap.width      = 0;
+    slot->bitmap.rows       = 0;
+    slot->bitmap.pitch      = 0;
+    slot->bitmap.pixel_mode = 0;
+    /* `slot->bitmap.buffer' has been handled by ft_glyphslot_free_bitmap */
+
+    slot->bitmap_left   = 0;
+    slot->bitmap_top    = 0;
+    slot->num_subglyphs = 0;
+    slot->subglyphs     = NULL;
+    slot->control_data  = NULL;
+    slot->control_len   = 0;
+    slot->other         = NULL;
+    slot->format        = FT_GLYPH_FORMAT_NONE;
+
+    slot->linearHoriAdvance = 0;
+    slot->linearVertAdvance = 0;
+    slot->lsb_delta         = 0;
+    slot->rsb_delta         = 0;
+  }
+
+
+  static void
+  ft_glyphslot_done( FT_GlyphSlot  slot )
+  {
+    FT_Driver        driver = slot->face->driver;
+    FT_Driver_Class  clazz  = driver->clazz;
+    FT_Memory        memory = driver->root.memory;
+
+
+    if ( clazz->done_slot )
+      clazz->done_slot( slot );
+
+    /* free bitmap buffer if needed */
+    ft_glyphslot_free_bitmap( slot );
+
+    /* slot->internal might be NULL in out-of-memory situations */
+    if ( slot->internal )
+    {
+      /* free glyph loader */
+      if ( FT_DRIVER_USES_OUTLINES( driver ) )
+      {
+        FT_GlyphLoader_Done( slot->internal->loader );
+        slot->internal->loader = NULL;
+      }
+
+      FT_FREE( slot->internal );
+    }
+  }
+
+
+  /* documentation is in ftobjs.h */
+
+  FT_BASE_DEF( FT_Error )
+  FT_New_GlyphSlot( FT_Face        face,
+                    FT_GlyphSlot  *aslot )
+  {
+    FT_Error         error;
+    FT_Driver        driver;
+    FT_Driver_Class  clazz;
+    FT_Memory        memory;
+    FT_GlyphSlot     slot = NULL;
+
+
+    if ( !face )
+      return FT_THROW( Invalid_Face_Handle );
+
+    if ( !face->driver )
+      return FT_THROW( Invalid_Argument );
+
+    driver = face->driver;
+    clazz  = driver->clazz;
+    memory = driver->root.memory;
+
+    FT_TRACE4(( "FT_New_GlyphSlot: Creating new slot object\n" ));
+    if ( !FT_ALLOC( slot, clazz->slot_object_size ) )
+    {
+      slot->face = face;
+
+      error = ft_glyphslot_init( slot );
+      if ( error )
+      {
+        ft_glyphslot_done( slot );
+        FT_FREE( slot );
+        goto Exit;
+      }
+
+      slot->next  = face->glyph;
+      face->glyph = slot;
+
+      if ( aslot )
+        *aslot = slot;
+    }
+    else if ( aslot )
+      *aslot = NULL;
+
+
+  Exit:
+    FT_TRACE4(( "FT_New_GlyphSlot: Return %d\n", error ));
+    return error;
+  }
+
+
+  /* documentation is in ftobjs.h */
+
+  FT_BASE_DEF( void )
+  FT_Done_GlyphSlot( FT_GlyphSlot  slot )
+  {
+    if ( slot )
+    {
+      FT_Driver     driver = slot->face->driver;
+      FT_Memory     memory = driver->root.memory;
+      FT_GlyphSlot  prev;
+      FT_GlyphSlot  cur;
+
+
+      /* Remove slot from its parent face's list */
+      prev = NULL;
+      cur  = slot->face->glyph;
+
+      while ( cur )
+      {
+        if ( cur == slot )
+        {
+          if ( !prev )
+            slot->face->glyph = cur->next;
+          else
+            prev->next = cur->next;
+
+          /* finalize client-specific data */
+          if ( slot->generic.finalizer )
+            slot->generic.finalizer( slot );
+
+          ft_glyphslot_done( slot );
+          FT_FREE( slot );
+          break;
+        }
+        prev = cur;
+        cur  = cur->next;
+      }
+    }
+  }
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( void )
+  FT_Set_Transform( FT_Face     face,
+                    FT_Matrix*  matrix,
+                    FT_Vector*  delta )
+  {
+    FT_Face_Internal  internal;
+
+
+    if ( !face )
+      return;
+
+    internal = face->internal;
+
+    internal->transform_flags = 0;
+
+    if ( !matrix )
+    {
+      internal->transform_matrix.xx = 0x10000L;
+      internal->transform_matrix.xy = 0;
+      internal->transform_matrix.yx = 0;
+      internal->transform_matrix.yy = 0x10000L;
+
+      matrix = &internal->transform_matrix;
+    }
+    else
+      internal->transform_matrix = *matrix;
+
+    /* set transform_flags bit flag 0 if `matrix' isn't the identity */
+    if ( ( matrix->xy | matrix->yx ) ||
+         matrix->xx != 0x10000L      ||
+         matrix->yy != 0x10000L      )
+      internal->transform_flags |= 1;
+
+    if ( !delta )
+    {
+      internal->transform_delta.x = 0;
+      internal->transform_delta.y = 0;
+
+      delta = &internal->transform_delta;
+    }
+    else
+      internal->transform_delta = *delta;
+
+    /* set transform_flags bit flag 1 if `delta' isn't the null vector */
+    if ( delta->x | delta->y )
+      internal->transform_flags |= 2;
+  }
+
+
+  static FT_Renderer
+  ft_lookup_glyph_renderer( FT_GlyphSlot  slot );
+
+
+#ifdef GRID_FIT_METRICS
+  static void
+  ft_glyphslot_grid_fit_metrics( FT_GlyphSlot  slot,
+                                 FT_Bool       vertical )
+  {
+    FT_Glyph_Metrics*  metrics = &slot->metrics;
+    FT_Pos             right, bottom;
+
+
+    if ( vertical )
+    {
+      metrics->horiBearingX = FT_PIX_FLOOR( metrics->horiBearingX );
+      metrics->horiBearingY = FT_PIX_CEIL ( metrics->horiBearingY );
+
+      right  = FT_PIX_CEIL( metrics->vertBearingX + metrics->width );
+      bottom = FT_PIX_CEIL( metrics->vertBearingY + metrics->height );
+
+      metrics->vertBearingX = FT_PIX_FLOOR( metrics->vertBearingX );
+      metrics->vertBearingY = FT_PIX_FLOOR( metrics->vertBearingY );
+
+      metrics->width  = right - metrics->vertBearingX;
+      metrics->height = bottom - metrics->vertBearingY;
+    }
+    else
+    {
+      metrics->vertBearingX = FT_PIX_FLOOR( metrics->vertBearingX );
+      metrics->vertBearingY = FT_PIX_FLOOR( metrics->vertBearingY );
+
+      right  = FT_PIX_CEIL ( metrics->horiBearingX + metrics->width );
+      bottom = FT_PIX_FLOOR( metrics->horiBearingY - metrics->height );
+
+      metrics->horiBearingX = FT_PIX_FLOOR( metrics->horiBearingX );
+      metrics->horiBearingY = FT_PIX_CEIL ( metrics->horiBearingY );
+
+      metrics->width  = right - metrics->horiBearingX;
+      metrics->height = metrics->horiBearingY - bottom;
+    }
+
+    metrics->horiAdvance = FT_PIX_ROUND( metrics->horiAdvance );
+    metrics->vertAdvance = FT_PIX_ROUND( metrics->vertAdvance );
+  }
+#endif /* GRID_FIT_METRICS */
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_Load_Glyph( FT_Face   face,
+                 FT_UInt   glyph_index,
+                 FT_Int32  load_flags )
+  {
+    FT_Error      error;
+    FT_Driver     driver;
+    FT_GlyphSlot  slot;
+    FT_Library    library;
+    FT_Bool       autohint = FALSE;
+    FT_Module     hinter;
+    TT_Face       ttface = (TT_Face)face;
+
+
+    if ( !face || !face->size || !face->glyph )
+      return FT_THROW( Invalid_Face_Handle );
+
+    /* The validity test for `glyph_index' is performed by the */
+    /* font drivers.                                           */
+
+    slot = face->glyph;
+    ft_glyphslot_clear( slot );
+
+    driver  = face->driver;
+    library = driver->root.library;
+    hinter  = library->auto_hinter;
+
+    /* resolve load flags dependencies */
+
+    if ( load_flags & FT_LOAD_NO_RECURSE )
+      load_flags |= FT_LOAD_NO_SCALE         |
+                    FT_LOAD_IGNORE_TRANSFORM;
+
+    if ( load_flags & FT_LOAD_NO_SCALE )
+    {
+      load_flags |= FT_LOAD_NO_HINTING |
+                    FT_LOAD_NO_BITMAP;
+
+      load_flags &= ~FT_LOAD_RENDER;
+    }
+
+    /*
+     * Determine whether we need to auto-hint or not.
+     * The general rules are:
+     *
+     * - Do only auto-hinting if we have a hinter module, a scalable font
+     *   format dealing with outlines, and no transforms except simple
+     *   slants and/or rotations by integer multiples of 90 degrees.
+     *
+     * - Then, auto-hint if FT_LOAD_FORCE_AUTOHINT is set or if we don't
+     *   have a native font hinter.
+     *
+     * - Otherwise, auto-hint for LIGHT hinting mode or if there isn't
+     *   any hinting bytecode in the TrueType/OpenType font.
+     *
+     * - Exception: The font is `tricky' and requires the native hinter to
+     *   load properly.
+     */
+
+    if ( hinter                                           &&
+         !( load_flags & FT_LOAD_NO_HINTING )             &&
+         !( load_flags & FT_LOAD_NO_AUTOHINT )            &&
+         FT_DRIVER_IS_SCALABLE( driver )                  &&
+         FT_DRIVER_USES_OUTLINES( driver )                &&
+         !FT_IS_TRICKY( face )                            &&
+         ( ( load_flags & FT_LOAD_IGNORE_TRANSFORM )    ||
+           ( face->internal->transform_matrix.yx == 0 &&
+             face->internal->transform_matrix.xx != 0 ) ||
+           ( face->internal->transform_matrix.xx == 0 &&
+             face->internal->transform_matrix.yx != 0 ) ) )
+    {
+      if ( ( load_flags & FT_LOAD_FORCE_AUTOHINT ) ||
+           !FT_DRIVER_HAS_HINTER( driver )         )
+        autohint = TRUE;
+      else
+      {
+        FT_Render_Mode  mode = FT_LOAD_TARGET_MODE( load_flags );
+
+
+        /* the check for `num_locations' assures that we actually    */
+        /* test for instructions in a TTF and not in a CFF-based OTF */
+        /*                                                           */
+        /* since `maxSizeOfInstructions' might be unreliable, we     */
+        /* check the size of the `fpgm' and `prep' tables, too --    */
+        /* the assumption is that there don't exist real TTFs where  */
+        /* both `fpgm' and `prep' tables are missing                 */
+        if ( ( mode == FT_RENDER_MODE_LIGHT                   &&
+               !FT_DRIVER_HINTS_LIGHTLY( driver ) )             ||
+             ( FT_IS_SFNT( face )                             &&
+               ttface->num_locations                          &&
+               ttface->max_profile.maxSizeOfInstructions == 0 &&
+               ttface->font_program_size == 0                 &&
+               ttface->cvt_program_size == 0                  ) )
+          autohint = TRUE;
+      }
+    }
+
+    if ( autohint )
+    {
+      FT_AutoHinter_Interface  hinting;
+
+
+      /* try to load embedded bitmaps first if available            */
+      /*                                                            */
+      /* XXX: This is really a temporary hack that should disappear */
+      /*      promptly with FreeType 2.1!                           */
+      /*                                                            */
+      if ( FT_HAS_FIXED_SIZES( face )             &&
+          ( load_flags & FT_LOAD_NO_BITMAP ) == 0 )
+      {
+        error = driver->clazz->load_glyph( slot, face->size,
+                                           glyph_index,
+                                           load_flags | FT_LOAD_SBITS_ONLY );
+
+        if ( !error && slot->format == FT_GLYPH_FORMAT_BITMAP )
+          goto Load_Ok;
+      }
+
+      {
+        FT_Face_Internal  internal        = face->internal;
+        FT_Int            transform_flags = internal->transform_flags;
+
+
+        /* since the auto-hinter calls FT_Load_Glyph by itself, */
+        /* make sure that glyphs aren't transformed             */
+        internal->transform_flags = 0;
+
+        /* load auto-hinted outline */
+        hinting = (FT_AutoHinter_Interface)hinter->clazz->module_interface;
+
+        error   = hinting->load_glyph( (FT_AutoHinter)hinter,
+                                       slot, face->size,
+                                       glyph_index, load_flags );
+
+        internal->transform_flags = transform_flags;
+      }
+    }
+    else
+    {
+      error = driver->clazz->load_glyph( slot,
+                                         face->size,
+                                         glyph_index,
+                                         load_flags );
+      if ( error )
+        goto Exit;
+
+      if ( slot->format == FT_GLYPH_FORMAT_OUTLINE )
+      {
+        /* check that the loaded outline is correct */
+        error = FT_Outline_Check( &slot->outline );
+        if ( error )
+          goto Exit;
+
+#ifdef GRID_FIT_METRICS
+        if ( !( load_flags & FT_LOAD_NO_HINTING ) )
+          ft_glyphslot_grid_fit_metrics( slot,
+              FT_BOOL( load_flags & FT_LOAD_VERTICAL_LAYOUT ) );
+#endif
+      }
+    }
+
+  Load_Ok:
+    /* compute the advance */
+    if ( load_flags & FT_LOAD_VERTICAL_LAYOUT )
+    {
+      slot->advance.x = 0;
+      slot->advance.y = slot->metrics.vertAdvance;
+    }
+    else
+    {
+      slot->advance.x = slot->metrics.horiAdvance;
+      slot->advance.y = 0;
+    }
+
+    /* compute the linear advance in 16.16 pixels */
+    if ( ( load_flags & FT_LOAD_LINEAR_DESIGN ) == 0 &&
+         ( FT_IS_SCALABLE( face ) )                  )
+    {
+      FT_Size_Metrics*  metrics = &face->size->metrics;
+
+
+      /* it's tricky! */
+      slot->linearHoriAdvance = FT_MulDiv( slot->linearHoriAdvance,
+                                           metrics->x_scale, 64 );
+
+      slot->linearVertAdvance = FT_MulDiv( slot->linearVertAdvance,
+                                           metrics->y_scale, 64 );
+    }
+
+    if ( ( load_flags & FT_LOAD_IGNORE_TRANSFORM ) == 0 )
+    {
+      FT_Face_Internal  internal = face->internal;
+
+
+      /* now, transform the glyph image if needed */
+      if ( internal->transform_flags )
+      {
+        /* get renderer */
+        FT_Renderer  renderer = ft_lookup_glyph_renderer( slot );
+
+
+        if ( renderer )
+          error = renderer->clazz->transform_glyph(
+                                     renderer, slot,
+                                     &internal->transform_matrix,
+                                     &internal->transform_delta );
+        else if ( slot->format == FT_GLYPH_FORMAT_OUTLINE )
+        {
+          /* apply `standard' transformation if no renderer is available */
+          if ( internal->transform_flags & 1 )
+            FT_Outline_Transform( &slot->outline,
+                                  &internal->transform_matrix );
+
+          if ( internal->transform_flags & 2 )
+            FT_Outline_Translate( &slot->outline,
+                                  internal->transform_delta.x,
+                                  internal->transform_delta.y );
+        }
+
+        /* transform advance */
+        FT_Vector_Transform( &slot->advance, &internal->transform_matrix );
+      }
+    }
+
+    FT_TRACE5(( "  x advance: %d\n" , slot->advance.x ));
+    FT_TRACE5(( "  y advance: %d\n" , slot->advance.y ));
+
+    FT_TRACE5(( "  linear x advance: %d\n" , slot->linearHoriAdvance ));
+    FT_TRACE5(( "  linear y advance: %d\n" , slot->linearVertAdvance ));
+
+    /* do we need to render the image now? */
+    if ( !error                                    &&
+         slot->format != FT_GLYPH_FORMAT_BITMAP    &&
+         slot->format != FT_GLYPH_FORMAT_COMPOSITE &&
+         load_flags & FT_LOAD_RENDER )
+    {
+      FT_Render_Mode  mode = FT_LOAD_TARGET_MODE( load_flags );
+
+
+      if ( mode == FT_RENDER_MODE_NORMAL      &&
+           (load_flags & FT_LOAD_MONOCHROME ) )
+        mode = FT_RENDER_MODE_MONO;
+
+      error = FT_Render_Glyph( slot, mode );
+    }
+
+  Exit:
+    return error;
+  }
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_Load_Char( FT_Face   face,
+                FT_ULong  char_code,
+                FT_Int32  load_flags )
+  {
+    FT_UInt  glyph_index;
+
+
+    if ( !face )
+      return FT_THROW( Invalid_Face_Handle );
+
+    glyph_index = (FT_UInt)char_code;
+    if ( face->charmap )
+      glyph_index = FT_Get_Char_Index( face, char_code );
+
+    return FT_Load_Glyph( face, glyph_index, load_flags );
+  }
+
+
+  /* destructor for sizes list */
+  static void
+  destroy_size( FT_Memory  memory,
+                FT_Size    size,
+                FT_Driver  driver )
+  {
+    /* finalize client-specific data */
+    if ( size->generic.finalizer )
+      size->generic.finalizer( size );
+
+    /* finalize format-specific stuff */
+    if ( driver->clazz->done_size )
+      driver->clazz->done_size( size );
+
+    FT_FREE( size->internal );
+    FT_FREE( size );
+  }
+
+
+  static void
+  ft_cmap_done_internal( FT_CMap  cmap );
+
+
+  static void
+  destroy_charmaps( FT_Face    face,
+                    FT_Memory  memory )
+  {
+    FT_Int  n;
+
+
+    if ( !face )
+      return;
+
+    for ( n = 0; n < face->num_charmaps; n++ )
+    {
+      FT_CMap  cmap = FT_CMAP( face->charmaps[n] );
+
+
+      ft_cmap_done_internal( cmap );
+
+      face->charmaps[n] = NULL;
+    }
+
+    FT_FREE( face->charmaps );
+    face->num_charmaps = 0;
+  }
+
+
+  /* destructor for faces list */
+  static void
+  destroy_face( FT_Memory  memory,
+                FT_Face    face,
+                FT_Driver  driver )
+  {
+    FT_Driver_Class  clazz = driver->clazz;
+
+
+    /* discard auto-hinting data */
+    if ( face->autohint.finalizer )
+      face->autohint.finalizer( face->autohint.data );
+
+    /* Discard glyph slots for this face.                           */
+    /* Beware!  FT_Done_GlyphSlot() changes the field `face->glyph' */
+    while ( face->glyph )
+      FT_Done_GlyphSlot( face->glyph );
+
+    /* discard all sizes for this face */
+    FT_List_Finalize( &face->sizes_list,
+                      (FT_List_Destructor)destroy_size,
+                      memory,
+                      driver );
+    face->size = NULL;
+
+    /* now discard client data */
+    if ( face->generic.finalizer )
+      face->generic.finalizer( face );
+
+    /* discard charmaps */
+    destroy_charmaps( face, memory );
+
+    /* finalize format-specific stuff */
+    if ( clazz->done_face )
+      clazz->done_face( face );
+
+    /* close the stream for this face if needed */
+    FT_Stream_Free(
+      face->stream,
+      ( face->face_flags & FT_FACE_FLAG_EXTERNAL_STREAM ) != 0 );
+
+    face->stream = NULL;
+
+    /* get rid of it */
+    if ( face->internal )
+    {
+      FT_FREE( face->internal );
+    }
+    FT_FREE( face );
+  }
+
+
+  static void
+  Destroy_Driver( FT_Driver  driver )
+  {
+    FT_List_Finalize( &driver->faces_list,
+                      (FT_List_Destructor)destroy_face,
+                      driver->root.memory,
+                      driver );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    find_unicode_charmap                                               */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This function finds a Unicode charmap, if there is one.            */
+  /*    And if there is more than one, it tries to favour the more         */
+  /*    extensive one, i.e., one that supports UCS-4 against those which   */
+  /*    are limited to the BMP (said UCS-2 encoding.)                      */
+  /*                                                                       */
+  /*    This function is called from open_face() (just below), and also    */
+  /*    from FT_Select_Charmap( ..., FT_ENCODING_UNICODE ).                */
+  /*                                                                       */
+  static FT_Error
+  find_unicode_charmap( FT_Face  face )
+  {
+    FT_CharMap*  first;
+    FT_CharMap*  cur;
+
+
+    /* caller should have already checked that `face' is valid */
+    FT_ASSERT( face );
+
+    first = face->charmaps;
+
+    if ( !first )
+      return FT_THROW( Invalid_CharMap_Handle );
+
+    /*
+     *  The original TrueType specification(s) only specified charmap
+     *  formats that are capable of mapping 8 or 16 bit character codes to
+     *  glyph indices.
+     *
+     *  However, recent updates to the Apple and OpenType specifications
+     *  introduced new formats that are capable of mapping 32-bit character
+     *  codes as well.  And these are already used on some fonts, mainly to
+     *  map non-BMP Asian ideographs as defined in Unicode.
+     *
+     *  For compatibility purposes, these fonts generally come with
+     *  *several* Unicode charmaps:
+     *
+     *   - One of them in the "old" 16-bit format, that cannot access
+     *     all glyphs in the font.
+     *
+     *   - Another one in the "new" 32-bit format, that can access all
+     *     the glyphs.
+     *
+     *  This function has been written to always favor a 32-bit charmap
+     *  when found.  Otherwise, a 16-bit one is returned when found.
+     */
+
+    /* Since the `interesting' table, with IDs (3,10), is normally the */
+    /* last one, we loop backwards.  This loses with type1 fonts with  */
+    /* non-BMP characters (<.0001%), this wins with .ttf with non-BMP  */
+    /* chars (.01% ?), and this is the same about 99.99% of the time!  */
+
+    cur = first + face->num_charmaps;  /* points after the last one */
+
+    for ( ; --cur >= first; )
+    {
+      if ( cur[0]->encoding == FT_ENCODING_UNICODE )
+      {
+        /* XXX If some new encodings to represent UCS-4 are added, */
+        /*     they should be added here.                          */
+        if ( ( cur[0]->platform_id == TT_PLATFORM_MICROSOFT &&
+               cur[0]->encoding_id == TT_MS_ID_UCS_4        )     ||
+             ( cur[0]->platform_id == TT_PLATFORM_APPLE_UNICODE &&
+               cur[0]->encoding_id == TT_APPLE_ID_UNICODE_32    ) )
+        {
+          face->charmap = cur[0];
+          return FT_Err_Ok;
+        }
+      }
+    }
+
+    /* We do not have any UCS-4 charmap.                */
+    /* Do the loop again and search for UCS-2 charmaps. */
+    cur = first + face->num_charmaps;
+
+    for ( ; --cur >= first; )
+    {
+      if ( cur[0]->encoding == FT_ENCODING_UNICODE )
+      {
+        face->charmap = cur[0];
+        return FT_Err_Ok;
+      }
+    }
+
+    return FT_THROW( Invalid_CharMap_Handle );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    find_variant_selector_charmap                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This function finds the variant selector charmap, if there is one. */
+  /*    There can only be one (platform=0, specific=5, format=14).         */
+  /*                                                                       */
+  static FT_CharMap
+  find_variant_selector_charmap( FT_Face  face )
+  {
+    FT_CharMap*  first;
+    FT_CharMap*  end;
+    FT_CharMap*  cur;
+
+
+    /* caller should have already checked that `face' is valid */
+    FT_ASSERT( face );
+
+    first = face->charmaps;
+
+    if ( !first )
+      return NULL;
+
+    end = first + face->num_charmaps;  /* points after the last one */
+
+    for ( cur = first; cur < end; ++cur )
+    {
+      if ( cur[0]->platform_id == TT_PLATFORM_APPLE_UNICODE    &&
+           cur[0]->encoding_id == TT_APPLE_ID_VARIANT_SELECTOR &&
+           FT_Get_CMap_Format( cur[0] ) == 14                  )
+        return cur[0];
+    }
+
+    return NULL;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    open_face                                                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    This function does some work for FT_Open_Face().                   */
+  /*                                                                       */
+  static FT_Error
+  open_face( FT_Driver      driver,
+             FT_Stream      *astream,
+             FT_Bool        external_stream,
+             FT_Long        face_index,
+             FT_Int         num_params,
+             FT_Parameter*  params,
+             FT_Face       *aface )
+  {
+    FT_Memory         memory;
+    FT_Driver_Class   clazz;
+    FT_Face           face     = NULL;
+    FT_Face_Internal  internal = NULL;
+
+    FT_Error          error, error2;
+
+
+    clazz  = driver->clazz;
+    memory = driver->root.memory;
+
+    /* allocate the face object and perform basic initialization */
+    if ( FT_ALLOC( face, clazz->face_object_size ) )
+      goto Fail;
+
+    face->driver = driver;
+    face->memory = memory;
+    face->stream = *astream;
+
+    /* set the FT_FACE_FLAG_EXTERNAL_STREAM bit for FT_Done_Face */
+    if ( external_stream )
+      face->face_flags |= FT_FACE_FLAG_EXTERNAL_STREAM;
+
+    if ( FT_NEW( internal ) )
+      goto Fail;
+
+    face->internal = internal;
+
+#ifdef FT_CONFIG_OPTION_INCREMENTAL
+    {
+      int  i;
+
+
+      face->internal->incremental_interface = NULL;
+      for ( i = 0; i < num_params && !face->internal->incremental_interface;
+            i++ )
+        if ( params[i].tag == FT_PARAM_TAG_INCREMENTAL )
+          face->internal->incremental_interface =
+            (FT_Incremental_Interface)params[i].data;
+    }
+#endif
+
+    if ( clazz->init_face )
+      error = clazz->init_face( *astream,
+                                face,
+                                (FT_Int)face_index,
+                                num_params,
+                                params );
+    *astream = face->stream; /* Stream may have been changed. */
+    if ( error )
+      goto Fail;
+
+    /* select Unicode charmap by default */
+    error2 = find_unicode_charmap( face );
+
+    /* if no Unicode charmap can be found, FT_Err_Invalid_CharMap_Handle */
+    /* is returned.                                                      */
+
+    /* no error should happen, but we want to play safe */
+    if ( error2 && FT_ERR_NEQ( error2, Invalid_CharMap_Handle ) )
+    {
+      error = error2;
+      goto Fail;
+    }
+
+    *aface = face;
+
+  Fail:
+    if ( error )
+    {
+      destroy_charmaps( face, memory );
+      if ( clazz->done_face )
+        clazz->done_face( face );
+      FT_FREE( internal );
+      FT_FREE( face );
+      *aface = NULL;
+    }
+
+    return error;
+  }
+
+
+  /* there's a Mac-specific extended implementation of FT_New_Face() */
+  /* in src/base/ftmac.c                                             */
+
+#ifndef FT_MACINTOSH
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_New_Face( FT_Library   library,
+               const char*  pathname,
+               FT_Long      face_index,
+               FT_Face     *aface )
+  {
+    FT_Open_Args  args;
+
+
+    /* test for valid `library' and `aface' delayed to `FT_Open_Face' */
+    if ( !pathname )
+      return FT_THROW( Invalid_Argument );
+
+    args.flags    = FT_OPEN_PATHNAME;
+    args.pathname = (char*)pathname;
+    args.stream   = NULL;
+
+    return FT_Open_Face( library, &args, face_index, aface );
+  }
+
+#endif
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_New_Memory_Face( FT_Library      library,
+                      const FT_Byte*  file_base,
+                      FT_Long         file_size,
+                      FT_Long         face_index,
+                      FT_Face        *aface )
+  {
+    FT_Open_Args  args;
+
+
+    /* test for valid `library' and `face' delayed to `FT_Open_Face' */
+    if ( !file_base )
+      return FT_THROW( Invalid_Argument );
+
+    args.flags       = FT_OPEN_MEMORY;
+    args.memory_base = file_base;
+    args.memory_size = file_size;
+    args.stream      = NULL;
+
+    return FT_Open_Face( library, &args, face_index, aface );
+  }
+
+
+#ifdef FT_CONFIG_OPTION_MAC_FONTS
+
+  /* The behavior here is very similar to that in base/ftmac.c, but it     */
+  /* is designed to work on non-mac systems, so no mac specific calls.     */
+  /*                                                                       */
+  /* We look at the file and determine if it is a mac dfont file or a mac  */
+  /* resource file, or a macbinary file containing a mac resource file.    */
+  /*                                                                       */
+  /* Unlike ftmac I'm not going to look at a `FOND'.  I don't really see   */
+  /* the point, especially since there may be multiple `FOND' resources.   */
+  /* Instead I'll just look for `sfnt' and `POST' resources, ordered as    */
+  /* they occur in the file.                                               */
+  /*                                                                       */
+  /* Note that multiple `POST' resources do not mean multiple postscript   */
+  /* fonts; they all get jammed together to make what is essentially a     */
+  /* pfb file.                                                             */
+  /*                                                                       */
+  /* We aren't interested in `NFNT' or `FONT' bitmap resources.            */
+  /*                                                                       */
+  /* As soon as we get an `sfnt' load it into memory and pass it off to    */
+  /* FT_Open_Face.                                                         */
+  /*                                                                       */
+  /* If we have a (set of) `POST' resources, massage them into a (memory)  */
+  /* pfb file and pass that to FT_Open_Face.  (As with ftmac.c I'm not     */
+  /* going to try to save the kerning info.  After all that lives in the   */
+  /* `FOND' which isn't in the file containing the `POST' resources so     */
+  /* we don't really have access to it.                                    */
+
+
+  /* Finalizer for a memory stream; gets called by FT_Done_Face(). */
+  /* It frees the memory it uses.                                  */
+  /* From ftmac.c.                                                 */
+  static void
+  memory_stream_close( FT_Stream  stream )
+  {
+    FT_Memory  memory = stream->memory;
+
+
+    FT_FREE( stream->base );
+
+    stream->size  = 0;
+    stream->base  = NULL;
+    stream->close = NULL;
+  }
+
+
+  /* Create a new memory stream from a buffer and a size. */
+  /* From ftmac.c.                                        */
+  static FT_Error
+  new_memory_stream( FT_Library           library,
+                     FT_Byte*             base,
+                     FT_ULong             size,
+                     FT_Stream_CloseFunc  close,
+                     FT_Stream           *astream )
+  {
+    FT_Error   error;
+    FT_Memory  memory;
+    FT_Stream  stream = NULL;
+
+
+    if ( !library )
+      return FT_THROW( Invalid_Library_Handle );
+
+    if ( !base )
+      return FT_THROW( Invalid_Argument );
+
+    *astream = NULL;
+    memory = library->memory;
+    if ( FT_NEW( stream ) )
+      goto Exit;
+
+    FT_Stream_OpenMemory( stream, base, size );
+
+    stream->close = close;
+
+    *astream = stream;
+
+  Exit:
+    return error;
+  }
+
+
+  /* Create a new FT_Face given a buffer and a driver name. */
+  /* from ftmac.c */
+  FT_LOCAL_DEF( FT_Error )
+  open_face_from_buffer( FT_Library   library,
+                         FT_Byte*     base,
+                         FT_ULong     size,
+                         FT_Long      face_index,
+                         const char*  driver_name,
+                         FT_Face     *aface )
+  {
+    FT_Open_Args  args;
+    FT_Error      error;
+    FT_Stream     stream = NULL;
+    FT_Memory     memory = library->memory;
+
+
+    error = new_memory_stream( library,
+                               base,
+                               size,
+                               memory_stream_close,
+                               &stream );
+    if ( error )
+    {
+      FT_FREE( base );
+      return error;
+    }
+
+    args.flags = FT_OPEN_STREAM;
+    args.stream = stream;
+    if ( driver_name )
+    {
+      args.flags = args.flags | FT_OPEN_DRIVER;
+      args.driver = FT_Get_Module( library, driver_name );
+    }
+
+#ifdef FT_MACINTOSH
+    /* At this point, the face index has served its purpose;  */
+    /* whoever calls this function has already used it to     */
+    /* locate the correct font data.  We should not propagate */
+    /* this index to FT_Open_Face() (unless it is negative).  */
+
+    if ( face_index > 0 )
+      face_index &= 0x7FFF0000L; /* retain GX data */
+#endif
+
+    error = FT_Open_Face( library, &args, face_index, aface );
+
+    if ( error == FT_Err_Ok )
+      (*aface)->face_flags &= ~FT_FACE_FLAG_EXTERNAL_STREAM;
+    else
+#ifdef FT_MACINTOSH
+      FT_Stream_Free( stream, 0 );
+#else
+    {
+      FT_Stream_Close( stream );
+      FT_FREE( stream );
+    }
+#endif
+
+    return error;
+  }
+
+
+  /* Look up `TYP1' or `CID ' table from sfnt table directory.       */
+  /* `offset' and `length' must exclude the binary header in tables. */
+
+  /* Type 1 and CID-keyed font drivers should recognize sfnt-wrapped */
+  /* format too.  Here, since we can't expect that the TrueType font */
+  /* driver is loaded unconditionally, we must parse the font by     */
+  /* ourselves.  We are only interested in the name of the table and */
+  /* the offset.                                                     */
+
+  static FT_Error
+  ft_lookup_PS_in_sfnt_stream( FT_Stream  stream,
+                               FT_Long    face_index,
+                               FT_ULong*  offset,
+                               FT_ULong*  length,
+                               FT_Bool*   is_sfnt_cid )
+  {
+    FT_Error   error;
+    FT_UShort  numTables;
+    FT_Long    pstable_index;
+    FT_ULong   tag;
+    int        i;
+
+
+    *offset = 0;
+    *length = 0;
+    *is_sfnt_cid = FALSE;
+
+    /* TODO: support for sfnt-wrapped PS/CID in TTC format */
+
+    /* version check for 'typ1' (should be ignored?) */
+    if ( FT_READ_ULONG( tag ) )
+      return error;
+    if ( tag != TTAG_typ1 )
+      return FT_THROW( Unknown_File_Format );
+
+    if ( FT_READ_USHORT( numTables ) )
+      return error;
+    if ( FT_STREAM_SKIP( 2 * 3 ) ) /* skip binary search header */
+      return error;
+
+    pstable_index = -1;
+    *is_sfnt_cid  = FALSE;
+
+    for ( i = 0; i < numTables; i++ )
+    {
+      if ( FT_READ_ULONG( tag )     || FT_STREAM_SKIP( 4 )      ||
+           FT_READ_ULONG( *offset ) || FT_READ_ULONG( *length ) )
+        return error;
+
+      if ( tag == TTAG_CID )
+      {
+        pstable_index++;
+        *offset += 22;
+        *length -= 22;
+        *is_sfnt_cid = TRUE;
+        if ( face_index < 0 )
+          return FT_Err_Ok;
+      }
+      else if ( tag == TTAG_TYP1 )
+      {
+        pstable_index++;
+        *offset += 24;
+        *length -= 24;
+        *is_sfnt_cid = FALSE;
+        if ( face_index < 0 )
+          return FT_Err_Ok;
+      }
+      if ( face_index >= 0 && pstable_index == face_index )
+        return FT_Err_Ok;
+    }
+
+    return FT_THROW( Table_Missing );
+  }
+
+
+  FT_LOCAL_DEF( FT_Error )
+  open_face_PS_from_sfnt_stream( FT_Library     library,
+                                 FT_Stream      stream,
+                                 FT_Long        face_index,
+                                 FT_Int         num_params,
+                                 FT_Parameter  *params,
+                                 FT_Face       *aface )
+  {
+    FT_Error   error;
+    FT_Memory  memory = library->memory;
+    FT_ULong   offset, length;
+    FT_ULong   pos;
+    FT_Bool    is_sfnt_cid;
+    FT_Byte*   sfnt_ps = NULL;
+
+    FT_UNUSED( num_params );
+    FT_UNUSED( params );
+
+
+    /* ignore GX stuff */
+    if ( face_index > 0 )
+      face_index &= 0xFFFFL;
+
+    pos = FT_STREAM_POS();
+
+    error = ft_lookup_PS_in_sfnt_stream( stream,
+                                         face_index,
+                                         &offset,
+                                         &length,
+                                         &is_sfnt_cid );
+    if ( error )
+      goto Exit;
+
+    if ( offset > stream->size )
+    {
+      FT_TRACE2(( "open_face_PS_from_sfnt_stream: invalid table offset\n" ));
+      error = FT_THROW( Invalid_Table );
+      goto Exit;
+    }
+    else if ( length > stream->size - offset )
+    {
+      FT_TRACE2(( "open_face_PS_from_sfnt_stream: invalid table length\n" ));
+      error = FT_THROW( Invalid_Table );
+      goto Exit;
+    }
+
+    error = FT_Stream_Seek( stream, pos + offset );
+    if ( error )
+      goto Exit;
+
+    if ( FT_ALLOC( sfnt_ps, (FT_Long)length ) )
+      goto Exit;
+
+    error = FT_Stream_Read( stream, (FT_Byte *)sfnt_ps, length );
+    if ( error )
+    {
+      FT_FREE( sfnt_ps );
+      goto Exit;
+    }
+
+    error = open_face_from_buffer( library,
+                                   sfnt_ps,
+                                   length,
+                                   FT_MIN( face_index, 0 ),
+                                   is_sfnt_cid ? "cid" : "type1",
+                                   aface );
+  Exit:
+    {
+      FT_Error  error1;
+
+
+      if ( FT_ERR_EQ( error, Unknown_File_Format ) )
+      {
+        error1 = FT_Stream_Seek( stream, pos );
+        if ( error1 )
+          return error1;
+      }
+
+      return error;
+    }
+  }
+
+
+#ifndef FT_MACINTOSH
+
+  /* The resource header says we've got resource_cnt `POST' (type1) */
+  /* resources in this file.  They all need to be coalesced into    */
+  /* one lump which gets passed on to the type1 driver.             */
+  /* Here can be only one PostScript font in a file so face_index   */
+  /* must be 0 (or -1).                                             */
+  /*                                                                */
+  static FT_Error
+  Mac_Read_POST_Resource( FT_Library  library,
+                          FT_Stream   stream,
+                          FT_Long    *offsets,
+                          FT_Long     resource_cnt,
+                          FT_Long     face_index,
+                          FT_Face    *aface )
+  {
+    FT_Error   error  = FT_ERR( Cannot_Open_Resource );
+    FT_Memory  memory = library->memory;
+    FT_Byte*   pfb_data = NULL;
+    int        i, type, flags;
+    FT_ULong   len;
+    FT_ULong   pfb_len, pfb_pos, pfb_lenpos;
+    FT_ULong   rlen, temp;
+
+
+    if ( face_index == -1 )
+      face_index = 0;
+    if ( face_index != 0 )
+      return error;
+
+    /* Find the length of all the POST resources, concatenated.  Assume */
+    /* worst case (each resource in its own section).                   */
+    pfb_len = 0;
+    for ( i = 0; i < resource_cnt; ++i )
+    {
+      error = FT_Stream_Seek( stream, (FT_ULong)offsets[i] );
+      if ( error )
+        goto Exit;
+      if ( FT_READ_ULONG( temp ) )
+        goto Exit;
+
+      /* FT2 allocator takes signed long buffer length,
+       * too large value causing overflow should be checked
+       */
+      FT_TRACE4(( "                 POST fragment #%d: length=0x%08x"
+                  " total pfb_len=0x%08x\n",
+                  i, temp, pfb_len + temp + 6));
+      if ( FT_MAC_RFORK_MAX_LEN < temp               ||
+           FT_MAC_RFORK_MAX_LEN - temp < pfb_len + 6 )
+      {
+        FT_TRACE2(( "             MacOS resource length cannot exceed"
+                    " 0x%08x\n", FT_MAC_RFORK_MAX_LEN ));
+        error = FT_THROW( Invalid_Offset );
+        goto Exit;
+      }
+
+      pfb_len += temp + 6;
+    }
+
+    FT_TRACE2(( "             total buffer size to concatenate %d"
+                " POST fragments: 0x%08x\n",
+                 resource_cnt, pfb_len + 2));
+    if ( pfb_len + 2 < 6 ) {
+      FT_TRACE2(( "             too long fragment length makes"
+                  " pfb_len confused: pfb_len=0x%08x\n", pfb_len ));
+      error = FT_THROW( Array_Too_Large );
+      goto Exit;
+    }
+    if ( FT_ALLOC( pfb_data, (FT_Long)pfb_len + 2 ) )
+      goto Exit;
+
+    pfb_data[0] = 0x80;
+    pfb_data[1] = 1;            /* Ascii section */
+    pfb_data[2] = 0;            /* 4-byte length, fill in later */
+    pfb_data[3] = 0;
+    pfb_data[4] = 0;
+    pfb_data[5] = 0;
+    pfb_pos     = 6;
+    pfb_lenpos  = 2;
+
+    len = 0;
+    type = 1;
+    for ( i = 0; i < resource_cnt; ++i )
+    {
+      error = FT_Stream_Seek( stream, (FT_ULong)offsets[i] );
+      if ( error )
+        goto Exit2;
+      if ( FT_READ_ULONG( rlen ) )
+        goto Exit2;
+
+      /* FT2 allocator takes signed long buffer length,
+       * too large fragment length causing overflow should be checked
+       */
+      if ( 0x7FFFFFFFUL < rlen )
+      {
+        error = FT_THROW( Invalid_Offset );
+        goto Exit2;
+      }
+
+      if ( FT_READ_USHORT( flags ) )
+        goto Exit2;
+      FT_TRACE3(( "POST fragment[%d]: offsets=0x%08x, rlen=0x%08x, flags=0x%04x\n",
+                   i, offsets[i], rlen, flags ));
+
+      error = FT_ERR( Array_Too_Large );
+      /* postpone the check of rlen longer than buffer until FT_Stream_Read() */
+      if ( ( flags >> 8 ) == 0 )        /* Comment, should not be loaded */
+      {
+        FT_TRACE3(( "    Skip POST fragment #%d because it is a comment\n", i ));
+        continue;
+      }
+
+      /* the flags are part of the resource, so rlen >= 2.  */
+      /* but some fonts declare rlen = 0 for empty fragment */
+      if ( rlen > 2 )
+        rlen -= 2;
+      else
+        rlen = 0;
+
+      if ( ( flags >> 8 ) == type )
+        len += rlen;
+      else
+      {
+        FT_TRACE3(( "    Write POST fragment #%d header (4-byte) to buffer"
+                    " %p + 0x%08x\n", i, pfb_data, pfb_lenpos ));
+        if ( pfb_lenpos + 3 > pfb_len + 2 )
+          goto Exit2;
+        pfb_data[pfb_lenpos    ] = (FT_Byte)( len );
+        pfb_data[pfb_lenpos + 1] = (FT_Byte)( len >> 8 );
+        pfb_data[pfb_lenpos + 2] = (FT_Byte)( len >> 16 );
+        pfb_data[pfb_lenpos + 3] = (FT_Byte)( len >> 24 );
+
+        if ( ( flags >> 8 ) == 5 )      /* End of font mark */
+          break;
+
+        FT_TRACE3(( "    Write POST fragment #%d header (6-byte) to buffer"
+                    " %p + 0x%08x\n", i, pfb_data, pfb_pos ));
+        if ( pfb_pos + 6 > pfb_len + 2 )
+          goto Exit2;
+        pfb_data[pfb_pos++] = 0x80;
+
+        type = flags >> 8;
+        len = rlen;
+
+        pfb_data[pfb_pos++] = (FT_Byte)type;
+        pfb_lenpos          = pfb_pos;
+        pfb_data[pfb_pos++] = 0;        /* 4-byte length, fill in later */
+        pfb_data[pfb_pos++] = 0;
+        pfb_data[pfb_pos++] = 0;
+        pfb_data[pfb_pos++] = 0;
+      }
+
+      if ( pfb_pos > pfb_len || pfb_pos + rlen > pfb_len )
+        goto Exit2;
+
+      FT_TRACE3(( "    Load POST fragment #%d (%d byte) to buffer"
+                  " %p + 0x%08x\n", i, rlen, pfb_data, pfb_pos ));
+      error = FT_Stream_Read( stream, (FT_Byte *)pfb_data + pfb_pos, rlen );
+      if ( error )
+        goto Exit2;
+      pfb_pos += rlen;
+    }
+
+    error = FT_ERR( Array_Too_Large );
+    if ( pfb_pos + 2 > pfb_len + 2 )
+      goto Exit2;
+    pfb_data[pfb_pos++] = 0x80;
+    pfb_data[pfb_pos++] = 3;
+
+    if ( pfb_lenpos + 3 > pfb_len + 2 )
+      goto Exit2;
+    pfb_data[pfb_lenpos    ] = (FT_Byte)( len );
+    pfb_data[pfb_lenpos + 1] = (FT_Byte)( len >> 8 );
+    pfb_data[pfb_lenpos + 2] = (FT_Byte)( len >> 16 );
+    pfb_data[pfb_lenpos + 3] = (FT_Byte)( len >> 24 );
+
+    return open_face_from_buffer( library,
+                                  pfb_data,
+                                  pfb_pos,
+                                  face_index,
+                                  "type1",
+                                  aface );
+
+  Exit2:
+    if ( error == FT_ERR( Array_Too_Large ) )
+      FT_TRACE2(( "  Abort due to too-short buffer to store"
+                  " all POST fragments\n" ));
+    else if ( error == FT_ERR( Invalid_Offset ) )
+      FT_TRACE2(( "  Abort due to invalid offset in a POST fragment\n" ));
+    if ( error )
+      error = FT_ERR( Cannot_Open_Resource );
+    FT_FREE( pfb_data );
+
+  Exit:
+    return error;
+  }
+
+
+  /* The resource header says we've got resource_cnt `sfnt'      */
+  /* (TrueType/OpenType) resources in this file.  Look through   */
+  /* them for the one indicated by face_index, load it into mem, */
+  /* pass it on to the truetype driver, and return it.           */
+  /*                                                             */
+  static FT_Error
+  Mac_Read_sfnt_Resource( FT_Library  library,
+                          FT_Stream   stream,
+                          FT_Long    *offsets,
+                          FT_Long     resource_cnt,
+                          FT_Long     face_index,
+                          FT_Face    *aface )
+  {
+    FT_Memory  memory = library->memory;
+    FT_Byte*   sfnt_data = NULL;
+    FT_Error   error;
+    FT_ULong   flag_offset;
+    FT_Long    rlen;
+    int        is_cff;
+    FT_Long    face_index_in_resource = 0;
+
+
+    if ( face_index < 0 )
+      face_index = -face_index - 1;
+    if ( face_index >= resource_cnt )
+      return FT_THROW( Cannot_Open_Resource );
+
+    flag_offset = (FT_ULong)offsets[face_index];
+    error = FT_Stream_Seek( stream, flag_offset );
+    if ( error )
+      goto Exit;
+
+    if ( FT_READ_LONG( rlen ) )
+      goto Exit;
+    if ( rlen == -1 )
+      return FT_THROW( Cannot_Open_Resource );
+    if ( (FT_ULong)rlen > FT_MAC_RFORK_MAX_LEN )
+      return FT_THROW( Invalid_Offset );
+
+    error = open_face_PS_from_sfnt_stream( library,
+                                           stream,
+                                           face_index,
+                                           0, NULL,
+                                           aface );
+    if ( !error )
+      goto Exit;
+
+    /* rewind sfnt stream before open_face_PS_from_sfnt_stream() */
+    error = FT_Stream_Seek( stream, flag_offset + 4 );
+    if ( error )
+      goto Exit;
+
+    if ( FT_ALLOC( sfnt_data, rlen ) )
+      return error;
+    error = FT_Stream_Read( stream, (FT_Byte *)sfnt_data, (FT_ULong)rlen );
+    if ( error ) {
+      FT_FREE( sfnt_data );
+      goto Exit;
+    }
+
+    is_cff = rlen > 4 && !ft_memcmp( sfnt_data, "OTTO", 4 );
+    error = open_face_from_buffer( library,
+                                   sfnt_data,
+                                   (FT_ULong)rlen,
+                                   face_index_in_resource,
+                                   is_cff ? "cff" : "truetype",
+                                   aface );
+
+  Exit:
+    return error;
+  }
+
+
+  /* Check for a valid resource fork header, or a valid dfont    */
+  /* header.  In a resource fork the first 16 bytes are repeated */
+  /* at the location specified by bytes 4-7.  In a dfont bytes   */
+  /* 4-7 point to 16 bytes of zeroes instead.                    */
+  /*                                                             */
+  static FT_Error
+  IsMacResource( FT_Library  library,
+                 FT_Stream   stream,
+                 FT_Long     resource_offset,
+                 FT_Long     face_index,
+                 FT_Face    *aface )
+  {
+    FT_Memory  memory = library->memory;
+    FT_Error   error;
+    FT_Long    map_offset, rdara_pos;
+    FT_Long    *data_offsets;
+    FT_Long    count;
+
+
+    error = FT_Raccess_Get_HeaderInfo( library, stream, resource_offset,
+                                       &map_offset, &rdara_pos );
+    if ( error )
+      return error;
+
+    /* POST resources must be sorted to concatenate properly */
+    error = FT_Raccess_Get_DataOffsets( library, stream,
+                                        map_offset, rdara_pos,
+                                        TTAG_POST, TRUE,
+                                        &data_offsets, &count );
+    if ( !error )
+    {
+      error = Mac_Read_POST_Resource( library, stream, data_offsets, count,
+                                      face_index, aface );
+      FT_FREE( data_offsets );
+      /* POST exists in an LWFN providing a single face */
+      if ( !error )
+        (*aface)->num_faces = 1;
+      return error;
+    }
+
+    /* sfnt resources should not be sorted to preserve the face order by
+       QuickDraw API */
+    error = FT_Raccess_Get_DataOffsets( library, stream,
+                                        map_offset, rdara_pos,
+                                        TTAG_sfnt, FALSE,
+                                        &data_offsets, &count );
+    if ( !error )
+    {
+      FT_Long  face_index_internal = face_index % count;
+
+
+      error = Mac_Read_sfnt_Resource( library, stream, data_offsets, count,
+                                      face_index_internal, aface );
+      FT_FREE( data_offsets );
+      if ( !error )
+        (*aface)->num_faces = count;
+    }
+
+    return error;
+  }
+
+
+  /* Check for a valid macbinary header, and if we find one   */
+  /* check that the (flattened) resource fork in it is valid. */
+  /*                                                          */
+  static FT_Error
+  IsMacBinary( FT_Library  library,
+               FT_Stream   stream,
+               FT_Long     face_index,
+               FT_Face    *aface )
+  {
+    unsigned char  header[128];
+    FT_Error       error;
+    FT_Long        dlen, offset;
+
+
+    if ( NULL == stream )
+      return FT_THROW( Invalid_Stream_Operation );
+
+    error = FT_Stream_Seek( stream, 0 );
+    if ( error )
+      goto Exit;
+
+    error = FT_Stream_Read( stream, (FT_Byte*)header, 128 );
+    if ( error )
+      goto Exit;
+
+    if (            header[ 0] !=   0 ||
+                    header[74] !=   0 ||
+                    header[82] !=   0 ||
+                    header[ 1] ==   0 ||
+                    header[ 1] >   33 ||
+                    header[63] !=   0 ||
+         header[2 + header[1]] !=   0 ||
+                  header[0x53] > 0x7F )
+      return FT_THROW( Unknown_File_Format );
+
+    dlen = ( header[0x53] << 24 ) |
+           ( header[0x54] << 16 ) |
+           ( header[0x55] <<  8 ) |
+             header[0x56];
+#if 0
+    rlen = ( header[0x57] << 24 ) |
+           ( header[0x58] << 16 ) |
+           ( header[0x59] <<  8 ) |
+             header[0x5A];
+#endif /* 0 */
+    offset = 128 + ( ( dlen + 127 ) & ~127 );
+
+    return IsMacResource( library, stream, offset, face_index, aface );
+
+  Exit:
+    return error;
+  }
+
+
+  static FT_Error
+  load_face_in_embedded_rfork( FT_Library           library,
+                               FT_Stream            stream,
+                               FT_Long              face_index,
+                               FT_Face             *aface,
+                               const FT_Open_Args  *args )
+  {
+
+#undef  FT_COMPONENT
+#define FT_COMPONENT  trace_raccess
+
+    FT_Memory  memory = library->memory;
+    FT_Error   error  = FT_ERR( Unknown_File_Format );
+    FT_UInt    i;
+
+    char *     file_names[FT_RACCESS_N_RULES];
+    FT_Long    offsets[FT_RACCESS_N_RULES];
+    FT_Error   errors[FT_RACCESS_N_RULES];
+    FT_Bool    is_darwin_vfs, vfs_rfork_has_no_font = FALSE; /* not tested */
+
+    FT_Open_Args  args2;
+    FT_Stream     stream2 = NULL;
+
+
+    FT_Raccess_Guess( library, stream,
+                      args->pathname, file_names, offsets, errors );
+
+    for ( i = 0; i < FT_RACCESS_N_RULES; i++ )
+    {
+      is_darwin_vfs = ft_raccess_rule_by_darwin_vfs( library, i );
+      if ( is_darwin_vfs && vfs_rfork_has_no_font )
+      {
+        FT_TRACE3(( "Skip rule %d: darwin vfs resource fork"
+                    " is already checked and"
+                    " no font is found\n", i ));
+        continue;
+      }
+
+      if ( errors[i] )
+      {
+        FT_TRACE3(( "Error[%d] has occurred in rule %d\n", errors[i], i ));
+        continue;
+      }
+
+      args2.flags    = FT_OPEN_PATHNAME;
+      args2.pathname = file_names[i] ? file_names[i] : args->pathname;
+
+      FT_TRACE3(( "Try rule %d: %s (offset=%d) ...",
+                  i, args2.pathname, offsets[i] ));
+
+      error = FT_Stream_New( library, &args2, &stream2 );
+      if ( is_darwin_vfs && FT_ERR_EQ( error, Cannot_Open_Stream ) )
+        vfs_rfork_has_no_font = TRUE;
+
+      if ( error )
+      {
+        FT_TRACE3(( "failed\n" ));
+        continue;
+      }
+
+      error = IsMacResource( library, stream2, offsets[i],
+                             face_index, aface );
+      FT_Stream_Free( stream2, 0 );
+
+      FT_TRACE3(( "%s\n", error ? "failed": "successful" ));
+
+      if ( !error )
+          break;
+      else if ( is_darwin_vfs )
+          vfs_rfork_has_no_font = TRUE;
+    }
+
+    for (i = 0; i < FT_RACCESS_N_RULES; i++)
+    {
+      if ( file_names[i] )
+        FT_FREE( file_names[i] );
+    }
+
+    /* Caller (load_mac_face) requires FT_Err_Unknown_File_Format. */
+    if ( error )
+      error = FT_ERR( Unknown_File_Format );
+
+    return error;
+
+#undef  FT_COMPONENT
+#define FT_COMPONENT  trace_objs
+
+  }
+
+
+  /* Check for some macintosh formats without Carbon framework.    */
+  /* Is this a macbinary file?  If so look at the resource fork.   */
+  /* Is this a mac dfont file?                                     */
+  /* Is this an old style resource fork? (in data)                 */
+  /* Else call load_face_in_embedded_rfork to try extra rules      */
+  /* (defined in `ftrfork.c').                                     */
+  /*                                                               */
+  static FT_Error
+  load_mac_face( FT_Library           library,
+                 FT_Stream            stream,
+                 FT_Long              face_index,
+                 FT_Face             *aface,
+                 const FT_Open_Args  *args )
+  {
+    FT_Error error;
+    FT_UNUSED( args );
+
+
+    error = IsMacBinary( library, stream, face_index, aface );
+    if ( FT_ERR_EQ( error, Unknown_File_Format ) )
+    {
+
+#undef  FT_COMPONENT
+#define FT_COMPONENT  trace_raccess
+
+#ifdef FT_DEBUG_LEVEL_TRACE
+      FT_TRACE3(( "Try as dfont: " ));
+      if ( !( args->flags & FT_OPEN_MEMORY ) )
+        FT_TRACE3(( "%s ...", args->pathname ));
+#endif
+
+      error = IsMacResource( library, stream, 0, face_index, aface );
+
+      FT_TRACE3(( "%s\n", error ? "failed" : "successful" ));
+
+#undef  FT_COMPONENT
+#define FT_COMPONENT  trace_objs
+
+    }
+
+    if ( ( FT_ERR_EQ( error, Unknown_File_Format )      ||
+           FT_ERR_EQ( error, Invalid_Stream_Operation ) ) &&
+         ( args->flags & FT_OPEN_PATHNAME )               )
+      error = load_face_in_embedded_rfork( library, stream,
+                                           face_index, aface, args );
+    return error;
+  }
+#endif
+
+#endif  /* !FT_MACINTOSH && FT_CONFIG_OPTION_MAC_FONTS */
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_Open_Face( FT_Library           library,
+                const FT_Open_Args*  args,
+                FT_Long              face_index,
+                FT_Face             *aface )
+  {
+    FT_Error     error;
+    FT_Driver    driver = NULL;
+    FT_Memory    memory = NULL;
+    FT_Stream    stream = NULL;
+    FT_Face      face   = NULL;
+    FT_ListNode  node   = NULL;
+    FT_Bool      external_stream;
+    FT_Module*   cur;
+    FT_Module*   limit;
+
+
+    /* test for valid `library' delayed to `FT_Stream_New' */
+
+    if ( ( !aface && face_index >= 0 ) || !args )
+      return FT_THROW( Invalid_Argument );
+
+    external_stream = FT_BOOL( ( args->flags & FT_OPEN_STREAM ) &&
+                               args->stream                     );
+
+    /* create input stream */
+    error = FT_Stream_New( library, args, &stream );
+    if ( error )
+      goto Fail3;
+
+    memory = library->memory;
+
+    /* If the font driver is specified in the `args' structure, use */
+    /* it.  Otherwise, we scan the list of registered drivers.      */
+    if ( ( args->flags & FT_OPEN_DRIVER ) && args->driver )
+    {
+      driver = FT_DRIVER( args->driver );
+
+      /* not all modules are drivers, so check... */
+      if ( FT_MODULE_IS_DRIVER( driver ) )
+      {
+        FT_Int         num_params = 0;
+        FT_Parameter*  params     = NULL;
+
+
+        if ( args->flags & FT_OPEN_PARAMS )
+        {
+          num_params = args->num_params;
+          params     = args->params;
+        }
+
+        error = open_face( driver, &stream, external_stream, face_index,
+                           num_params, params, &face );
+        if ( !error )
+          goto Success;
+      }
+      else
+        error = FT_THROW( Invalid_Handle );
+
+      FT_Stream_Free( stream, external_stream );
+      goto Fail;
+    }
+    else
+    {
+      error = FT_ERR( Missing_Module );
+
+      /* check each font driver for an appropriate format */
+      cur   = library->modules;
+      limit = cur + library->num_modules;
+
+      for ( ; cur < limit; cur++ )
+      {
+        /* not all modules are font drivers, so check... */
+        if ( FT_MODULE_IS_DRIVER( cur[0] ) )
+        {
+          FT_Int         num_params = 0;
+          FT_Parameter*  params     = NULL;
+
+
+          driver = FT_DRIVER( cur[0] );
+
+          if ( args->flags & FT_OPEN_PARAMS )
+          {
+            num_params = args->num_params;
+            params     = args->params;
+          }
+
+          error = open_face( driver, &stream, external_stream, face_index,
+                             num_params, params, &face );
+          if ( !error )
+            goto Success;
+
+#ifdef FT_CONFIG_OPTION_MAC_FONTS
+          if ( ft_strcmp( cur[0]->clazz->module_name, "truetype" ) == 0 &&
+               FT_ERR_EQ( error, Table_Missing )                        )
+          {
+            /* TrueType but essential tables are missing */
+            error = FT_Stream_Seek( stream, 0 );
+            if ( error )
+              break;
+
+            error = open_face_PS_from_sfnt_stream( library,
+                                                   stream,
+                                                   face_index,
+                                                   num_params,
+                                                   params,
+                                                   aface );
+            if ( !error )
+            {
+              FT_Stream_Free( stream, external_stream );
+              return error;
+            }
+          }
+#endif
+
+          if ( FT_ERR_NEQ( error, Unknown_File_Format ) )
+            goto Fail3;
+        }
+      }
+
+    Fail3:
+      /* If we are on the mac, and we get an                          */
+      /* FT_Err_Invalid_Stream_Operation it may be because we have an */
+      /* empty data fork, so we need to check the resource fork.      */
+      if ( FT_ERR_NEQ( error, Cannot_Open_Stream )       &&
+           FT_ERR_NEQ( error, Unknown_File_Format )      &&
+           FT_ERR_NEQ( error, Invalid_Stream_Operation ) )
+        goto Fail2;
+
+#if !defined( FT_MACINTOSH ) && defined( FT_CONFIG_OPTION_MAC_FONTS )
+      error = load_mac_face( library, stream, face_index, aface, args );
+      if ( !error )
+      {
+        /* We don't want to go to Success here.  We've already done that. */
+        /* On the other hand, if we succeeded we still need to close this */
+        /* stream (we opened a different stream which extracted the       */
+        /* interesting information out of this stream here.  That stream  */
+        /* will still be open and the face will point to it).             */
+        FT_Stream_Free( stream, external_stream );
+        return error;
+      }
+
+      if ( FT_ERR_NEQ( error, Unknown_File_Format ) )
+        goto Fail2;
+#endif  /* !FT_MACINTOSH && FT_CONFIG_OPTION_MAC_FONTS */
+
+      /* no driver is able to handle this format */
+      error = FT_THROW( Unknown_File_Format );
+
+  Fail2:
+      FT_Stream_Free( stream, external_stream );
+      goto Fail;
+    }
+
+  Success:
+    FT_TRACE4(( "FT_Open_Face: New face object, adding to list\n" ));
+
+    /* add the face object to its driver's list */
+    if ( FT_NEW( node ) )
+      goto Fail;
+
+    node->data = face;
+    /* don't assume driver is the same as face->driver, so use */
+    /* face->driver instead.                                   */
+    FT_List_Add( &face->driver->faces_list, node );
+
+    /* now allocate a glyph slot object for the face */
+    FT_TRACE4(( "FT_Open_Face: Creating glyph slot\n" ));
+
+    if ( face_index >= 0 )
+    {
+      error = FT_New_GlyphSlot( face, NULL );
+      if ( error )
+        goto Fail;
+
+      /* finally, allocate a size object for the face */
+      {
+        FT_Size  size;
+
+
+        FT_TRACE4(( "FT_Open_Face: Creating size object\n" ));
+
+        error = FT_New_Size( face, &size );
+        if ( error )
+          goto Fail;
+
+        face->size = size;
+      }
+    }
+
+    /* some checks */
+
+    if ( FT_IS_SCALABLE( face ) )
+    {
+      if ( face->height < 0 )
+        face->height = (FT_Short)-face->height;
+
+      if ( !FT_HAS_VERTICAL( face ) )
+        face->max_advance_height = (FT_Short)face->height;
+    }
+
+    if ( FT_HAS_FIXED_SIZES( face ) )
+    {
+      FT_Int  i;
+
+
+      for ( i = 0; i < face->num_fixed_sizes; i++ )
+      {
+        FT_Bitmap_Size*  bsize = face->available_sizes + i;
+
+
+        if ( bsize->height < 0 )
+          bsize->height = -bsize->height;
+        if ( bsize->x_ppem < 0 )
+          bsize->x_ppem = -bsize->x_ppem;
+        if ( bsize->y_ppem < 0 )
+          bsize->y_ppem = -bsize->y_ppem;
+
+        /* check whether negation actually has worked */
+        if ( bsize->height < 0 || bsize->x_ppem < 0 || bsize->y_ppem < 0 )
+        {
+          FT_TRACE0(( "FT_Open_Face:"
+                      " Invalid bitmap dimensions for stroke %d,"
+                      " now disabled\n", i ));
+          bsize->width  = 0;
+          bsize->height = 0;
+          bsize->size   = 0;
+          bsize->x_ppem = 0;
+          bsize->y_ppem = 0;
+        }
+      }
+    }
+
+    /* initialize internal face data */
+    {
+      FT_Face_Internal  internal = face->internal;
+
+
+      internal->transform_matrix.xx = 0x10000L;
+      internal->transform_matrix.xy = 0;
+      internal->transform_matrix.yx = 0;
+      internal->transform_matrix.yy = 0x10000L;
+
+      internal->transform_delta.x = 0;
+      internal->transform_delta.y = 0;
+
+      internal->refcount = 1;
+    }
+
+    if ( aface )
+      *aface = face;
+    else
+      FT_Done_Face( face );
+
+    goto Exit;
+
+  Fail:
+    if ( node )
+      FT_Done_Face( face );    /* face must be in the driver's list */
+    else if ( face )
+      destroy_face( memory, face, driver );
+
+  Exit:
+    FT_TRACE4(( "FT_Open_Face: Return %d\n", error ));
+
+    return error;
+  }
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_Attach_File( FT_Face      face,
+                  const char*  filepathname )
+  {
+    FT_Open_Args  open;
+
+
+    /* test for valid `face' delayed to `FT_Attach_Stream' */
+
+    if ( !filepathname )
+      return FT_THROW( Invalid_Argument );
+
+    open.stream   = NULL;
+    open.flags    = FT_OPEN_PATHNAME;
+    open.pathname = (char*)filepathname;
+
+    return FT_Attach_Stream( face, &open );
+  }
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_Attach_Stream( FT_Face        face,
+                    FT_Open_Args*  parameters )
+  {
+    FT_Stream  stream;
+    FT_Error   error;
+    FT_Driver  driver;
+
+    FT_Driver_Class  clazz;
+
+
+    /* test for valid `parameters' delayed to `FT_Stream_New' */
+
+    if ( !face )
+      return FT_THROW( Invalid_Face_Handle );
+
+    driver = face->driver;
+    if ( !driver )
+      return FT_THROW( Invalid_Driver_Handle );
+
+    error = FT_Stream_New( driver->root.library, parameters, &stream );
+    if ( error )
+      goto Exit;
+
+    /* we implement FT_Attach_Stream in each driver through the */
+    /* `attach_file' interface                                  */
+
+    error = FT_ERR( Unimplemented_Feature );
+    clazz = driver->clazz;
+    if ( clazz->attach_file )
+      error = clazz->attach_file( face, stream );
+
+    /* close the attached stream */
+    FT_Stream_Free( stream,
+                    (FT_Bool)( parameters->stream &&
+                               ( parameters->flags & FT_OPEN_STREAM ) ) );
+
+  Exit:
+    return error;
+  }
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_Reference_Face( FT_Face  face )
+  {
+    if ( !face )
+      return FT_THROW( Invalid_Face_Handle );
+
+    face->internal->refcount++;
+
+    return FT_Err_Ok;
+  }
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_Done_Face( FT_Face  face )
+  {
+    FT_Error     error;
+    FT_Driver    driver;
+    FT_Memory    memory;
+    FT_ListNode  node;
+
+
+    error = FT_ERR( Invalid_Face_Handle );
+    if ( face && face->driver )
+    {
+      face->internal->refcount--;
+      if ( face->internal->refcount > 0 )
+        error = FT_Err_Ok;
+      else
+      {
+        driver = face->driver;
+        memory = driver->root.memory;
+
+        /* find face in driver's list */
+        node = FT_List_Find( &driver->faces_list, face );
+        if ( node )
+        {
+          /* remove face object from the driver's list */
+          FT_List_Remove( &driver->faces_list, node );
+          FT_FREE( node );
+
+          /* now destroy the object proper */
+          destroy_face( memory, face, driver );
+          error = FT_Err_Ok;
+        }
+      }
+    }
+
+    return error;
+  }
+
+
+  /* documentation is in ftobjs.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_New_Size( FT_Face   face,
+               FT_Size  *asize )
+  {
+    FT_Error         error;
+    FT_Memory        memory;
+    FT_Driver        driver;
+    FT_Driver_Class  clazz;
+
+    FT_Size          size = NULL;
+    FT_ListNode      node = NULL;
+
+
+    if ( !face )
+      return FT_THROW( Invalid_Face_Handle );
+
+    if ( !asize )
+      return FT_THROW( Invalid_Argument );
+
+    if ( !face->driver )
+      return FT_THROW( Invalid_Driver_Handle );
+
+    *asize = NULL;
+
+    driver = face->driver;
+    clazz  = driver->clazz;
+    memory = face->memory;
+
+    /* Allocate new size object and perform basic initialisation */
+    if ( FT_ALLOC( size, clazz->size_object_size ) || FT_NEW( node ) )
+      goto Exit;
+
+    size->face = face;
+
+    /* for now, do not use any internal fields in size objects */
+    size->internal = NULL;
+
+    if ( clazz->init_size )
+      error = clazz->init_size( size );
+
+    /* in case of success, add to the face's list */
+    if ( !error )
+    {
+      *asize     = size;
+      node->data = size;
+      FT_List_Add( &face->sizes_list, node );
+    }
+
+  Exit:
+    if ( error )
+    {
+      FT_FREE( node );
+      FT_FREE( size );
+    }
+
+    return error;
+  }
+
+
+  /* documentation is in ftobjs.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_Done_Size( FT_Size  size )
+  {
+    FT_Error     error;
+    FT_Driver    driver;
+    FT_Memory    memory;
+    FT_Face      face;
+    FT_ListNode  node;
+
+
+    if ( !size )
+      return FT_THROW( Invalid_Size_Handle );
+
+    face = size->face;
+    if ( !face )
+      return FT_THROW( Invalid_Face_Handle );
+
+    driver = face->driver;
+    if ( !driver )
+      return FT_THROW( Invalid_Driver_Handle );
+
+    memory = driver->root.memory;
+
+    error = FT_Err_Ok;
+    node  = FT_List_Find( &face->sizes_list, size );
+    if ( node )
+    {
+      FT_List_Remove( &face->sizes_list, node );
+      FT_FREE( node );
+
+      if ( face->size == size )
+      {
+        face->size = NULL;
+        if ( face->sizes_list.head )
+          face->size = (FT_Size)(face->sizes_list.head->data);
+      }
+
+      destroy_size( memory, size, driver );
+    }
+    else
+      error = FT_THROW( Invalid_Size_Handle );
+
+    return error;
+  }
+
+
+  /* documentation is in ftobjs.h */
+
+  FT_BASE_DEF( FT_Error )
+  FT_Match_Size( FT_Face          face,
+                 FT_Size_Request  req,
+                 FT_Bool          ignore_width,
+                 FT_ULong*        size_index )
+  {
+    FT_Int   i;
+    FT_Long  w, h;
+
+
+    if ( !FT_HAS_FIXED_SIZES( face ) )
+      return FT_THROW( Invalid_Face_Handle );
+
+    /* FT_Bitmap_Size doesn't provide enough info... */
+    if ( req->type != FT_SIZE_REQUEST_TYPE_NOMINAL )
+      return FT_THROW( Unimplemented_Feature );
+
+    w = FT_REQUEST_WIDTH ( req );
+    h = FT_REQUEST_HEIGHT( req );
+
+    if ( req->width && !req->height )
+      h = w;
+    else if ( !req->width && req->height )
+      w = h;
+
+    w = FT_PIX_ROUND( w );
+    h = FT_PIX_ROUND( h );
+
+    for ( i = 0; i < face->num_fixed_sizes; i++ )
+    {
+      FT_Bitmap_Size*  bsize = face->available_sizes + i;
+
+
+      if ( h != FT_PIX_ROUND( bsize->y_ppem ) )
+        continue;
+
+      if ( w == FT_PIX_ROUND( bsize->x_ppem ) || ignore_width )
+      {
+        FT_TRACE3(( "FT_Match_Size: bitmap strike %d matches\n", i ));
+
+        if ( size_index )
+          *size_index = (FT_ULong)i;
+
+        return FT_Err_Ok;
+      }
+    }
+
+    return FT_THROW( Invalid_Pixel_Size );
+  }
+
+
+  /* documentation is in ftobjs.h */
+
+  FT_BASE_DEF( void )
+  ft_synthesize_vertical_metrics( FT_Glyph_Metrics*  metrics,
+                                  FT_Pos             advance )
+  {
+    FT_Pos  height = metrics->height;
+
+
+    /* compensate for glyph with bbox above/below the baseline */
+    if ( metrics->horiBearingY < 0 )
+    {
+      if ( height < metrics->horiBearingY )
+        height = metrics->horiBearingY;
+    }
+    else if ( metrics->horiBearingY > 0 )
+      height -= metrics->horiBearingY;
+
+    /* the factor 1.2 is a heuristical value */
+    if ( !advance )
+      advance = height * 12 / 10;
+
+    metrics->vertBearingX = metrics->horiBearingX - metrics->horiAdvance / 2;
+    metrics->vertBearingY = ( advance - height ) / 2;
+    metrics->vertAdvance  = advance;
+  }
+
+
+  static void
+  ft_recompute_scaled_metrics( FT_Face           face,
+                               FT_Size_Metrics*  metrics )
+  {
+    /* Compute root ascender, descender, test height, and max_advance */
+
+#ifdef GRID_FIT_METRICS
+    metrics->ascender    = FT_PIX_CEIL( FT_MulFix( face->ascender,
+                                                   metrics->y_scale ) );
+
+    metrics->descender   = FT_PIX_FLOOR( FT_MulFix( face->descender,
+                                                    metrics->y_scale ) );
+
+    metrics->height      = FT_PIX_ROUND( FT_MulFix( face->height,
+                                                    metrics->y_scale ) );
+
+    metrics->max_advance = FT_PIX_ROUND( FT_MulFix( face->max_advance_width,
+                                                    metrics->x_scale ) );
+#else /* !GRID_FIT_METRICS */
+    metrics->ascender    = FT_MulFix( face->ascender,
+                                      metrics->y_scale );
+
+    metrics->descender   = FT_MulFix( face->descender,
+                                      metrics->y_scale );
+
+    metrics->height      = FT_MulFix( face->height,
+                                      metrics->y_scale );
+
+    metrics->max_advance = FT_MulFix( face->max_advance_width,
+                                      metrics->x_scale );
+#endif /* !GRID_FIT_METRICS */
+  }
+
+
+  FT_BASE_DEF( void )
+  FT_Select_Metrics( FT_Face   face,
+                     FT_ULong  strike_index )
+  {
+    FT_Size_Metrics*  metrics;
+    FT_Bitmap_Size*   bsize;
+
+
+    metrics = &face->size->metrics;
+    bsize   = face->available_sizes + strike_index;
+
+    metrics->x_ppem = (FT_UShort)( ( bsize->x_ppem + 32 ) >> 6 );
+    metrics->y_ppem = (FT_UShort)( ( bsize->y_ppem + 32 ) >> 6 );
+
+    if ( FT_IS_SCALABLE( face ) )
+    {
+      metrics->x_scale = FT_DivFix( bsize->x_ppem,
+                                    face->units_per_EM );
+      metrics->y_scale = FT_DivFix( bsize->y_ppem,
+                                    face->units_per_EM );
+
+      ft_recompute_scaled_metrics( face, metrics );
+    }
+    else
+    {
+      metrics->x_scale     = 1L << 16;
+      metrics->y_scale     = 1L << 16;
+      metrics->ascender    = bsize->y_ppem;
+      metrics->descender   = 0;
+      metrics->height      = bsize->height << 6;
+      metrics->max_advance = bsize->x_ppem;
+    }
+
+    FT_TRACE5(( "FT_Select_Metrics:\n" ));
+    FT_TRACE5(( "  x scale: %d (%f)\n",
+                metrics->x_scale, metrics->x_scale / 65536.0 ));
+    FT_TRACE5(( "  y scale: %d (%f)\n",
+                metrics->y_scale, metrics->y_scale / 65536.0 ));
+    FT_TRACE5(( "  ascender: %f\n",    metrics->ascender / 64.0 ));
+    FT_TRACE5(( "  descender: %f\n",   metrics->descender / 64.0 ));
+    FT_TRACE5(( "  height: %f\n",      metrics->height / 64.0 ));
+    FT_TRACE5(( "  max advance: %f\n", metrics->max_advance / 64.0 ));
+    FT_TRACE5(( "  x ppem: %d\n",      metrics->x_ppem ));
+    FT_TRACE5(( "  y ppem: %d\n",      metrics->y_ppem ));
+  }
+
+
+  FT_BASE_DEF( void )
+  FT_Request_Metrics( FT_Face          face,
+                      FT_Size_Request  req )
+  {
+    FT_Size_Metrics*  metrics;
+
+
+    metrics = &face->size->metrics;
+
+    if ( FT_IS_SCALABLE( face ) )
+    {
+      FT_Long  w = 0, h = 0, scaled_w = 0, scaled_h = 0;
+
+
+      switch ( req->type )
+      {
+      case FT_SIZE_REQUEST_TYPE_NOMINAL:
+        w = h = face->units_per_EM;
+        break;
+
+      case FT_SIZE_REQUEST_TYPE_REAL_DIM:
+        w = h = face->ascender - face->descender;
+        break;
+
+      case FT_SIZE_REQUEST_TYPE_BBOX:
+        w = face->bbox.xMax - face->bbox.xMin;
+        h = face->bbox.yMax - face->bbox.yMin;
+        break;
+
+      case FT_SIZE_REQUEST_TYPE_CELL:
+        w = face->max_advance_width;
+        h = face->ascender - face->descender;
+        break;
+
+      case FT_SIZE_REQUEST_TYPE_SCALES:
+        metrics->x_scale = (FT_Fixed)req->width;
+        metrics->y_scale = (FT_Fixed)req->height;
+        if ( !metrics->x_scale )
+          metrics->x_scale = metrics->y_scale;
+        else if ( !metrics->y_scale )
+          metrics->y_scale = metrics->x_scale;
+        goto Calculate_Ppem;
+
+      case FT_SIZE_REQUEST_TYPE_MAX:
+        break;
+      }
+
+      /* to be on the safe side */
+      if ( w < 0 )
+        w = -w;
+
+      if ( h < 0 )
+        h = -h;
+
+      scaled_w = FT_REQUEST_WIDTH ( req );
+      scaled_h = FT_REQUEST_HEIGHT( req );
+
+      /* determine scales */
+      if ( req->width )
+      {
+        metrics->x_scale = FT_DivFix( scaled_w, w );
+
+        if ( req->height )
+        {
+          metrics->y_scale = FT_DivFix( scaled_h, h );
+
+          if ( req->type == FT_SIZE_REQUEST_TYPE_CELL )
+          {
+            if ( metrics->y_scale > metrics->x_scale )
+              metrics->y_scale = metrics->x_scale;
+            else
+              metrics->x_scale = metrics->y_scale;
+          }
+        }
+        else
+        {
+          metrics->y_scale = metrics->x_scale;
+          scaled_h = FT_MulDiv( scaled_w, h, w );
+        }
+      }
+      else
+      {
+        metrics->x_scale = metrics->y_scale = FT_DivFix( scaled_h, h );
+        scaled_w = FT_MulDiv( scaled_h, w, h );
+      }
+
+  Calculate_Ppem:
+      /* calculate the ppems */
+      if ( req->type != FT_SIZE_REQUEST_TYPE_NOMINAL )
+      {
+        scaled_w = FT_MulFix( face->units_per_EM, metrics->x_scale );
+        scaled_h = FT_MulFix( face->units_per_EM, metrics->y_scale );
+      }
+
+      metrics->x_ppem = (FT_UShort)( ( scaled_w + 32 ) >> 6 );
+      metrics->y_ppem = (FT_UShort)( ( scaled_h + 32 ) >> 6 );
+
+      ft_recompute_scaled_metrics( face, metrics );
+    }
+    else
+    {
+      FT_ZERO( metrics );
+      metrics->x_scale = 1L << 16;
+      metrics->y_scale = 1L << 16;
+    }
+
+    FT_TRACE5(( "FT_Request_Metrics:\n" ));
+    FT_TRACE5(( "  x scale: %d (%f)\n",
+                metrics->x_scale, metrics->x_scale / 65536.0 ));
+    FT_TRACE5(( "  y scale: %d (%f)\n",
+                metrics->y_scale, metrics->y_scale / 65536.0 ));
+    FT_TRACE5(( "  ascender: %f\n",    metrics->ascender / 64.0 ));
+    FT_TRACE5(( "  descender: %f\n",   metrics->descender / 64.0 ));
+    FT_TRACE5(( "  height: %f\n",      metrics->height / 64.0 ));
+    FT_TRACE5(( "  max advance: %f\n", metrics->max_advance / 64.0 ));
+    FT_TRACE5(( "  x ppem: %d\n",      metrics->x_ppem ));
+    FT_TRACE5(( "  y ppem: %d\n",      metrics->y_ppem ));
+  }
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_Select_Size( FT_Face  face,
+                  FT_Int   strike_index )
+  {
+    FT_Driver_Class  clazz;
+
+
+    if ( !face || !FT_HAS_FIXED_SIZES( face ) )
+      return FT_THROW( Invalid_Face_Handle );
+
+    if ( strike_index < 0 || strike_index >= face->num_fixed_sizes )
+      return FT_THROW( Invalid_Argument );
+
+    clazz = face->driver->clazz;
+
+    if ( clazz->select_size )
+    {
+      FT_Error  error;
+
+
+      error = clazz->select_size( face->size, (FT_ULong)strike_index );
+
+#ifdef FT_DEBUG_LEVEL_TRACE
+      {
+        FT_Size_Metrics*  metrics = &face->size->metrics;
+
+
+        FT_TRACE5(( "FT_Select_Size (font driver's `select_size'):\n" ));
+        FT_TRACE5(( "  x scale: %d (%f)\n",
+                    metrics->x_scale, metrics->x_scale / 65536.0 ));
+        FT_TRACE5(( "  y scale: %d (%f)\n",
+                    metrics->y_scale, metrics->y_scale / 65536.0 ));
+        FT_TRACE5(( "  ascender: %f\n",    metrics->ascender / 64.0 ));
+        FT_TRACE5(( "  descender: %f\n",   metrics->descender / 64.0 ));
+        FT_TRACE5(( "  height: %f\n",      metrics->height / 64.0 ));
+        FT_TRACE5(( "  max advance: %f\n", metrics->max_advance / 64.0 ));
+        FT_TRACE5(( "  x ppem: %d\n",      metrics->x_ppem ));
+        FT_TRACE5(( "  y ppem: %d\n",      metrics->y_ppem ));
+      }
+#endif
+
+      return error;
+    }
+
+    FT_Select_Metrics( face, (FT_ULong)strike_index );
+
+    return FT_Err_Ok;
+  }
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_Request_Size( FT_Face          face,
+                   FT_Size_Request  req )
+  {
+    FT_Driver_Class  clazz;
+    FT_ULong         strike_index;
+
+
+    if ( !face )
+      return FT_THROW( Invalid_Face_Handle );
+
+    if ( !req || req->width < 0 || req->height < 0 ||
+         req->type >= FT_SIZE_REQUEST_TYPE_MAX )
+      return FT_THROW( Invalid_Argument );
+
+    clazz = face->driver->clazz;
+
+    if ( clazz->request_size )
+    {
+      FT_Error  error;
+
+
+      error = clazz->request_size( face->size, req );
+
+#ifdef FT_DEBUG_LEVEL_TRACE
+      {
+        FT_Size_Metrics*  metrics = &face->size->metrics;
+
+
+        FT_TRACE5(( "FT_Request_Size (font driver's `request_size'):\n" ));
+        FT_TRACE5(( "  x scale: %d (%f)\n",
+                    metrics->x_scale, metrics->x_scale / 65536.0 ));
+        FT_TRACE5(( "  y scale: %d (%f)\n",
+                    metrics->y_scale, metrics->y_scale / 65536.0 ));
+        FT_TRACE5(( "  ascender: %f\n",    metrics->ascender / 64.0 ));
+        FT_TRACE5(( "  descender: %f\n",   metrics->descender / 64.0 ));
+        FT_TRACE5(( "  height: %f\n",      metrics->height / 64.0 ));
+        FT_TRACE5(( "  max advance: %f\n", metrics->max_advance / 64.0 ));
+        FT_TRACE5(( "  x ppem: %d\n",      metrics->x_ppem ));
+        FT_TRACE5(( "  y ppem: %d\n",      metrics->y_ppem ));
+      }
+#endif
+
+      return error;
+    }
+
+    /*
+     * The reason that a driver doesn't have `request_size' defined is
+     * either that the scaling here suffices or that the supported formats
+     * are bitmap-only and size matching is not implemented.
+     *
+     * In the latter case, a simple size matching is done.
+     */
+    if ( !FT_IS_SCALABLE( face ) && FT_HAS_FIXED_SIZES( face ) )
+    {
+      FT_Error  error;
+
+
+      error = FT_Match_Size( face, req, 0, &strike_index );
+      if ( error )
+        return error;
+
+      return FT_Select_Size( face, (FT_Int)strike_index );
+    }
+
+    FT_Request_Metrics( face, req );
+
+    return FT_Err_Ok;
+  }
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_Set_Char_Size( FT_Face     face,
+                    FT_F26Dot6  char_width,
+                    FT_F26Dot6  char_height,
+                    FT_UInt     horz_resolution,
+                    FT_UInt     vert_resolution )
+  {
+    FT_Size_RequestRec  req;
+
+
+    /* check of `face' delayed to `FT_Request_Size' */
+
+    if ( !char_width )
+      char_width = char_height;
+    else if ( !char_height )
+      char_height = char_width;
+
+    if ( !horz_resolution )
+      horz_resolution = vert_resolution;
+    else if ( !vert_resolution )
+      vert_resolution = horz_resolution;
+
+    if ( char_width  < 1 * 64 )
+      char_width  = 1 * 64;
+    if ( char_height < 1 * 64 )
+      char_height = 1 * 64;
+
+    if ( !horz_resolution )
+      horz_resolution = vert_resolution = 72;
+
+    req.type           = FT_SIZE_REQUEST_TYPE_NOMINAL;
+    req.width          = char_width;
+    req.height         = char_height;
+    req.horiResolution = horz_resolution;
+    req.vertResolution = vert_resolution;
+
+    return FT_Request_Size( face, &req );
+  }
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_Set_Pixel_Sizes( FT_Face  face,
+                      FT_UInt  pixel_width,
+                      FT_UInt  pixel_height )
+  {
+    FT_Size_RequestRec  req;
+
+
+    /* check of `face' delayed to `FT_Request_Size' */
+
+    if ( pixel_width == 0 )
+      pixel_width = pixel_height;
+    else if ( pixel_height == 0 )
+      pixel_height = pixel_width;
+
+    if ( pixel_width  < 1 )
+      pixel_width  = 1;
+    if ( pixel_height < 1 )
+      pixel_height = 1;
+
+    /* use `>=' to avoid potential compiler warning on 16bit platforms */
+    if ( pixel_width >= 0xFFFFU )
+      pixel_width = 0xFFFFU;
+    if ( pixel_height >= 0xFFFFU )
+      pixel_height = 0xFFFFU;
+
+    req.type           = FT_SIZE_REQUEST_TYPE_NOMINAL;
+    req.width          = (FT_Long)( pixel_width << 6 );
+    req.height         = (FT_Long)( pixel_height << 6 );
+    req.horiResolution = 0;
+    req.vertResolution = 0;
+
+    return FT_Request_Size( face, &req );
+  }
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_Get_Kerning( FT_Face     face,
+                  FT_UInt     left_glyph,
+                  FT_UInt     right_glyph,
+                  FT_UInt     kern_mode,
+                  FT_Vector  *akerning )
+  {
+    FT_Error   error = FT_Err_Ok;
+    FT_Driver  driver;
+
+
+    if ( !face )
+      return FT_THROW( Invalid_Face_Handle );
+
+    if ( !akerning )
+      return FT_THROW( Invalid_Argument );
+
+    driver = face->driver;
+
+    akerning->x = 0;
+    akerning->y = 0;
+
+    if ( driver->clazz->get_kerning )
+    {
+      error = driver->clazz->get_kerning( face,
+                                          left_glyph,
+                                          right_glyph,
+                                          akerning );
+      if ( !error )
+      {
+        if ( kern_mode != FT_KERNING_UNSCALED )
+        {
+          akerning->x = FT_MulFix( akerning->x, face->size->metrics.x_scale );
+          akerning->y = FT_MulFix( akerning->y, face->size->metrics.y_scale );
+
+          if ( kern_mode != FT_KERNING_UNFITTED )
+          {
+            FT_Pos  orig_x = akerning->x;
+            FT_Pos  orig_y = akerning->y;
+
+
+            /* we scale down kerning values for small ppem values */
+            /* to avoid that rounding makes them too big.         */
+            /* `25' has been determined heuristically.            */
+            if ( face->size->metrics.x_ppem < 25 )
+              akerning->x = FT_MulDiv( orig_x,
+                                       face->size->metrics.x_ppem, 25 );
+            if ( face->size->metrics.y_ppem < 25 )
+              akerning->y = FT_MulDiv( orig_y,
+                                       face->size->metrics.y_ppem, 25 );
+
+            akerning->x = FT_PIX_ROUND( akerning->x );
+            akerning->y = FT_PIX_ROUND( akerning->y );
+
+#ifdef FT_DEBUG_LEVEL_TRACE
+            {
+              FT_Pos  orig_x_rounded = FT_PIX_ROUND( orig_x );
+              FT_Pos  orig_y_rounded = FT_PIX_ROUND( orig_y );
+
+
+              if ( akerning->x != orig_x_rounded ||
+                   akerning->y != orig_y_rounded )
+                FT_TRACE5(( "FT_Get_Kerning: horizontal kerning"
+                            " (%d, %d) scaled down to (%d, %d) pixels\n",
+                            orig_x_rounded / 64, orig_y_rounded / 64,
+                            akerning->x / 64, akerning->y / 64 ));
+            }
+#endif
+          }
+        }
+      }
+    }
+
+    return error;
+  }
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_Get_Track_Kerning( FT_Face    face,
+                        FT_Fixed   point_size,
+                        FT_Int     degree,
+                        FT_Fixed*  akerning )
+  {
+    FT_Service_Kerning  service;
+    FT_Error            error = FT_Err_Ok;
+
+
+    if ( !face )
+      return FT_THROW( Invalid_Face_Handle );
+
+    if ( !akerning )
+      return FT_THROW( Invalid_Argument );
+
+    FT_FACE_FIND_SERVICE( face, service, KERNING );
+    if ( !service )
+      return FT_THROW( Unimplemented_Feature );
+
+    error = service->get_track( face,
+                                point_size,
+                                degree,
+                                akerning );
+
+    return error;
+  }
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_Select_Charmap( FT_Face      face,
+                     FT_Encoding  encoding )
+  {
+    FT_CharMap*  cur;
+    FT_CharMap*  limit;
+
+
+    if ( !face )
+      return FT_THROW( Invalid_Face_Handle );
+
+    if ( encoding == FT_ENCODING_NONE )
+      return FT_THROW( Invalid_Argument );
+
+    /* FT_ENCODING_UNICODE is special.  We try to find the `best' Unicode */
+    /* charmap available, i.e., one with UCS-4 characters, if possible.   */
+    /*                                                                    */
+    /* This is done by find_unicode_charmap() above, to share code.       */
+    if ( encoding == FT_ENCODING_UNICODE )
+      return find_unicode_charmap( face );
+
+    cur = face->charmaps;
+    if ( !cur )
+      return FT_THROW( Invalid_CharMap_Handle );
+
+    limit = cur + face->num_charmaps;
+
+    for ( ; cur < limit; cur++ )
+    {
+      if ( cur[0]->encoding == encoding )
+      {
+        face->charmap = cur[0];
+        return 0;
+      }
+    }
+
+    return FT_THROW( Invalid_Argument );
+  }
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_Set_Charmap( FT_Face     face,
+                  FT_CharMap  charmap )
+  {
+    FT_CharMap*  cur;
+    FT_CharMap*  limit;
+
+
+    if ( !face )
+      return FT_THROW( Invalid_Face_Handle );
+
+    cur = face->charmaps;
+    if ( !cur || !charmap )
+      return FT_THROW( Invalid_CharMap_Handle );
+
+    if ( FT_Get_CMap_Format( charmap ) == 14 )
+      return FT_THROW( Invalid_Argument );
+
+    limit = cur + face->num_charmaps;
+
+    for ( ; cur < limit; cur++ )
+    {
+      if ( cur[0] == charmap )
+      {
+        face->charmap = cur[0];
+        return FT_Err_Ok;
+      }
+    }
+
+    return FT_THROW( Invalid_Argument );
+  }
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_Int )
+  FT_Get_Charmap_Index( FT_CharMap  charmap )
+  {
+    FT_Int  i;
+
+
+    if ( !charmap || !charmap->face )
+      return -1;
+
+    for ( i = 0; i < charmap->face->num_charmaps; i++ )
+      if ( charmap->face->charmaps[i] == charmap )
+        break;
+
+    FT_ASSERT( i < charmap->face->num_charmaps );
+
+    return i;
+  }
+
+
+  static void
+  ft_cmap_done_internal( FT_CMap  cmap )
+  {
+    FT_CMap_Class  clazz  = cmap->clazz;
+    FT_Face        face   = cmap->charmap.face;
+    FT_Memory      memory = FT_FACE_MEMORY( face );
+
+
+    if ( clazz->done )
+      clazz->done( cmap );
+
+    FT_FREE( cmap );
+  }
+
+
+  FT_BASE_DEF( void )
+  FT_CMap_Done( FT_CMap  cmap )
+  {
+    if ( cmap )
+    {
+      FT_Face    face   = cmap->charmap.face;
+      FT_Memory  memory = FT_FACE_MEMORY( face );
+      FT_Error   error;
+      FT_Int     i, j;
+
+
+      for ( i = 0; i < face->num_charmaps; i++ )
+      {
+        if ( (FT_CMap)face->charmaps[i] == cmap )
+        {
+          FT_CharMap  last_charmap = face->charmaps[face->num_charmaps - 1];
+
+
+          if ( FT_RENEW_ARRAY( face->charmaps,
+                               face->num_charmaps,
+                               face->num_charmaps - 1 ) )
+            return;
+
+          /* remove it from our list of charmaps */
+          for ( j = i + 1; j < face->num_charmaps; j++ )
+          {
+            if ( j == face->num_charmaps - 1 )
+              face->charmaps[j - 1] = last_charmap;
+            else
+              face->charmaps[j - 1] = face->charmaps[j];
+          }
+
+          face->num_charmaps--;
+
+          if ( (FT_CMap)face->charmap == cmap )
+            face->charmap = NULL;
+
+          ft_cmap_done_internal( cmap );
+
+          break;
+        }
+      }
+    }
+  }
+
+
+  FT_BASE_DEF( FT_Error )
+  FT_CMap_New( FT_CMap_Class  clazz,
+               FT_Pointer     init_data,
+               FT_CharMap     charmap,
+               FT_CMap       *acmap )
+  {
+    FT_Error   error = FT_Err_Ok;
+    FT_Face    face;
+    FT_Memory  memory;
+    FT_CMap    cmap = NULL;
+
+
+    if ( clazz == NULL || charmap == NULL || charmap->face == NULL )
+      return FT_THROW( Invalid_Argument );
+
+    face   = charmap->face;
+    memory = FT_FACE_MEMORY( face );
+
+    if ( !FT_ALLOC( cmap, clazz->size ) )
+    {
+      cmap->charmap = *charmap;
+      cmap->clazz   = clazz;
+
+      if ( clazz->init )
+      {
+        error = clazz->init( cmap, init_data );
+        if ( error )
+          goto Fail;
+      }
+
+      /* add it to our list of charmaps */
+      if ( FT_RENEW_ARRAY( face->charmaps,
+                           face->num_charmaps,
+                           face->num_charmaps + 1 ) )
+        goto Fail;
+
+      face->charmaps[face->num_charmaps++] = (FT_CharMap)cmap;
+    }
+
+  Exit:
+    if ( acmap )
+      *acmap = cmap;
+
+    return error;
+
+  Fail:
+    ft_cmap_done_internal( cmap );
+    cmap = NULL;
+    goto Exit;
+  }
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_UInt )
+  FT_Get_Char_Index( FT_Face   face,
+                     FT_ULong  charcode )
+  {
+    FT_UInt  result = 0;
+
+
+    if ( face && face->charmap )
+    {
+      FT_CMap  cmap = FT_CMAP( face->charmap );
+
+
+      if ( charcode > 0xFFFFFFFFUL )
+      {
+        FT_TRACE1(( "FT_Get_Char_Index: too large charcode" ));
+        FT_TRACE1(( " 0x%x is truncated\n", charcode ));
+      }
+
+      result = cmap->clazz->char_index( cmap, (FT_UInt32)charcode );
+      if ( result >= (FT_UInt)face->num_glyphs )
+        result = 0;
+    }
+
+    return result;
+  }
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_ULong )
+  FT_Get_First_Char( FT_Face   face,
+                     FT_UInt  *agindex )
+  {
+    FT_ULong  result = 0;
+    FT_UInt   gindex = 0;
+
+
+    /* only do something if we have a charmap, and we have glyphs at all */
+    if ( face && face->charmap && face->num_glyphs )
+    {
+      gindex = FT_Get_Char_Index( face, 0 );
+      if ( gindex == 0 )
+        result = FT_Get_Next_Char( face, 0, &gindex );
+    }
+
+    if ( agindex )
+      *agindex = gindex;
+
+    return result;
+  }
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_ULong )
+  FT_Get_Next_Char( FT_Face   face,
+                    FT_ULong  charcode,
+                    FT_UInt  *agindex )
+  {
+    FT_ULong  result = 0;
+    FT_UInt   gindex = 0;
+
+
+    if ( face && face->charmap && face->num_glyphs )
+    {
+      FT_UInt32  code = (FT_UInt32)charcode;
+      FT_CMap    cmap = FT_CMAP( face->charmap );
+
+
+      do
+      {
+        gindex = cmap->clazz->char_next( cmap, &code );
+
+      } while ( gindex >= (FT_UInt)face->num_glyphs );
+
+      result = ( gindex == 0 ) ? 0 : code;
+    }
+
+    if ( agindex )
+      *agindex = gindex;
+
+    return result;
+  }
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_UInt )
+  FT_Face_GetCharVariantIndex( FT_Face   face,
+                               FT_ULong  charcode,
+                               FT_ULong  variantSelector )
+  {
+    FT_UInt  result = 0;
+
+
+    if ( face                                           &&
+         face->charmap                                  &&
+         face->charmap->encoding == FT_ENCODING_UNICODE )
+    {
+      FT_CharMap  charmap = find_variant_selector_charmap( face );
+      FT_CMap     ucmap = FT_CMAP( face->charmap );
+
+
+      if ( charmap != NULL )
+      {
+        FT_CMap  vcmap = FT_CMAP( charmap );
+
+
+        if ( charcode > 0xFFFFFFFFUL )
+        {
+          FT_TRACE1(( "FT_Get_Char_Index: too large charcode" ));
+          FT_TRACE1(( " 0x%x is truncated\n", charcode ));
+        }
+        if ( variantSelector > 0xFFFFFFFFUL )
+        {
+          FT_TRACE1(( "FT_Get_Char_Index: too large variantSelector" ));
+          FT_TRACE1(( " 0x%x is truncated\n", variantSelector ));
+        }
+
+        result = vcmap->clazz->char_var_index( vcmap, ucmap,
+                                               (FT_UInt32)charcode,
+                                               (FT_UInt32)variantSelector );
+      }
+    }
+
+    return result;
+  }
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_Int )
+  FT_Face_GetCharVariantIsDefault( FT_Face   face,
+                                   FT_ULong  charcode,
+                                   FT_ULong  variantSelector )
+  {
+    FT_Int  result = -1;
+
+
+    if ( face )
+    {
+      FT_CharMap  charmap = find_variant_selector_charmap( face );
+
+
+      if ( charmap != NULL )
+      {
+        FT_CMap  vcmap = FT_CMAP( charmap );
+
+
+        if ( charcode > 0xFFFFFFFFUL )
+        {
+          FT_TRACE1(( "FT_Get_Char_Index: too large charcode" ));
+          FT_TRACE1(( " 0x%x is truncated\n", charcode ));
+        }
+        if ( variantSelector > 0xFFFFFFFFUL )
+        {
+          FT_TRACE1(( "FT_Get_Char_Index: too large variantSelector" ));
+          FT_TRACE1(( " 0x%x is truncated\n", variantSelector ));
+        }
+
+        result = vcmap->clazz->char_var_default( vcmap,
+                                                 (FT_UInt32)charcode,
+                                                 (FT_UInt32)variantSelector );
+      }
+    }
+
+    return result;
+  }
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_UInt32* )
+  FT_Face_GetVariantSelectors( FT_Face  face )
+  {
+    FT_UInt32  *result = NULL;
+
+
+    if ( face )
+    {
+      FT_CharMap  charmap = find_variant_selector_charmap( face );
+
+
+      if ( charmap != NULL )
+      {
+        FT_CMap    vcmap  = FT_CMAP( charmap );
+        FT_Memory  memory = FT_FACE_MEMORY( face );
+
+
+        result = vcmap->clazz->variant_list( vcmap, memory );
+      }
+    }
+
+    return result;
+  }
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_UInt32* )
+  FT_Face_GetVariantsOfChar( FT_Face   face,
+                             FT_ULong  charcode )
+  {
+    FT_UInt32  *result = NULL;
+
+
+    if ( face )
+    {
+      FT_CharMap  charmap = find_variant_selector_charmap( face );
+
+
+      if ( charmap != NULL )
+      {
+        FT_CMap    vcmap  = FT_CMAP( charmap );
+        FT_Memory  memory = FT_FACE_MEMORY( face );
+
+
+        if ( charcode > 0xFFFFFFFFUL )
+        {
+          FT_TRACE1(( "FT_Get_Char_Index: too large charcode" ));
+          FT_TRACE1(( " 0x%x is truncated\n", charcode ));
+        }
+
+        result = vcmap->clazz->charvariant_list( vcmap, memory,
+                                                 (FT_UInt32)charcode );
+      }
+    }
+    return result;
+  }
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_UInt32* )
+  FT_Face_GetCharsOfVariant( FT_Face   face,
+                             FT_ULong  variantSelector )
+  {
+    FT_UInt32  *result = NULL;
+
+
+    if ( face )
+    {
+      FT_CharMap  charmap = find_variant_selector_charmap( face );
+
+
+      if ( charmap != NULL )
+      {
+        FT_CMap    vcmap  = FT_CMAP( charmap );
+        FT_Memory  memory = FT_FACE_MEMORY( face );
+
+
+        if ( variantSelector > 0xFFFFFFFFUL )
+        {
+          FT_TRACE1(( "FT_Get_Char_Index: too large variantSelector" ));
+          FT_TRACE1(( " 0x%x is truncated\n", variantSelector ));
+        }
+
+        result = vcmap->clazz->variantchar_list( vcmap, memory,
+                                                 (FT_UInt32)variantSelector );
+      }
+    }
+
+    return result;
+  }
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_UInt )
+  FT_Get_Name_Index( FT_Face     face,
+                     FT_String*  glyph_name )
+  {
+    FT_UInt  result = 0;
+
+
+    if ( face                       &&
+         FT_HAS_GLYPH_NAMES( face ) &&
+         glyph_name                 )
+    {
+      FT_Service_GlyphDict  service;
+
+
+      FT_FACE_LOOKUP_SERVICE( face,
+                              service,
+                              GLYPH_DICT );
+
+      if ( service && service->name_index )
+        result = service->name_index( face, glyph_name );
+    }
+
+    return result;
+  }
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_Get_Glyph_Name( FT_Face     face,
+                     FT_UInt     glyph_index,
+                     FT_Pointer  buffer,
+                     FT_UInt     buffer_max )
+  {
+    FT_Error              error;
+    FT_Service_GlyphDict  service;
+
+
+    if ( !face )
+      return FT_THROW( Invalid_Face_Handle );
+
+    if ( !buffer || buffer_max == 0 )
+      return FT_THROW( Invalid_Argument );
+
+    /* clean up buffer */
+    ((FT_Byte*)buffer)[0] = '\0';
+
+    if ( (FT_Long)glyph_index >= face->num_glyphs )
+      return FT_THROW( Invalid_Glyph_Index );
+
+    if ( !FT_HAS_GLYPH_NAMES( face ) )
+      return FT_THROW( Invalid_Argument );
+
+    FT_FACE_LOOKUP_SERVICE( face, service, GLYPH_DICT );
+    if ( service && service->get_name )
+      error = service->get_name( face, glyph_index, buffer, buffer_max );
+    else
+      error = FT_THROW( Invalid_Argument );
+
+    return error;
+  }
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( const char* )
+  FT_Get_Postscript_Name( FT_Face  face )
+  {
+    const char*  result = NULL;
+
+
+    if ( !face )
+      goto Exit;
+
+    if ( !result )
+    {
+      FT_Service_PsFontName  service;
+
+
+      FT_FACE_LOOKUP_SERVICE( face,
+                              service,
+                              POSTSCRIPT_FONT_NAME );
+
+      if ( service && service->get_ps_font_name )
+        result = service->get_ps_font_name( face );
+    }
+
+  Exit:
+    return result;
+  }
+
+
+  /* documentation is in tttables.h */
+
+  FT_EXPORT_DEF( void* )
+  FT_Get_Sfnt_Table( FT_Face      face,
+                     FT_Sfnt_Tag  tag )
+  {
+    void*                  table = NULL;
+    FT_Service_SFNT_Table  service;
+
+
+    if ( face && FT_IS_SFNT( face ) )
+    {
+      FT_FACE_FIND_SERVICE( face, service, SFNT_TABLE );
+      if ( service != NULL )
+        table = service->get_table( face, tag );
+    }
+
+    return table;
+  }
+
+
+  /* documentation is in tttables.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_Load_Sfnt_Table( FT_Face    face,
+                      FT_ULong   tag,
+                      FT_Long    offset,
+                      FT_Byte*   buffer,
+                      FT_ULong*  length )
+  {
+    FT_Service_SFNT_Table  service;
+
+
+    if ( !face || !FT_IS_SFNT( face ) )
+      return FT_THROW( Invalid_Face_Handle );
+
+    FT_FACE_FIND_SERVICE( face, service, SFNT_TABLE );
+    if ( service == NULL )
+      return FT_THROW( Unimplemented_Feature );
+
+    return service->load_table( face, tag, offset, buffer, length );
+  }
+
+
+  /* documentation is in tttables.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_Sfnt_Table_Info( FT_Face    face,
+                      FT_UInt    table_index,
+                      FT_ULong  *tag,
+                      FT_ULong  *length )
+  {
+    FT_Service_SFNT_Table  service;
+    FT_ULong               offset;
+
+
+    /* test for valid `length' delayed to `service->table_info' */
+
+    if ( !face || !FT_IS_SFNT( face ) )
+      return FT_THROW( Invalid_Face_Handle );
+
+    FT_FACE_FIND_SERVICE( face, service, SFNT_TABLE );
+    if ( service == NULL )
+      return FT_THROW( Unimplemented_Feature );
+
+    return service->table_info( face, table_index, tag, &offset, length );
+  }
+
+
+  /* documentation is in tttables.h */
+
+  FT_EXPORT_DEF( FT_ULong )
+  FT_Get_CMap_Language_ID( FT_CharMap  charmap )
+  {
+    FT_Service_TTCMaps  service;
+    FT_Face             face;
+    TT_CMapInfo         cmap_info;
+
+
+    if ( !charmap || !charmap->face )
+      return 0;
+
+    face = charmap->face;
+    FT_FACE_FIND_SERVICE( face, service, TT_CMAP );
+    if ( service == NULL )
+      return 0;
+    if ( service->get_cmap_info( charmap, &cmap_info ))
+      return 0;
+
+    return cmap_info.language;
+  }
+
+
+  /* documentation is in tttables.h */
+
+  FT_EXPORT_DEF( FT_Long )
+  FT_Get_CMap_Format( FT_CharMap  charmap )
+  {
+    FT_Service_TTCMaps  service;
+    FT_Face             face;
+    TT_CMapInfo         cmap_info;
+
+
+    if ( !charmap || !charmap->face )
+      return -1;
+
+    face = charmap->face;
+    FT_FACE_FIND_SERVICE( face, service, TT_CMAP );
+    if ( service == NULL )
+      return -1;
+    if ( service->get_cmap_info( charmap, &cmap_info ))
+      return -1;
+
+    return cmap_info.format;
+  }
+
+
+  /* documentation is in ftsizes.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_Activate_Size( FT_Size  size )
+  {
+    FT_Face  face;
+
+
+    if ( !size )
+      return FT_THROW( Invalid_Size_Handle );
+
+    face = size->face;
+    if ( !face || !face->driver )
+      return FT_THROW( Invalid_Face_Handle );
+
+    /* we don't need anything more complex than that; all size objects */
+    /* are already listed by the face                                  */
+    face->size = size;
+
+    return FT_Err_Ok;
+  }
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****                                                                 ****/
+  /****                        R E N D E R E R S                        ****/
+  /****                                                                 ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+
+  /* lookup a renderer by glyph format in the library's list */
+  FT_BASE_DEF( FT_Renderer )
+  FT_Lookup_Renderer( FT_Library       library,
+                      FT_Glyph_Format  format,
+                      FT_ListNode*     node )
+  {
+    FT_ListNode  cur;
+    FT_Renderer  result = NULL;
+
+
+    if ( !library )
+      goto Exit;
+
+    cur = library->renderers.head;
+
+    if ( node )
+    {
+      if ( *node )
+        cur = (*node)->next;
+      *node = NULL;
+    }
+
+    while ( cur )
+    {
+      FT_Renderer  renderer = FT_RENDERER( cur->data );
+
+
+      if ( renderer->glyph_format == format )
+      {
+        if ( node )
+          *node = cur;
+
+        result = renderer;
+        break;
+      }
+      cur = cur->next;
+    }
+
+  Exit:
+    return result;
+  }
+
+
+  static FT_Renderer
+  ft_lookup_glyph_renderer( FT_GlyphSlot  slot )
+  {
+    FT_Face      face    = slot->face;
+    FT_Library   library = FT_FACE_LIBRARY( face );
+    FT_Renderer  result  = library->cur_renderer;
+
+
+    if ( !result || result->glyph_format != slot->format )
+      result = FT_Lookup_Renderer( library, slot->format, 0 );
+
+    return result;
+  }
+
+
+  static void
+  ft_set_current_renderer( FT_Library  library )
+  {
+    FT_Renderer  renderer;
+
+
+    renderer = FT_Lookup_Renderer( library, FT_GLYPH_FORMAT_OUTLINE, 0 );
+    library->cur_renderer = renderer;
+  }
+
+
+  static FT_Error
+  ft_add_renderer( FT_Module  module )
+  {
+    FT_Library   library = module->library;
+    FT_Memory    memory  = library->memory;
+    FT_Error     error;
+    FT_ListNode  node    = NULL;
+
+
+    if ( FT_NEW( node ) )
+      goto Exit;
+
+    {
+      FT_Renderer         render = FT_RENDERER( module );
+      FT_Renderer_Class*  clazz  = (FT_Renderer_Class*)module->clazz;
+
+
+      render->clazz        = clazz;
+      render->glyph_format = clazz->glyph_format;
+
+      /* allocate raster object if needed */
+      if ( clazz->glyph_format == FT_GLYPH_FORMAT_OUTLINE &&
+           clazz->raster_class->raster_new                )
+      {
+        error = clazz->raster_class->raster_new( memory, &render->raster );
+        if ( error )
+          goto Fail;
+
+        render->raster_render = clazz->raster_class->raster_render;
+        render->render        = clazz->render_glyph;
+      }
+
+      /* add to list */
+      node->data = module;
+      FT_List_Add( &library->renderers, node );
+
+      ft_set_current_renderer( library );
+    }
+
+  Fail:
+    if ( error )
+      FT_FREE( node );
+
+  Exit:
+    return error;
+  }
+
+
+  static void
+  ft_remove_renderer( FT_Module  module )
+  {
+    FT_Library   library;
+    FT_Memory    memory;
+    FT_ListNode  node;
+
+
+    library = module->library;
+    if ( !library )
+      return;
+
+    memory = library->memory;
+
+    node = FT_List_Find( &library->renderers, module );
+    if ( node )
+    {
+      FT_Renderer  render = FT_RENDERER( module );
+
+
+      /* release raster object, if any */
+      if ( render->clazz->glyph_format == FT_GLYPH_FORMAT_OUTLINE &&
+           render->raster                                         )
+        render->clazz->raster_class->raster_done( render->raster );
+
+      /* remove from list */
+      FT_List_Remove( &library->renderers, node );
+      FT_FREE( node );
+
+      ft_set_current_renderer( library );
+    }
+  }
+
+
+  /* documentation is in ftrender.h */
+
+  FT_EXPORT_DEF( FT_Renderer )
+  FT_Get_Renderer( FT_Library       library,
+                   FT_Glyph_Format  format )
+  {
+    /* test for valid `library' delayed to `FT_Lookup_Renderer' */
+
+    return FT_Lookup_Renderer( library, format, 0 );
+  }
+
+
+  /* documentation is in ftrender.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_Set_Renderer( FT_Library     library,
+                   FT_Renderer    renderer,
+                   FT_UInt        num_params,
+                   FT_Parameter*  parameters )
+  {
+    FT_ListNode  node;
+    FT_Error     error = FT_Err_Ok;
+
+    FT_Renderer_SetModeFunc  set_mode;
+
+
+    if ( !library )
+    {
+      error = FT_THROW( Invalid_Library_Handle );
+      goto Exit;
+    }
+
+    if ( !renderer )
+    {
+      error = FT_THROW( Invalid_Argument );
+      goto Exit;
+    }
+
+    if ( num_params > 0 && !parameters )
+    {
+      error = FT_THROW( Invalid_Argument );
+      goto Exit;
+    }
+
+    node = FT_List_Find( &library->renderers, renderer );
+    if ( !node )
+    {
+      error = FT_THROW( Invalid_Argument );
+      goto Exit;
+    }
+
+    FT_List_Up( &library->renderers, node );
+
+    if ( renderer->glyph_format == FT_GLYPH_FORMAT_OUTLINE )
+      library->cur_renderer = renderer;
+
+    set_mode = renderer->clazz->set_mode;
+
+    for ( ; num_params > 0; num_params-- )
+    {
+      error = set_mode( renderer, parameters->tag, parameters->data );
+      if ( error )
+        break;
+      parameters++;
+    }
+
+  Exit:
+    return error;
+  }
+
+
+  FT_BASE_DEF( FT_Error )
+  FT_Render_Glyph_Internal( FT_Library      library,
+                            FT_GlyphSlot    slot,
+                            FT_Render_Mode  render_mode )
+  {
+    FT_Error     error = FT_Err_Ok;
+    FT_Renderer  renderer;
+
+
+    /* if it is already a bitmap, no need to do anything */
+    switch ( slot->format )
+    {
+    case FT_GLYPH_FORMAT_BITMAP:   /* already a bitmap, don't do anything */
+      break;
+
+    default:
+      {
+        FT_ListNode  node = NULL;
+
+
+        /* small shortcut for the very common case */
+        if ( slot->format == FT_GLYPH_FORMAT_OUTLINE )
+        {
+          renderer = library->cur_renderer;
+          node     = library->renderers.head;
+        }
+        else
+          renderer = FT_Lookup_Renderer( library, slot->format, &node );
+
+        error = FT_ERR( Unimplemented_Feature );
+        while ( renderer )
+        {
+          error = renderer->render( renderer, slot, render_mode, NULL );
+          if ( !error                                   ||
+               FT_ERR_NEQ( error, Cannot_Render_Glyph ) )
+            break;
+
+          /* FT_Err_Cannot_Render_Glyph is returned if the render mode   */
+          /* is unsupported by the current renderer for this glyph image */
+          /* format.                                                     */
+
+          /* now, look for another renderer that supports the same */
+          /* format.                                               */
+          renderer = FT_Lookup_Renderer( library, slot->format, &node );
+        }
+      }
+    }
+
+#ifdef FT_DEBUG_LEVEL_TRACE
+
+#undef  FT_COMPONENT
+#define FT_COMPONENT  trace_bitmap
+
+    /*
+     * Computing the MD5 checksum is expensive, unnecessarily distorting a
+     * possible profiling of FreeType if compiled with tracing support.  For
+     * this reason, we execute the following code only if explicitly
+     * requested.
+     */
+
+    /* we use FT_TRACE3 in this block */
+    if ( ft_trace_levels[trace_bitmap] >= 3 )
+    {
+      /* we convert to a single bitmap format for computing the checksum */
+      if ( !error )
+      {
+        FT_Bitmap  bitmap;
+        FT_Error   err;
+
+
+        FT_Bitmap_Init( &bitmap );
+
+        /* this also converts the bitmap flow to `down' (i.e., pitch > 0) */
+        err = FT_Bitmap_Convert( library, &slot->bitmap, &bitmap, 1 );
+        if ( !err )
+        {
+          MD5_CTX        ctx;
+          unsigned char  md5[16];
+          int            i;
+          unsigned int   rows  = bitmap.rows;
+          unsigned int   pitch = (unsigned int)bitmap.pitch;
+
+
+          MD5_Init( &ctx );
+          if ( bitmap.buffer )
+            MD5_Update( &ctx, bitmap.buffer, rows * pitch );
+          MD5_Final( md5, &ctx );
+
+          FT_TRACE3(( "MD5 checksum for %dx%d bitmap:\n"
+                      "  ",
+                      rows, pitch ));
+          for ( i = 0; i < 16; i++ )
+            FT_TRACE3(( "%02X", md5[i] ));
+          FT_TRACE3(( "\n" ));
+        }
+
+        FT_Bitmap_Done( library, &bitmap );
+      }
+    }
+
+#undef  FT_COMPONENT
+#define FT_COMPONENT  trace_objs
+
+#endif /* FT_DEBUG_LEVEL_TRACE */
+
+    return error;
+  }
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_Render_Glyph( FT_GlyphSlot    slot,
+                   FT_Render_Mode  render_mode )
+  {
+    FT_Library  library;
+
+
+    if ( !slot || !slot->face )
+      return FT_THROW( Invalid_Argument );
+
+    library = FT_FACE_LIBRARY( slot->face );
+
+    return FT_Render_Glyph_Internal( library, slot, render_mode );
+  }
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****                                                                 ****/
+  /****                         M O D U L E S                           ****/
+  /****                                                                 ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    Destroy_Module                                                     */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Destroys a given module object.  For drivers, this also destroys   */
+  /*    all child faces.                                                   */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    module :: A handle to the target driver object.                    */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The driver _must_ be LOCKED!                                       */
+  /*                                                                       */
+  static void
+  Destroy_Module( FT_Module  module )
+  {
+    FT_Memory         memory  = module->memory;
+    FT_Module_Class*  clazz   = module->clazz;
+    FT_Library        library = module->library;
+
+
+    if ( library && library->auto_hinter == module )
+      library->auto_hinter = NULL;
+
+    /* if the module is a renderer */
+    if ( FT_MODULE_IS_RENDERER( module ) )
+      ft_remove_renderer( module );
+
+    /* if the module is a font driver, add some steps */
+    if ( FT_MODULE_IS_DRIVER( module ) )
+      Destroy_Driver( FT_DRIVER( module ) );
+
+    /* finalize the module object */
+    if ( clazz->module_done )
+      clazz->module_done( module );
+
+    /* discard it */
+    FT_FREE( module );
+  }
+
+
+  /* documentation is in ftmodapi.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_Add_Module( FT_Library              library,
+                 const FT_Module_Class*  clazz )
+  {
+    FT_Error   error;
+    FT_Memory  memory;
+    FT_Module  module = NULL;
+    FT_UInt    nn;
+
+
+#define FREETYPE_VER_FIXED  ( ( (FT_Long)FREETYPE_MAJOR << 16 ) | \
+                                FREETYPE_MINOR                  )
+
+    if ( !library )
+      return FT_THROW( Invalid_Library_Handle );
+
+    if ( !clazz )
+      return FT_THROW( Invalid_Argument );
+
+    /* check freetype version */
+    if ( clazz->module_requires > FREETYPE_VER_FIXED )
+      return FT_THROW( Invalid_Version );
+
+    /* look for a module with the same name in the library's table */
+    for ( nn = 0; nn < library->num_modules; nn++ )
+    {
+      module = library->modules[nn];
+      if ( ft_strcmp( module->clazz->module_name, clazz->module_name ) == 0 )
+      {
+        /* this installed module has the same name, compare their versions */
+        if ( clazz->module_version <= module->clazz->module_version )
+          return FT_THROW( Lower_Module_Version );
+
+        /* remove the module from our list, then exit the loop to replace */
+        /* it by our new version..                                        */
+        FT_Remove_Module( library, module );
+        break;
+      }
+    }
+
+    memory = library->memory;
+    error  = FT_Err_Ok;
+
+    if ( library->num_modules >= FT_MAX_MODULES )
+    {
+      error = FT_THROW( Too_Many_Drivers );
+      goto Exit;
+    }
+
+    /* allocate module object */
+    if ( FT_ALLOC( module, clazz->module_size ) )
+      goto Exit;
+
+    /* base initialization */
+    module->library = library;
+    module->memory  = memory;
+    module->clazz   = (FT_Module_Class*)clazz;
+
+    /* check whether the module is a renderer - this must be performed */
+    /* before the normal module initialization                         */
+    if ( FT_MODULE_IS_RENDERER( module ) )
+    {
+      /* add to the renderers list */
+      error = ft_add_renderer( module );
+      if ( error )
+        goto Fail;
+    }
+
+    /* is the module a auto-hinter? */
+    if ( FT_MODULE_IS_HINTER( module ) )
+      library->auto_hinter = module;
+
+    /* if the module is a font driver */
+    if ( FT_MODULE_IS_DRIVER( module ) )
+    {
+      FT_Driver  driver = FT_DRIVER( module );
+
+
+      driver->clazz = (FT_Driver_Class)module->clazz;
+    }
+
+    if ( clazz->module_init )
+    {
+      error = clazz->module_init( module );
+      if ( error )
+        goto Fail;
+    }
+
+    /* add module to the library's table */
+    library->modules[library->num_modules++] = module;
+
+  Exit:
+    return error;
+
+  Fail:
+    if ( FT_MODULE_IS_RENDERER( module ) )
+    {
+      FT_Renderer  renderer = FT_RENDERER( module );
+
+
+      if ( renderer->clazz                                          &&
+           renderer->clazz->glyph_format == FT_GLYPH_FORMAT_OUTLINE &&
+           renderer->raster                                         )
+        renderer->clazz->raster_class->raster_done( renderer->raster );
+    }
+
+    FT_FREE( module );
+    goto Exit;
+  }
+
+
+  /* documentation is in ftmodapi.h */
+
+  FT_EXPORT_DEF( FT_Module )
+  FT_Get_Module( FT_Library   library,
+                 const char*  module_name )
+  {
+    FT_Module   result = NULL;
+    FT_Module*  cur;
+    FT_Module*  limit;
+
+
+    if ( !library || !module_name )
+      return result;
+
+    cur   = library->modules;
+    limit = cur + library->num_modules;
+
+    for ( ; cur < limit; cur++ )
+      if ( ft_strcmp( cur[0]->clazz->module_name, module_name ) == 0 )
+      {
+        result = cur[0];
+        break;
+      }
+
+    return result;
+  }
+
+
+  /* documentation is in ftobjs.h */
+
+  FT_BASE_DEF( const void* )
+  FT_Get_Module_Interface( FT_Library   library,
+                           const char*  mod_name )
+  {
+    FT_Module  module;
+
+
+    /* test for valid `library' delayed to FT_Get_Module() */
+
+    module = FT_Get_Module( library, mod_name );
+
+    return module ? module->clazz->module_interface : 0;
+  }
+
+
+  FT_BASE_DEF( FT_Pointer )
+  ft_module_get_service( FT_Module    module,
+                         const char*  service_id )
+  {
+    FT_Pointer  result = NULL;
+
+
+    if ( module )
+    {
+      FT_ASSERT( module->clazz && module->clazz->get_interface );
+
+      /* first, look for the service in the module */
+      if ( module->clazz->get_interface )
+        result = module->clazz->get_interface( module, service_id );
+
+      if ( result == NULL )
+      {
+        /* we didn't find it, look in all other modules then */
+        FT_Library  library = module->library;
+        FT_Module*  cur     = library->modules;
+        FT_Module*  limit   = cur + library->num_modules;
+
+
+        for ( ; cur < limit; cur++ )
+        {
+          if ( cur[0] != module )
+          {
+            FT_ASSERT( cur[0]->clazz );
+
+            if ( cur[0]->clazz->get_interface )
+            {
+              result = cur[0]->clazz->get_interface( cur[0], service_id );
+              if ( result != NULL )
+                break;
+            }
+          }
+        }
+      }
+    }
+
+    return result;
+  }
+
+
+  /* documentation is in ftmodapi.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_Remove_Module( FT_Library  library,
+                    FT_Module   module )
+  {
+    /* try to find the module from the table, then remove it from there */
+
+    if ( !library )
+      return FT_THROW( Invalid_Library_Handle );
+
+    if ( module )
+    {
+      FT_Module*  cur   = library->modules;
+      FT_Module*  limit = cur + library->num_modules;
+
+
+      for ( ; cur < limit; cur++ )
+      {
+        if ( cur[0] == module )
+        {
+          /* remove it from the table */
+          library->num_modules--;
+          limit--;
+          while ( cur < limit )
+          {
+            cur[0] = cur[1];
+            cur++;
+          }
+          limit[0] = NULL;
+
+          /* destroy the module */
+          Destroy_Module( module );
+
+          return FT_Err_Ok;
+        }
+      }
+    }
+    return FT_THROW( Invalid_Driver_Handle );
+  }
+
+
+  static FT_Error
+  ft_property_do( FT_Library        library,
+                  const FT_String*  module_name,
+                  const FT_String*  property_name,
+                  void*             value,
+                  FT_Bool           set,
+                  FT_Bool           value_is_string )
+  {
+    FT_Module*           cur;
+    FT_Module*           limit;
+    FT_Module_Interface  interface;
+
+    FT_Service_Properties  service;
+
+#ifdef FT_DEBUG_LEVEL_ERROR
+    const FT_String*  set_name  = "FT_Property_Set";
+    const FT_String*  get_name  = "FT_Property_Get";
+    const FT_String*  func_name = set ? set_name : get_name;
+#endif
+
+    FT_Bool  missing_func;
+
+
+    if ( !library )
+      return FT_THROW( Invalid_Library_Handle );
+
+    if ( !module_name || !property_name || !value )
+      return FT_THROW( Invalid_Argument );
+
+    cur   = library->modules;
+    limit = cur + library->num_modules;
+
+    /* search module */
+    for ( ; cur < limit; cur++ )
+      if ( !ft_strcmp( cur[0]->clazz->module_name, module_name ) )
+        break;
+
+    if ( cur == limit )
+    {
+      FT_ERROR(( "%s: can't find module `%s'\n",
+                 func_name, module_name ));
+      return FT_THROW( Missing_Module );
+    }
+
+    /* check whether we have a service interface */
+    if ( !cur[0]->clazz->get_interface )
+    {
+      FT_ERROR(( "%s: module `%s' doesn't support properties\n",
+                 func_name, module_name ));
+      return FT_THROW( Unimplemented_Feature );
+    }
+
+    /* search property service */
+    interface = cur[0]->clazz->get_interface( cur[0],
+                                              FT_SERVICE_ID_PROPERTIES );
+    if ( !interface )
+    {
+      FT_ERROR(( "%s: module `%s' doesn't support properties\n",
+                 func_name, module_name ));
+      return FT_THROW( Unimplemented_Feature );
+    }
+
+    service = (FT_Service_Properties)interface;
+
+    if ( set )
+      missing_func = (FT_Bool)( !service->set_property );
+    else
+      missing_func = (FT_Bool)( !service->get_property );
+
+    if ( missing_func )
+    {
+      FT_ERROR(( "%s: property service of module `%s' is broken\n",
+                 func_name, module_name ));
+      return FT_THROW( Unimplemented_Feature );
+    }
+
+    return set ? service->set_property( cur[0],
+                                        property_name,
+                                        value,
+                                        value_is_string )
+               : service->get_property( cur[0],
+                                        property_name,
+                                        value );
+  }
+
+
+  /* documentation is in ftmodapi.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_Property_Set( FT_Library        library,
+                   const FT_String*  module_name,
+                   const FT_String*  property_name,
+                   const void*       value )
+  {
+    return ft_property_do( library,
+                           module_name,
+                           property_name,
+                           (void*)value,
+                           TRUE,
+                           FALSE );
+  }
+
+
+  /* documentation is in ftmodapi.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_Property_Get( FT_Library        library,
+                   const FT_String*  module_name,
+                   const FT_String*  property_name,
+                   void*             value )
+  {
+    return ft_property_do( library,
+                           module_name,
+                           property_name,
+                           value,
+                           FALSE,
+                           FALSE );
+  }
+
+
+#ifdef FT_CONFIG_OPTION_ENVIRONMENT_PROPERTIES
+
+  /* this variant is used for handling the FREETYPE_PROPERTIES */
+  /* environment variable                                      */
+
+  FT_BASE_DEF( FT_Error )
+  ft_property_string_set( FT_Library        library,
+                          const FT_String*  module_name,
+                          const FT_String*  property_name,
+                          FT_String*        value )
+  {
+    return ft_property_do( library,
+                           module_name,
+                           property_name,
+                           (void*)value,
+                           TRUE,
+                           TRUE );
+  }
+
+#endif
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****                                                                 ****/
+  /****                         L I B R A R Y                           ****/
+  /****                                                                 ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /* documentation is in ftmodapi.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_Reference_Library( FT_Library  library )
+  {
+    if ( !library )
+      return FT_THROW( Invalid_Library_Handle );
+
+    library->refcount++;
+
+    return FT_Err_Ok;
+  }
+
+
+  /* documentation is in ftmodapi.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_New_Library( FT_Memory    memory,
+                  FT_Library  *alibrary )
+  {
+    FT_Library  library = NULL;
+    FT_Error    error;
+
+
+    if ( !memory || !alibrary )
+      return FT_THROW( Invalid_Argument );
+
+#ifdef FT_DEBUG_LEVEL_ERROR
+    /* init debugging support */
+    ft_debug_init();
+#endif
+
+    /* first of all, allocate the library object */
+    if ( FT_NEW( library ) )
+      return error;
+
+    library->memory = memory;
+
+#ifdef FT_CONFIG_OPTION_PIC
+    /* initialize position independent code containers */
+    error = ft_pic_container_init( library );
+    if ( error )
+      goto Fail;
+#endif
+
+    /* we don't use raster_pool anymore. */
+    library->raster_pool_size = 0;
+    library->raster_pool      = NULL;
+
+    library->version_major = FREETYPE_MAJOR;
+    library->version_minor = FREETYPE_MINOR;
+    library->version_patch = FREETYPE_PATCH;
+
+    library->refcount = 1;
+
+    /* That's ok now */
+    *alibrary = library;
+
+    return FT_Err_Ok;
+
+#ifdef FT_CONFIG_OPTION_PIC
+  Fail:
+    ft_pic_container_destroy( library );
+#endif
+    FT_FREE( library );
+    return error;
+  }
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( void )
+  FT_Library_Version( FT_Library   library,
+                      FT_Int      *amajor,
+                      FT_Int      *aminor,
+                      FT_Int      *apatch )
+  {
+    FT_Int  major = 0;
+    FT_Int  minor = 0;
+    FT_Int  patch = 0;
+
+
+    if ( library )
+    {
+      major = library->version_major;
+      minor = library->version_minor;
+      patch = library->version_patch;
+    }
+
+    if ( amajor )
+      *amajor = major;
+
+    if ( aminor )
+      *aminor = minor;
+
+    if ( apatch )
+      *apatch = patch;
+  }
+
+
+  /* documentation is in ftmodapi.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_Done_Library( FT_Library  library )
+  {
+    FT_Memory  memory;
+
+
+    if ( !library )
+      return FT_THROW( Invalid_Library_Handle );
+
+    library->refcount--;
+    if ( library->refcount > 0 )
+      goto Exit;
+
+    memory = library->memory;
+
+    /*
+     * Close all faces in the library.  If we don't do this, we can have
+     * some subtle memory leaks.
+     *
+     * Example:
+     *
+     *  - the cff font driver uses the pshinter module in cff_size_done
+     *  - if the pshinter module is destroyed before the cff font driver,
+     *    opened FT_Face objects managed by the driver are not properly
+     *    destroyed, resulting in a memory leak
+     *
+     * Some faces are dependent on other faces, like Type42 faces that
+     * depend on TrueType faces synthesized internally.
+     *
+     * The order of drivers should be specified in driver_name[].
+     */
+    {
+      FT_UInt      m, n;
+      const char*  driver_name[] = { "type42", NULL };
+
+
+      for ( m = 0;
+            m < sizeof ( driver_name ) / sizeof ( driver_name[0] );
+            m++ )
+      {
+        for ( n = 0; n < library->num_modules; n++ )
+        {
+          FT_Module    module      = library->modules[n];
+          const char*  module_name = module->clazz->module_name;
+          FT_List      faces;
+
+
+          if ( driver_name[m]                                &&
+               ft_strcmp( module_name, driver_name[m] ) != 0 )
+            continue;
+
+          if ( ( module->clazz->module_flags & FT_MODULE_FONT_DRIVER ) == 0 )
+            continue;
+
+          FT_TRACE7(( "FT_Done_Library: close faces for %s\n", module_name ));
+
+          faces = &FT_DRIVER( module )->faces_list;
+          while ( faces->head )
+          {
+            FT_Done_Face( FT_FACE( faces->head->data ) );
+            if ( faces->head )
+              FT_TRACE0(( "FT_Done_Library: failed to free some faces\n" ));
+          }
+        }
+      }
+    }
+
+    /* Close all other modules in the library */
+#if 1
+    /* XXX Modules are removed in the reversed order so that  */
+    /* type42 module is removed before truetype module.  This */
+    /* avoids double free in some occasions.  It is a hack.   */
+    while ( library->num_modules > 0 )
+      FT_Remove_Module( library,
+                        library->modules[library->num_modules - 1] );
+#else
+    {
+      FT_UInt  n;
+
+
+      for ( n = 0; n < library->num_modules; n++ )
+      {
+        FT_Module  module = library->modules[n];
+
+
+        if ( module )
+        {
+          Destroy_Module( module );
+          library->modules[n] = NULL;
+        }
+      }
+    }
+#endif
+
+#ifdef FT_CONFIG_OPTION_PIC
+    /* Destroy pic container contents */
+    ft_pic_container_destroy( library );
+#endif
+
+    FT_FREE( library );
+
+  Exit:
+    return FT_Err_Ok;
+  }
+
+
+  /* documentation is in ftmodapi.h */
+
+  FT_EXPORT_DEF( void )
+  FT_Set_Debug_Hook( FT_Library         library,
+                     FT_UInt            hook_index,
+                     FT_DebugHook_Func  debug_hook )
+  {
+    if ( library && debug_hook &&
+         hook_index <
+           ( sizeof ( library->debug_hooks ) / sizeof ( void* ) ) )
+      library->debug_hooks[hook_index] = debug_hook;
+  }
+
+
+  /* documentation is in ftmodapi.h */
+
+  FT_EXPORT_DEF( FT_TrueTypeEngineType )
+  FT_Get_TrueType_Engine_Type( FT_Library  library )
+  {
+    FT_TrueTypeEngineType  result = FT_TRUETYPE_ENGINE_TYPE_NONE;
+
+
+    if ( library )
+    {
+      FT_Module  module = FT_Get_Module( library, "truetype" );
+
+
+      if ( module )
+      {
+        FT_Service_TrueTypeEngine  service;
+
+
+        service = (FT_Service_TrueTypeEngine)
+                    ft_module_get_service( module,
+                                           FT_SERVICE_ID_TRUETYPE_ENGINE );
+        if ( service )
+          result = service->engine_type;
+      }
+    }
+
+    return result;
+  }
+
+
+  /* documentation is in freetype.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  FT_Get_SubGlyph_Info( FT_GlyphSlot  glyph,
+                        FT_UInt       sub_index,
+                        FT_Int       *p_index,
+                        FT_UInt      *p_flags,
+                        FT_Int       *p_arg1,
+                        FT_Int       *p_arg2,
+                        FT_Matrix    *p_transform )
+  {
+    FT_Error  error = FT_ERR( Invalid_Argument );
+
+
+    if ( glyph                                      &&
+         glyph->subglyphs                           &&
+         glyph->format == FT_GLYPH_FORMAT_COMPOSITE &&
+         sub_index < glyph->num_subglyphs           )
+    {
+      FT_SubGlyph  subg = glyph->subglyphs + sub_index;
+
+
+      *p_index     = subg->index;
+      *p_flags     = subg->flags;
+      *p_arg1      = subg->arg1;
+      *p_arg2      = subg->arg2;
+      *p_transform = subg->transform;
+
+      error = FT_Err_Ok;
+    }
+
+    return error;
+  }
+
+
+/* END */
diff -ruN freetype-2.7-orig/src/base/ftoutln.c freetype-2.7/src/base/ftoutln.c
--- freetype-2.7-orig/src/base/ftoutln.c	2016-08-26 11:12:02.000000000 +0200
+++ freetype-2.7/src/base/ftoutln.c	2016-09-09 16:01:22.465167416 +0200
@@ -29,7 +29,9 @@
 #include FT_INTERNAL_CALC_H
 #include FT_INTERNAL_DEBUG_H
 #include FT_TRIGONOMETRY_H
-
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+#include "ftinf.h"
+#endif
 
   /*************************************************************************/
   /*                                                                       */
@@ -913,7 +915,13 @@
     FT_Vector*  points;
     FT_Int      c, first, last;
     FT_Int      orientation;
-
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    FT_Bool use_various_tweaks = FALSE;
+    if( ftinf ) use_various_tweaks=ftinf->use_various_tweaks;
+
+    if ( use_various_tweaks )
+      ystrength = FT_PIX_FLOOR ( ystrength );
+#endif
 
     if ( !outline )
       return FT_THROW( Invalid_Outline );
diff -ruN freetype-2.7-orig/src/base/ftsynth.c freetype-2.7/src/base/ftsynth.c
--- freetype-2.7-orig/src/base/ftsynth.c	2016-02-03 19:13:58.000000000 +0100
+++ freetype-2.7/src/base/ftsynth.c	2016-09-09 16:01:22.465167416 +0200
@@ -22,7 +22,9 @@
 #include FT_INTERNAL_OBJECTS_H
 #include FT_OUTLINE_H
 #include FT_BITMAP_H
-
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+#include "ftinf.h"
+#endif
 
   /*************************************************************************/
   /*                                                                       */
@@ -93,7 +95,10 @@
     FT_Face     face;
     FT_Error    error;
     FT_Pos      xstr, ystr;
-
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    FT_Bool use_various_tweaks = FALSE;
+    if( ftinf ) use_various_tweaks=ftinf->use_various_tweaks;
+#endif
 
     if ( !slot )
       return;
@@ -111,8 +116,16 @@
     ystr = xstr;
 
     if ( slot->format == FT_GLYPH_FORMAT_OUTLINE )
+    {
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+      if ( use_various_tweaks )
+        (void)FT_Outline_EmboldenXY( &slot->outline,
+                                     xstr,
+                                     FT_PIX_FLOOR( ystr ) );
+      else
+#endif
       FT_Outline_EmboldenXY( &slot->outline, xstr, ystr );
-
+    }
     else /* slot->format == FT_GLYPH_FORMAT_BITMAP */
     {
       /* round to full pixels */
@@ -150,6 +163,9 @@
 
     slot->metrics.width        += xstr;
     slot->metrics.height       += ystr;
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    if ( !use_various_tweaks )
+#endif
     slot->metrics.horiAdvance  += xstr;
     slot->metrics.vertAdvance  += ystr;
     slot->metrics.horiBearingY += ystr;
diff -ruN freetype-2.7-orig/src/base/Jamfile freetype-2.7/src/base/Jamfile
--- freetype-2.7-orig/src/base/Jamfile	2016-02-03 19:13:58.000000000 +0100
+++ freetype-2.7/src/base/Jamfile	2016-09-09 16:01:22.465167416 +0200
@@ -56,6 +56,7 @@
                     ftglyph
                     ftgxval
                     ftinit
+                    ftinf
                     ftlcdfil
                     ftmm
                     ftotval
diff -ruN freetype-2.7-orig/src/base/rules.mk freetype-2.7/src/base/rules.mk
--- freetype-2.7-orig/src/base/rules.mk	2016-02-03 19:13:58.000000000 +0100
+++ freetype-2.7/src/base/rules.mk	2016-09-09 16:01:22.465167416 +0200
@@ -42,6 +42,7 @@
             $(BASE_DIR)/ftdbgmem.c \
             $(BASE_DIR)/ftgloadr.c \
             $(BASE_DIR)/fthash.c   \
+            $(BASE_DIR)/ftinf.c    \
             $(BASE_DIR)/ftobjs.c   \
             $(BASE_DIR)/ftoutln.c  \
             $(BASE_DIR)/ftpic.c    \
diff -ruN freetype-2.7-orig/src/cff/cffobjs.c freetype-2.7/src/cff/cffobjs.c
--- freetype-2.7-orig/src/cff/cffobjs.c	2016-08-26 11:45:36.000000000 +0200
+++ freetype-2.7/src/cff/cffobjs.c	2016-09-09 16:01:22.465167416 +0200
@@ -34,6 +34,9 @@
 
 #include "cfferrs.h"
 
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+#include "../base/ftinf.h"
+#endif
 
   /*************************************************************************/
   /*                                                                       */
@@ -1096,6 +1099,9 @@
 #endif
 
     driver->no_stem_darkening = TRUE;
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    if(ftinf) driver->no_stem_darkening = !ftinf->stem_darkening_cff;
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
 
     driver->darken_params[0] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1;
     driver->darken_params[1] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y1;
diff -ruN freetype-2.7-orig/src/smooth/ftsmooth.c freetype-2.7/src/smooth/ftsmooth.c
--- freetype-2.7-orig/src/smooth/ftsmooth.c	2016-02-03 19:13:58.000000000 +0100
+++ freetype-2.7/src/smooth/ftsmooth.c	2016-09-09 16:01:22.468500777 +0200
@@ -26,6 +26,18 @@
 
 #include "ftsmerrs.h"
 
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+#include <math.h>
+#include FT_BITMAP_H
+#include <string.h>
+#include <strings.h>
+#include FT_OUTLINE_H
+#include "../base/ftinf.h"
+
+#define verbose FALSE
+#define STVALUES if (verbose) \
+  printf ( "scale:%f translate:%ld ", *scale_value, *translate_value );
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
 
   /* initialize renderer -- init its raster */
   static FT_Error
@@ -93,6 +105,2219 @@
       FT_Outline_Get_CBox( &slot->outline, cbox );
   }
 
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+  static FT_Fixed FT_FixedFromFloat(float f)
+  {
+    short          value = f;
+    unsigned short fract = (f - value) * 0xFFFF;
+
+
+    return (FT_Fixed)((long)value << 16 | (unsigned long)fract );
+  }
+
+
+  /* ChromeOS sharpening algorithm */
+  /* soften the sub-pixel anti-aliasing and sharpen */
+  static void
+  _ft_lcd_chromeos_sharpen( FT_Bitmap*  bitmap,
+                        FT_Render_Mode  mode,
+                        FT_Byte         cutoff,
+                        double          gamma_value )
+  {
+    static FT_Bool        initialized_gamma = FALSE;
+    static unsigned short gamma_ramp[256];
+    FT_UInt               width  = (FT_UInt)bitmap->width;
+    FT_UInt               height = (FT_UInt)bitmap->rows;
+    int    ii;
+
+    if ( !initialized_gamma )
+    {
+      initialized_gamma = TRUE;
+      /* linear to voltage */
+      for ( ii = 0; ii < 256; ii++ )
+      {
+        gamma_ramp[ii] = (unsigned char)
+                         ( pow( (double)ii / 255.0, gamma_value ) * 255.0f );
+        if ( gamma_ramp[ii] < cutoff )
+          gamma_ramp[ii] = 0;
+      }
+    }
+
+    /* horizontal in-place sub-pixel sharpening filter */
+    if ( mode == FT_RENDER_MODE_LCD )
+    {
+      FT_Byte*  line = bitmap->buffer;
+
+
+      for ( ; height > 0; height--, line += bitmap->pitch )
+      {
+        FT_UInt  xx;
+
+
+        for ( xx = 0; xx < width; xx++ )
+          line[xx] = gamma_ramp[line[xx]];
+      }
+    }
+  }
+
+  /* simple linear scale to handle various sliding values */
+  float
+  sliding_scale ( int            min_value,
+                      int        max_value,
+                      float      min_amount,
+                      float      max_amount,
+                      int        cur_value )
+  {
+
+    float m = ( min_amount - max_amount ) / (float)( min_value - max_value );
+    float result = ( ( (float)cur_value * m) + ( max_amount - max_value * m ) ) ;
+
+    if ( min_amount < max_amount )
+    {
+      if ( result < min_amount )
+        return min_amount;
+      if ( result > max_amount )
+        return max_amount;
+    }
+    else
+    {
+      if ( result < max_amount )
+        return max_amount;
+      if ( result > min_amount )
+        return min_amount;
+    }
+
+    return result;
+  }
+
+
+  /* brightness and contrast adjustment on the bitmap */
+  static FT_Bool
+  _ft_bitmap_bc  ( FT_Bitmap*       bitmap,
+                      float         brightness,
+                      float         contrast )
+  {
+
+    FT_UInt   width   = (FT_UInt)bitmap->width;
+    FT_UInt   height  = (FT_UInt)bitmap->rows;
+    FT_Byte*  line    = bitmap->buffer;
+    FT_UInt   xx;
+
+
+    if ( brightness == 0 && contrast == 0 )
+      return FALSE;
+
+    for ( height = (FT_UInt)bitmap->rows;
+          height > 0;
+          height--, line += bitmap->pitch )
+    {
+      for ( xx = 0; xx < width - 1; xx += 1 )
+      {
+        if ( line[xx] > 0)
+        {
+          float  value  = (float)( 255 - line[xx] ) / 256.0;
+          FT_Int result = 0;
+
+          if ( brightness < 0.0 )
+            value = value * ( 1.0 + brightness );
+          else
+            value = value + ( ( 1.0 - value ) * brightness );
+
+          value = ( value - 0.5 ) *
+                    ( tan ( ( contrast + 1.0 ) * 3.141592/4.0 ) ) + 0.5;
+
+          result = (FT_Int)( 255.0 - value * 256.0 );
+
+          if ( result < 0 )
+            result = 0;
+          if ( result > 255 )
+            result = 255;
+
+          line[xx] = result;
+        }
+      }
+    }
+    return TRUE;
+  }
+
+
+  /* Filter to mimic Windows-style sharpening */
+  /* Determined via 100% experimentation.     */
+  static void
+  _ft_lcd_windows_sharpen( FT_Bitmap*      bitmap,
+                           FT_Render_Mode  mode,
+                           FT_UInt         strength,
+                           FT_Library      library )
+  {
+
+    FT_UInt   width   = (FT_UInt)bitmap->width;
+    FT_UInt   height  = (FT_UInt)bitmap->rows;
+    FT_Byte*  new_line;
+    FT_Byte*  line = bitmap->buffer;
+    FT_Bitmap new_bitmap;
+
+
+    FT_Bitmap_New( &new_bitmap );
+    FT_Bitmap_Copy( library, bitmap, &new_bitmap );
+    new_line = (&new_bitmap)->buffer;
+
+    if (strength > 0)
+      for (height = (FT_UInt)bitmap->rows;
+           height > 0;
+           height--, line += bitmap->pitch, new_line += bitmap->pitch )
+    {
+      FT_UInt   xx, threshold = 128;
+      FT_Byte*  prevline      = line - bitmap->pitch;
+      FT_Byte*  nextline      = line + bitmap->pitch;
+      FT_Byte*  new_prevline  = new_line - bitmap->pitch;
+      FT_Byte*  new_nextline  = new_line + bitmap->pitch;
+
+      for ( xx = 1; xx < width - 1; xx += 1 )
+      {
+        /* subpixel grid       sp11 sp21 sp31   */
+        /* where sp22 is       sp12 sp22 sp32   */
+        /* current subpixel.   sp13 sp23 sp33   */
+
+        FT_Int prevtotal, nexttotal, lefttotal, righttotal, sidesdiff,
+          prevdiff, nextdiff, sp11, sp21, sp31, sp12, sp22, sp32,
+          sp13, sp23, sp33;
+
+        sp12 = line [xx-1];
+        sp22 = line [xx];
+        sp32 = line [xx+1];
+
+        if ( height == bitmap->rows )
+        {
+          prevtotal = sp11 = sp21 = sp31 = 0;
+          prevdiff = sp22;
+          lefttotal = sp12 + sp13;
+          righttotal = sp32 + sp33;
+        }
+        else
+        {
+          prevtotal = prevline[xx-1] + prevline[xx] + prevline[xx+1];
+          sp11 = prevline [xx-1];
+          sp21 = prevline [xx];
+          sp31 = prevline [xx+1];
+          prevdiff = sp22 - sp21;
+          lefttotal = sp11 + sp12 + sp13;
+          righttotal = sp31 + sp32 + sp33;
+        }
+
+        if ( height == 1 )
+        {
+          nexttotal = sp13 = sp23 = sp33 = 0;
+          nextdiff = sp22;
+          lefttotal = sp11 + sp12;
+          righttotal = sp31 + sp32;
+        }
+        else
+        {
+          nexttotal = nextline[xx-1] + nextline[xx] + nextline[xx+1];
+          sp13 = nextline [xx-1];
+          sp23 = nextline [xx];
+          sp33 = nextline [xx+1];
+          nextdiff = sp23 - sp22;
+          lefttotal = sp11 + sp12 + sp13;
+          righttotal = sp31 + sp32 + sp33;
+        }
+
+        sidesdiff = lefttotal - righttotal;
+
+        if ( sidesdiff < 0 )
+          sidesdiff *= -1;
+
+        if ( prevdiff < 0 )
+          prevdiff *= -1;
+
+        if ( nextdiff < 0 )
+          nextdiff *= -1;
+
+        /* if the current pixel is less than threshold, and greater than 0  */
+        if ( sp22 <= threshold && sp22 > 0 )
+        {
+          /* A pixel is horizontally isolated if: */
+          /* 1: All upper adjecent pixels are >= threshold */
+          if ( prevtotal >= nexttotal  &&
+               abs( sp11 - sp12 ) > 5  &&
+               abs( sp21 - sp22 ) > 5  &&
+               abs( sp31 - sp32 ) > 5  && /* not a vert stem end */
+               sp11 >= threshold       &&
+               sp21 >= threshold       &&
+               sp31 >= threshold       &&
+               abs( sp23 - sp22 ) > 15 )  /* not on a vert stem */
+          {
+            /* darken upper adjacent subpixel;  lighten current */
+            if ( height != (FT_UInt)bitmap->rows )
+              new_prevline[xx] += ( ( 255 - new_prevline[xx] )
+                                      * strength ) / 100 ;
+
+            new_line[xx] -= ( new_line[xx] * strength ) / 100;
+
+            if ( height != 1 && height != (FT_UInt)bitmap->rows )
+              if ( new_nextline[xx] > 155 + ( 100 - strength ) )
+                new_prevline[xx] = 255;
+
+          }
+          else if ( nexttotal > prevtotal  &&
+                    abs( sp13 - sp12 ) > 5  &&
+                    abs( sp23 - sp22 ) > 5  &&
+                    abs( sp33 - sp32 ) > 5  &&
+                    /* 2: All lower adjecent pixels are >= threshold */
+                    sp13 >= threshold      &&
+                    sp23 >= threshold      &&
+                    sp33 >= threshold      &&
+                    abs( sp22 - sp21 ) > 15 )
+          {
+            /* darken lower adjacent subpixel;  lighten current */
+            if ( height != 1 )
+              new_nextline[xx] += ( 255 - new_nextline[xx] ) * strength / 100;
+
+            new_line[xx] -= ( new_line[xx] * strength ) / 100;
+
+            if ( height != 1 )
+              if ( new_nextline[xx] > 155 + ( 100 - strength ) )
+                new_nextline[xx] = 255;
+
+          }
+        }
+        else if ( sp22 > threshold && sp22 < 255 )
+        {
+          if ( sp11 <= threshold       &&
+               abs( sp13 - sp12 ) > 5  &&
+               abs( sp23 - sp22 ) > 5  &&
+               abs( sp33 - sp32 ) > 5  &&
+               sp21 <= threshold       &&
+               sp31 <= threshold       &&
+               prevtotal <= nexttotal  &&
+               abs( sp22 - sp21 ) > 15 )
+          {
+            /* bring this subpixel 1/3 of the way to 255 at 100% strength */
+            new_line[xx] += ( strength * ( 255 - new_line[xx] ) ) / 100;
+
+            if ( height != (FT_UInt)bitmap->rows )
+              new_prevline[xx] -= ( new_prevline[xx] * strength ) / 300;
+          }
+          else if ( sp13 <= threshold       &&
+                    abs( sp11 - sp12 ) > 5  &&
+                    abs( sp21 - sp22 ) > 5  &&
+                    abs( sp31 - sp32 ) > 5  &&
+                    sp23 <= threshold       &&
+                    sp33 <= threshold       &&
+                    nexttotal < prevtotal   &&
+                    abs( sp23 - sp22 ) > 15 )
+          {
+            new_line[xx] += ( strength * ( 255 - new_line[xx] ) ) / 100;
+
+            if ( height != 1 )
+              new_nextline[xx] -= ( new_nextline[xx] * strength ) / 300;
+          }
+        }
+      }
+    }
+    FT_Bitmap_Copy( library, &new_bitmap, bitmap);
+    FT_Bitmap_Done( library, &new_bitmap );
+  }
+
+
+  static void
+  _ft_lcd_darken_x  ( FT_Bitmap*      bitmap,
+                      FT_Render_Mode  mode,
+                      FT_UInt         strength,
+                      FT_Library      library )
+  {
+
+    FT_UInt   width   = (FT_UInt)bitmap->width;
+    FT_UInt   height  = (FT_UInt)bitmap->rows;
+    FT_Byte*  new_line;
+    FT_Byte*  line = bitmap->buffer;
+    FT_Bitmap new_bitmap;
+    int       factor1, factor2;
+    int       bias = 0;
+
+    FT_Bitmap_New( &new_bitmap );
+
+    FT_Bitmap_Copy( library, bitmap, &new_bitmap );
+    new_line = (&new_bitmap)->buffer;
+
+    if ( strength > 0 )
+      for ( height = (FT_UInt)bitmap->rows;
+            height > 0;
+            height--, line += bitmap->pitch, new_line += bitmap->pitch )
+    {
+      FT_UInt   xx;
+      FT_Byte*  prevline = line - bitmap->pitch;
+      FT_Byte*  nextline = line + bitmap->pitch;
+
+      for ( xx = 1; xx < width - 1; xx += 1 )
+      {
+        /* subpixel grid       sp11 sp21 sp31   */
+        /* where sp22 is       sp12 sp22 sp32   */
+        /* current subpixel.   sp13 sp23 sp33   */
+
+        FT_Int sp21, sp12, sp22, sp32, sp23;
+
+        sp12 = line [xx-1];
+        sp22 = line [xx];
+        sp32 = line [xx+1];
+
+        if ( height == bitmap->rows )
+          sp21 = 0;
+        else
+          sp21 = prevline [xx];
+
+        if ( height == 1 )
+          sp23 = 0;
+        else
+          sp23 = nextline [xx];
+
+        /* darken subpixel if neighbor above and below are much less than */
+        /* safer but less effective */
+        factor1 = 5;
+        factor2 = 5;
+
+        /* make matches in the middle of glyph slightly darker */
+        /*if (height > 1 && height < (FT_UInt)bitmap->rows) bias = 1;*/
+
+        if ( sp22 > factor1 * sp21  &&
+             sp22  > factor1 * sp23 &&
+             sp22 > factor2         &&
+             sp12 > 16              &&
+             sp32 > 16              )
+          if ( new_line[xx] < ( strength * 255 ) / 100 )
+            new_line[xx] = (strength * 255 ) / 100
+                             + bias * ( 255 - ( strength * 255 ) / 100 ) / 3;
+
+      }
+    }
+    FT_Bitmap_Copy( library, &new_bitmap, bitmap );
+    FT_Bitmap_Done( library, &new_bitmap );
+  }
+
+
+  static void
+  _ft_lcd_darken_y  ( FT_Bitmap*      bitmap,
+                      FT_Render_Mode  mode,
+                      FT_UInt         strength,
+                      FT_Library      library )
+  {
+
+    FT_UInt   width   = (FT_UInt)bitmap->width;
+    FT_UInt   height  = (FT_UInt)bitmap->rows;
+    FT_Byte*  new_line;
+    FT_Byte*  line = bitmap->buffer;
+    FT_Bitmap   new_bitmap;
+
+
+    FT_Bitmap_New( &new_bitmap );
+    FT_Bitmap_Copy( library, bitmap, &new_bitmap );
+    new_line = (&new_bitmap)->buffer;
+
+    if ( strength > 0 )
+      for ( height = (FT_UInt)bitmap->rows;
+            height > 0;
+            height--, line += bitmap->pitch, new_line += bitmap->pitch )
+    {
+      FT_UInt  xx;
+
+
+      for ( xx = 1; xx < width - 1; xx += 1 )
+      {
+        if ( line[xx] > line[xx-1] && line[xx] > line[xx+1] )
+        {
+           if (new_line[xx] > 0)
+             new_line[xx] += ( strength * ( 255 - new_line[xx] ) ) / 100;
+           new_line[xx-1] += ( strength * ( 255 - line[xx-1] ) ) / 100;
+           new_line[xx+1] += ( strength * ( 255 - line[xx+1] ) ) / 100;
+        }
+      }
+    }
+    FT_Bitmap_Copy( library, &new_bitmap, bitmap );
+    FT_Bitmap_Done( library, &new_bitmap );
+  }
+
+
+  static void
+  _ft_bitmap_cap  ( FT_Bitmap*      bitmap,
+                    FT_UInt         strength,
+                    FT_Library      library )
+  {
+
+    FT_UInt   width   = (FT_UInt)bitmap->width;
+    FT_UInt   height  = (FT_UInt)bitmap->rows;
+    FT_Byte*  new_line;
+    FT_Byte*  line = bitmap->buffer;
+    FT_UInt   cur_value = 0;
+    FT_Bitmap new_bitmap;
+
+
+    FT_Bitmap_New( &new_bitmap );
+    FT_Bitmap_Copy( library, bitmap, &new_bitmap );
+    new_line = (&new_bitmap)->buffer;
+
+    if ( strength > 0 )
+      for ( height = (FT_UInt)bitmap->rows;
+            height > 0;
+            height--, line += bitmap->pitch, new_line += bitmap->pitch )
+    {
+      FT_UInt  xx;
+
+
+      for ( xx = 1; xx < width - 1; xx += 1 )
+      {
+        cur_value = ( new_line[xx-1] + new_line[xx] + new_line[xx+1] ) / 3;
+        if ( cur_value > ( strength * 255 ) / 100 )
+        {
+          FT_UInt new_factor = ( strength * 255 ) / 100;
+          new_line[xx] = ( new_line[xx] * new_factor ) / cur_value;
+          new_line[xx+1] = ( new_line[xx+1] * new_factor ) / cur_value;
+          new_line[xx-1] = ( new_line[xx-1] * new_factor ) / cur_value;
+        }
+      }
+    }
+    FT_Bitmap_Copy( library, &new_bitmap, bitmap );
+    FT_Bitmap_Done( library, &new_bitmap );
+  }
+
+  static int
+  pseudo_gamma ( int val, float value )
+  {
+      return 256 * ( 1.0f - powf( ( 1.0f - val * (1.0f/256.0f) ), 1.0f / value ) );
+  }
+
+#if(0)
+  static void
+  _ft_bitmap_embolden  ( FT_Bitmap*      bitmap,
+                         FT_UInt         strength,
+                         FT_Library      library )
+  {
+
+    FT_UInt   width   = (FT_UInt)bitmap->width;
+    FT_UInt   height  = (FT_UInt)bitmap->rows;
+    FT_Byte*  new_line;
+    FT_Byte*  line = bitmap->buffer;
+    FT_Bitmap new_bitmap;
+    FT_UInt   xx;
+
+
+    FT_Bitmap_New(&new_bitmap);
+    FT_Bitmap_Copy(library, bitmap, &new_bitmap);
+    new_line = (&new_bitmap)->buffer;
+
+    if ( strength > 0 )
+      for ( height = (FT_UInt)bitmap->rows;
+            height > 0;
+            height--, line += bitmap->pitch, new_line += bitmap->pitch )
+    {
+      for ( xx = 1; xx < width - 1; xx += 1 )
+      {
+        FT_Int new_value = 0;
+
+
+        new_value = ( strength * line [xx-1] ) / 100
+                      + pseudo_gamma( line [xx], .75 )
+                      + (strength * line [xx+1] ) / 100;
+        if ( new_value > 255 )
+          new_value = 255;
+
+        new_line[xx] = new_value;
+      }
+    }
+    FT_Bitmap_Copy( library, &new_bitmap, bitmap );
+    FT_Bitmap_Done( library, &new_bitmap );
+  }
+
+
+
+  static void
+  _ft_bitmap_gamma  ( FT_Bitmap*    bitmap,
+                      float         strength )
+  {
+
+    FT_UInt   width   = (FT_UInt)bitmap->width;
+    FT_UInt   height  = (FT_UInt)bitmap->rows;
+    FT_Byte*  line = bitmap->buffer;
+    FT_UInt   xx;
+
+
+    if ( strength > 0 )
+      for ( height = (FT_UInt)bitmap->rows;
+            height > 0;
+            height--, line += bitmap->pitch )
+    {
+
+      for ( xx = 1; xx < width - 1; xx += 1 )
+      {
+        if ( abs( line[xx-1] - line[xx] ) < 20 ||
+             abs( line[xx+1] - line[xx] ) < 20 )
+        line [xx] = pseudo_gamma( line [xx], strength ) ;
+      }
+    }
+  }
+#endif
+
+  /* Fringe filter */
+  static void
+  _ft_lcd_fringe_filter ( FT_Bitmap*      bitmap,
+                          FT_Render_Mode  mode,
+                          FT_UInt         strength,
+                          FT_Library      library )
+  {
+
+    FT_UInt   width   = (FT_UInt)bitmap->width;
+    FT_UInt   height  = (FT_UInt)bitmap->rows;
+    FT_Byte*  new_line;
+    FT_Byte*  line = bitmap->buffer;
+    FT_Bitmap   new_bitmap;
+
+
+    FT_Bitmap_New(&new_bitmap);
+
+    line = bitmap->buffer;
+    FT_Bitmap_Copy( library, bitmap, &new_bitmap );
+    new_line = (&new_bitmap)->buffer;
+
+    for ( height = (FT_UInt)bitmap->rows;
+          height > 0;
+          height--, line += bitmap->pitch, new_line += bitmap->pitch )
+    {
+      /* Threshold set to 1/2 pixel intensity */
+      FT_UInt  xx, threshold = 128;
+
+      /* Hack to make this work when bitmap is at first or last line */
+      FT_Int   fudge = bitmap->pitch * (height == (FT_UInt)bitmap->rows);
+
+      FT_Byte*  prevline = line - bitmap->pitch + fudge;
+      FT_Byte*  nextline = line + bitmap->pitch;
+
+
+      for ( xx = 1; xx < width - 1; xx += 1 )
+      {
+        /* subpixel grid       sp11 sp21 sp31   */
+        /* where sp22 is       sp12 sp22 sp32   */
+        /* current subpixel.   sp13 sp23 sp33   */
+
+        FT_Int prevtotal, nexttotal, lefttotal, righttotal, sidesdiff,
+          leftdiff, rightdiff, prevdiff, nextdiff, sp11, sp21, sp31,
+          sp12, sp22, sp32, sp13, sp23, sp33;
+
+        sp12 = line [xx-1];
+        sp22 = line [xx];
+        sp32 = line [xx+1];
+
+        /* if at max height fake out some values */
+        if ( height == (FT_UInt)bitmap->rows )
+        {
+          prevtotal = sp11 = sp21 = sp31 = 0;
+          prevdiff = sp22;
+          lefttotal = sp12 + sp13;
+          righttotal = sp32 + sp33;
+        }
+        else
+        {
+          prevtotal = prevline[xx-1] + prevline[xx] + prevline[xx+1];
+          sp11 = prevline [xx-1];
+          sp21 = prevline [xx];
+          sp31 = prevline [xx+1];
+          prevdiff = sp22 - sp21;
+          lefttotal = sp11 + sp12 + sp13;
+          righttotal = sp31 + sp32 + sp33;
+        }
+
+        /* if at min height fake out some values */
+        if ( height == 1 )
+        {
+          nexttotal = sp13 = sp23 = sp33 = 0;
+          nextdiff = sp22;
+          lefttotal = sp11 + sp12;
+          righttotal = sp31 + sp32;
+        }
+        else
+        {
+          nexttotal = nextline[xx-1] + nextline[xx] + nextline[xx+1];
+          sp13 = nextline [xx-1];
+          sp23 = nextline [xx];
+          sp33 = nextline [xx+1];
+          nextdiff = sp23 - sp22;
+          lefttotal = sp11 + sp12 + sp13;
+          righttotal = sp31 + sp32 + sp33;
+        }
+
+        sidesdiff = lefttotal - righttotal;
+        leftdiff = sp22 - sp12;
+        rightdiff = sp32 - sp22;
+
+        if ( sidesdiff < 0 )
+          sidesdiff *= -1;
+
+        if ( prevdiff < 0 )
+          prevdiff *= -1;
+
+        if ( nextdiff < 0 )
+          nextdiff *= -1;
+
+        if ( leftdiff < 0 )
+          leftdiff *= -1;
+
+        if ( rightdiff < 0 )
+          rightdiff *= -1;
+
+        /* if the current subpixel is less than threshold, and varies only
+          slightly to left or right, lighten it */
+        if ( sp22 <= threshold && sp22 > 0       &&
+             ( leftdiff < 10 || rightdiff < 10 ) )
+        {
+          /* A pixel is horizontally isolated if: */
+          /* 1: All upper adjecent subpixels are >= threshold and all lower
+             adjacent ones are essentially white */
+          if ( prevtotal >= nexttotal &&
+               sp11 >= threshold      &&
+               sp21 >= threshold      &&
+               sp31 >= threshold      &&
+               sp13 < 2               &&
+               sp23 < 2               &&
+               sp33 < 2               )
+
+          {
+            new_line[xx] -= ( new_line[xx] * strength ) / 100;
+
+            if ( leftdiff < 10 )
+              /* OPPORTUNITY FOR IMPROVEMENT  - keep going left until 255? */
+              new_line[xx-1] -= ( new_line[xx-1] * strength ) / 200;
+
+            if ( rightdiff < 10 )
+              /* OPPORTUNITY FOR IMPROVEMENT */
+              new_line[xx+1] -= ( new_line[xx+1] * strength ) / 200;
+          }
+          else if ( nexttotal > prevtotal &&
+                    /* 2: the inverse of above */
+                    sp13 >= threshold     &&
+                    sp23 >= threshold     &&
+                    sp33 >= threshold     &&
+                    sp11 < 2              &&
+                    sp21 < 2              &&
+                    sp31 < 2              )
+          {
+            new_line[xx] -= ( new_line[xx] * strength ) / 100;
+
+            if ( leftdiff < 10 )
+              /* OPPORTUNITY FOR IMPROVEMENT - keep going left until 255?  */
+              new_line[xx-1] -= ( new_line[xx-1] * strength ) / 200;
+
+            if ( rightdiff < 10 )
+              /* OPPORTUNITY FOR IMPROVEMENT */
+              new_line[xx+1] -= ( new_line[xx+1] * strength ) / 200;
+          }
+        }
+        /* otherwise if the current subpixel is more than threshold, and varies
+          slightly to left or right, darken it */
+        else if ( sp22 > threshold    &&
+                  sp22 < 255          &&
+                  ( leftdiff < 10  ||
+                    rightdiff < 10 )  )
+        {
+          if ( sp11 <= 2             &&
+               sp21 <= 2             &&
+               sp31 <= 2             &&
+               sp13 >= threshold     &&
+               sp23 >= threshold     &&
+               sp33 >= threshold     &&
+               prevtotal < nexttotal )
+            new_line[xx] += ( ( 255 - new_line[xx] ) * strength ) / 100;
+
+          else if ( sp13 <= 2             &&
+                    sp23 <= 2             &&
+                    sp33 <= 2             &&
+                    nexttotal < prevtotal &&
+                    sp11 >= threshold     &&
+                    sp21 >= threshold     &&
+                    sp31 >= threshold     )
+            new_line[xx] += ( ( 255 - new_line[xx] ) * strength ) / 100;
+
+        }
+      }
+    }
+    FT_Bitmap_Copy( library, &new_bitmap, bitmap );
+    FT_Bitmap_Done( library, &new_bitmap );
+  }
+
+
+  /* Grayscale filter */
+  static void
+  _ft_lcd_grayscale_filter ( FT_Bitmap*      bitmap,
+                             FT_Render_Mode  mode,
+                             FT_UInt         strength,
+                             FT_Library      library )
+  {
+
+    FT_UInt   width   = (FT_UInt)bitmap->width;
+    FT_UInt   height  = (FT_UInt)bitmap->rows;
+    FT_Byte*  line    = bitmap->buffer;
+
+
+    for ( height = (FT_UInt)bitmap->rows;
+          height > 0;
+          height--, line += bitmap->pitch )
+    {
+      FT_UInt xx;
+
+
+      for ( xx = 0; xx < width - 1; xx += 3 )
+      {
+        FT_UInt total = line [xx] + line [xx + 1] + line [xx + 2];
+        line[xx] =   ( ( 100 - strength ) * line[xx]
+                       + strength * ( total / 3 ) ) / 100;
+        line[xx+1] = ( ( 100 - strength ) * line[xx+1]
+                       + strength * ( total / 3 ) ) / 100;
+        line[xx+2] = ( ( 100 - strength ) * line[xx+2]
+                       + strength * ( total / 3 ) ) / 100;
+      }
+    }
+  }
+
+/*
+  These need to be in sync with params inside ftinf.c
+  (not ideal but perhaps better than making these public)
+ */
+#define STEM_WIDTH_2_PPEM 18
+#define MAX_PPEM 100
+
+  typedef struct  Stem_Segment_
+  {
+    FT_Long       x1;
+    FT_Long       x2;
+    FT_Int        y;
+  } Stem_Segment;
+
+  typedef struct  Stem_Center_
+  {
+    FT_Long       x;
+    FT_Long       y;
+    FT_Long       w;
+    FT_Long       x1;
+    FT_Long       x2;
+  } Stem_Center;
+
+  typedef struct  Stem_
+  {
+    FT_Long       center;
+    FT_Long       count;
+    FT_Long       rcount; /* used to count within a range in possible stems */
+    FT_Long       width;
+    FT_Long       height;
+    FT_Short      zone;  /* 1 2 or 3 */
+    FT_Bool       generated;
+  } Stem;
+
+  static void
+  swap_stem ( Stem* s1, Stem* s2 )
+  {
+    Stem s;
+    s.center = s1->center;
+    s.count  = s1->count;
+    s.rcount = s1->rcount;
+    s.width  = s1->width;
+    s.zone   = s1->zone;
+    s.generated = s1->generated;
+
+    s1->center = s2->center;
+    s1->count  = s2->count;
+    s1->rcount = s2->rcount;
+    s1->width  = s2->width;
+    s1->zone   = s2->zone;
+    s1->generated = s2->generated;
+
+    s2->center = s.center;
+    s2->count  = s.count;
+    s2->rcount = s.rcount;
+    s2->width  = s.width;
+    s2->zone   = s.zone;
+    s2->generated = s.generated;
+  }
+
+  /* Stem alignment for bitmaps;  A hack with very nice results */
+  /* Ideally this could be implemented on the outline, prior to
+   * rasterization.  Possible future enhancement is to use the
+   * warper code to achieve this */
+  static void
+  _lcd_stem_align ( FT_Bitmap*      bitmap,
+                    FT_Render_Mode  mode,
+                    FT_GlyphSlot    slot,
+                    FT_Long*        translate_value,
+                    float*          scale_value,
+                    FT_UInt         alignment_strength,
+                    FT_UInt         fitting_strength,
+                    float*          embolden_value
+                  )
+  {
+    FT_UInt         width   = (FT_UInt)bitmap->width;
+    FT_UInt         height  = (FT_UInt)bitmap->rows;
+
+    Stem_Segment*   segments;
+    Stem_Segment*   leftmost_segment;
+    Stem_Segment*   rightmost_segment;
+    Stem_Segment*   leftmost_segment_not_extrema;
+    Stem_Segment*   rightmost_segment_not_extrema;
+    Stem*           stems;
+    Stem*           possible_stems;
+    Stem*           leftmost_stem;
+    Stem*           rightmost_stem;
+    Stem_Data*      known_stem_values;
+    Stem_Center*    centers;
+    FT_Long         leftmost_point = width * 256;
+    FT_Long         rightmost_point = 0;
+    FT_Long         leftmost_point_not_extrema = width * 256;
+    FT_Long         rightmost_point_not_extrema = 0;
+    FT_Long         num_segments = 0;
+    FT_Long         num_centers = 0;
+    FT_Long         *stem_centers;
+    FT_UInt         h;
+    FT_ULong        valid_stems = 0, valid_possible_stems = 0;
+    FT_Long         center, stem_matches, stem_matches_ledge;
+    FT_Long         stem_matches_redge, next_center, last_matching_center;
+    FT_Long         last_matching_ledge, last_matching_redge, this_center;
+    FT_Int          max_strength;
+    FT_Byte*        line = bitmap->buffer;
+    FT_UInt         current_value = 0;
+    FT_UInt         xx;
+    FT_Long         linearHoriAdvance = slot->linearHoriAdvance >> 10;
+
+    FT_Int          m_horiBearingX = slot->metrics.horiBearingX;
+    FT_Int          m_horiAdvance = slot->metrics.horiAdvance;
+    FT_Int          m_width = slot->metrics.width;
+    FT_Pos          one_pixel = 768;
+    FT_Pos          one_third_pixel = 256;
+    FT_Int          columns_per_pixel = 3;
+    /*FT_Int          extra_columns = 6;*/
+
+    /* on / off flags for testing different features */
+    FT_Bool         strategy_translate_using_closest_stem = TRUE;
+    FT_Bool         strategy_scale_to_closest_centers = FALSE;
+    FT_Bool         strategy_scale_to_closest_centers_up_only = FALSE;
+    FT_Bool         strategy_always_use_distance_ceiling = FALSE;
+    FT_Bool         strategy_auto_change_center_offset = TRUE;
+    FT_Bool         strategy_use_m_control = FALSE;
+    FT_Bool         strategy_correct_out_of_bounds_outlines = FALSE;
+    FT_Bool         strategy_also_use_edge_detection_for_stems = FALSE;
+    FT_Bool         strategy_use_strengths = TRUE;
+    FT_Bool         strategy_synthesize_stems = FALSE;
+    FT_Bool         strategy_bearing_correction = TRUE;
+    FT_Bool         strategy_use_d_correction = TRUE;
+    FT_Bool         strategy_fit_to_width = FALSE;
+    /*FT_Bool         strategy_center_glyph = FALSE;*/
+
+    const FT_Int    MIN_PPEM = 7;
+    /*const FT_Int    MAX_PPEM = 100;*/
+    const FT_Int    MAX_STEMS = 3;
+    FT_Int          ppem = 0;
+
+    Stem_Data       stem_data;
+
+    /* reset to default */
+    *scale_value = 1.0;
+
+    /* Simply return in odd cases where these don't seem to be set */
+    /* Flash and some pdf viewers will crash otherwise */
+    if ( !slot->face                       ||
+         !slot->face->size                 ||
+         !slot->face->size->metrics.x_ppem )
+      return;
+
+    if ( slot->face->size->metrics.x_ppem > MAX_PPEM )
+      return;
+
+    if ( slot->face->size->metrics.x_ppem < MIN_PPEM )
+      return;
+
+    if ( !FT_IS_SCALABLE( slot->face ) )
+      return;
+
+    ppem = slot->face->size->metrics.x_ppem;
+
+    if ( ppem < 9 )
+      return;
+    if ( ppem > 20 )
+        strategy_use_m_control = TRUE;
+
+    /* only perform alignment on styles we know, that aren't bold or italic */
+    /* perhaps detection could be added on those that are not set? */
+    /* Require certain ppems for narrow and light fonts */
+    if( slot->face->style_name )
+    {
+      if ( strcasestr( slot->face->style_name, "Italic" )            ||
+           strcasestr( slot->face->style_name, "Oblique" )           ||
+           strcasestr( slot->face->style_name, "Script" )            ||
+           strcasestr( slot->face->style_name, "Handwriting" )       ||
+           strcasestr( slot->face->style_name, "Bold" )              ||
+           strcasestr( slot->face->style_name, "Black" )             ||
+           ( ( strcasestr( slot->face->style_name, "Extra Thin" )  ||
+               strcasestr( slot->face->style_name, "Extra Light" ) ) &&
+             ppem < 10 )                                             ||
+           ( strcasestr( slot->face->style_name, "Thin" )
+               && ppem < 10 )                                        ||
+           ( strcasestr( slot->face->style_name, "Light" )
+               && ppem < 10 )                                        ||
+           ( strcasestr( slot->face->style_name, "Narrow" )
+               && ppem < 15 )                                        ||
+           ( strcasestr( slot->face->style_name, "Condensed" )
+               && ppem < 20 )                                        )
+            return;
+    }
+
+    if( slot->face->family_name )
+    {
+      if ( strcasestr( slot->face->family_name, "Italic" )            ||
+           strcasestr( slot->face->family_name, "Oblique" )           ||
+           strcasestr( slot->face->family_name, "Script" )            ||
+           strcasestr( slot->face->family_name, "Handwriting" )       ||
+           strcasestr( slot->face->family_name, "Bold" )              ||
+           strcasestr( slot->face->family_name, "Black" )             ||
+           ( ( strcasestr( slot->face->family_name, "Extra Thin" )  ||
+               strcasestr( slot->face->family_name, "Extra Light" ) ) &&
+             ppem < 10 )                                              ||
+           ( strcasestr( slot->face->family_name, "Thin" )
+               && ppem < 10 )                                         ||
+           ( strcasestr( slot->face->family_name, "Light" )
+               && ppem < 10 )                                         ||
+           ( strcasestr( slot->face->family_name, "Narrow" )
+               && ppem < 15 )                                         ||
+           ( strcasestr( slot->face->family_name, "Condensed" )
+               && ppem < 20 )                                         )
+            return;
+    }
+    else if ( slot->face->style_flags )
+    {
+      if ( slot->face->style_flags & FT_STYLE_FLAG_ITALIC ||
+           slot->face->style_flags & FT_STYLE_FLAG_BOLD   ||
+           FT_IS_TRICKY( slot->face )                     )
+        return;
+    }
+    else return;
+
+    if ( mode != FT_RENDER_MODE_LCD )
+    {
+      columns_per_pixel = 1;
+      one_pixel = 256;
+      one_third_pixel = 85;
+      /*extra_columns = 0;*/
+      /* until this can be figured out just return */
+      /* There are issues with missing glyphs */
+      return;
+    }
+
+    known_stem_values=&stem_data;
+    if ( ftinf && ftinf->use_known_settings_on_selected_fonts )
+    {
+      ftinf_fill_stem_values( known_stem_values, slot->face->family_name, ppem, TRUE );
+      /* translate value may be set for < 10 */
+      if (known_stem_values->stem_translating_only > -1024 )
+      {
+          *translate_value = known_stem_values->stem_translating_only;
+          return;
+      }
+      if( known_stem_values->bearing_correction == FALSE )
+          strategy_bearing_correction = FALSE;
+    } else
+        ftinf_fill_stem_values( known_stem_values, slot->face->family_name, ppem, FALSE );
+
+    if ( known_stem_values->use_100 ||
+         known_stem_values->m >= 0  )
+    {
+      alignment_strength = fitting_strength = 100;
+      strategy_use_m_control = TRUE;
+    }
+
+    if ( known_stem_values->edge_detection )
+      strategy_also_use_edge_detection_for_stems = TRUE;
+
+    /* Allocate */
+    segments = NULL;
+    leftmost_segment = (Stem_Segment*) malloc( 4*sizeof ( Stem_Segment ) );
+    leftmost_segment_not_extrema = leftmost_segment+1;
+    rightmost_segment = leftmost_segment+2;
+    rightmost_segment_not_extrema = leftmost_segment+3;
+
+    stems          = (Stem*) malloc ( (2*MAX_STEMS+2) * sizeof ( Stem ) );
+    possible_stems = stems+MAX_STEMS;
+    leftmost_stem  = possible_stems+MAX_STEMS;
+    rightmost_stem = leftmost_stem + 1;
+    centers        = NULL;
+
+    if ( verbose )
+      printf("\n");
+
+    /* Initialize */
+    stem_centers=(FT_Long*)calloc( width * 256, sizeof(stem_centers[0]) );
+
+    rightmost_segment->x1 = 0;
+    rightmost_segment->x2 = 0;
+    rightmost_segment->y  = 0;
+    leftmost_segment->x1  = 99999999;
+    leftmost_segment->x2  = 0;
+    leftmost_segment->y   = 0;
+
+    rightmost_segment_not_extrema->x1 = 0;
+    rightmost_segment_not_extrema->x2 = 0;
+    rightmost_segment_not_extrema->y  = 0;
+    leftmost_segment_not_extrema->x1  = 99999999;
+    leftmost_segment_not_extrema->x2  = 0;
+    leftmost_segment_not_extrema->y   = 0;
+
+    /* Locate stem centers for later processing */
+    for ( h = (FT_UInt)bitmap->rows; h > 0; h--, line += bitmap->pitch )
+    {
+      current_value = 0;
+      /* Calculate various sums and stem widths of glyph */
+      for ( xx = 0; xx < width; xx += 1 )
+      {
+        /* Reallocate (in blocks of 64) */
+        if( num_segments % 64 == 0 )
+            segments = (Stem_Segment*) realloc
+                ( segments, ( num_segments + 64 ) * sizeof ( Stem_Segment ) );
+
+        /* if line is white, and now has color, it's the start of a stem */
+        if ( current_value == 0 && line[xx] > 0 )
+        {
+          /* start of stem */
+          segments[num_segments].x1 = 256 * xx + ( 255 - line[xx] );
+          segments[num_segments].y = h;
+        }
+
+        /* otherwise, if it's currently black and the new value is 0,
+           it's the end of a stem */
+        else if ( ( current_value > 0 && line[xx] == 0 )   ||
+                  ( current_value > 0 && xx == width - 1 ) )
+        {
+          FT_Long stem_center_x;
+          segments[num_segments].x2 = 256 * ( xx - 1 ) + line[xx-1];
+
+          if ( xx == width - 1 )
+            segments[num_segments].x2 += line[xx];
+
+          /*stem center is average of start and end of stem */
+          stem_center_x = ( segments[num_segments].x2
+                            + segments[num_segments].x1 ) / 2;
+
+          /* Reallocate (in blocks of 32) */
+          if( num_centers % 32 == 0 )
+              centers = (Stem_Center*) realloc
+                  ( centers, ( num_centers + 32 ) * sizeof ( Stem_Center ) );
+          centers[num_centers].x = stem_center_x;
+          centers[num_centers].y = h;
+          centers[num_centers].x1 = segments[num_segments].x1;
+          centers[num_centers].x2 = segments[num_segments].x2;
+
+          num_centers++;
+
+          stem_centers[stem_center_x] += 1;
+
+          /* Find left and rightmost points for later calculations */
+          /* OR - Favor ones that aren't on the top or bottom if   */
+          /* possible to prevent v and w from getting caught later */
+          if ( segments[num_segments].x1 < leftmost_segment->x1      ||
+               ( segments[num_segments].y > 1                      &&
+                 segments[num_segments].y < height                 &&
+                 segments[num_segments].x1 == leftmost_segment->x1 ) )
+          {
+            leftmost_segment->x1 = segments[num_segments].x1;
+            leftmost_segment->x2 = segments[num_segments].x2;
+            leftmost_segment->y = h;
+          }
+          if ( segments[num_segments].x2 > rightmost_segment->x2      ||
+               ( segments[num_segments].y > 1                       &&
+                 segments[num_segments].y < height                  &&
+                 segments[num_segments].x1 == rightmost_segment->x1 ) )
+          {
+            rightmost_segment->x1 = segments[num_segments].x1;
+            rightmost_segment->x2 = segments[num_segments].x2;
+            rightmost_segment->y = h;
+          }
+
+          if ( segments[num_segments].x1
+                 < leftmost_segment_not_extrema->x1      ||
+               ( segments[num_segments].y > 1          &&
+                 segments[num_segments].y < height     &&
+                 segments[num_segments].x1
+                   == leftmost_segment_not_extrema->x1 &&
+                 h < (FT_UInt)bitmap->rows && h > 0    ) )
+          {
+            leftmost_segment_not_extrema->x1 = segments[num_segments].x1;
+            leftmost_segment_not_extrema->x2 = segments[num_segments].x2;
+            leftmost_segment_not_extrema->y = h;
+          }
+          if ( segments[num_segments].x2
+                 > rightmost_segment_not_extrema->x2      ||
+               ( segments[num_segments].y > 1           &&
+                 segments[num_segments].y < height      &&
+                 segments[num_segments].x1
+                   == rightmost_segment_not_extrema->x1 &&
+                 h < (FT_UInt)bitmap->rows && h > 0     ) )
+          {
+            rightmost_segment_not_extrema->x1 = segments[num_segments].x1;
+            rightmost_segment_not_extrema->x2 = segments[num_segments].x2;
+            rightmost_segment_not_extrema->y = h;
+          }
+
+          if ( segments[num_segments].x1 < leftmost_point )
+            leftmost_point = segments[num_segments].x1;
+
+          if ( segments[num_segments].x2 > rightmost_point )
+            rightmost_point = segments[num_segments].x2;
+
+          if ( segments[num_segments].x1 < leftmost_point_not_extrema &&
+               h < (FT_UInt)bitmap->rows && h > 0                     )
+            leftmost_point_not_extrema = segments[num_segments].x1;
+
+          if ( segments[num_segments].x2 > rightmost_point_not_extrema &&
+               h < (FT_UInt)bitmap->rows && h > 0                      )
+            rightmost_point_not_extrema = segments[num_segments].x2;
+
+          num_segments++;
+        }
+        /* else - other conditions - need some error checking here */
+        current_value = line[xx];
+      }
+    }
+
+    /* initialize */
+    for ( xx = 0; xx < MAX_STEMS; xx +=1 )
+    {
+      stems[xx].center = 0;
+      stems[xx].count = 0;
+      stems[xx].width = 0;
+      stems[xx].height = 0;
+      possible_stems[xx].center = 0;
+      possible_stems[xx].count = 0;
+      possible_stems[xx].width = 0;
+      possible_stems[xx].height = 0;
+    }
+
+    valid_stems = 0;
+    valid_possible_stems = 0;
+
+    /* Determine which centers belong to stems */
+    center = 0;
+
+    while ( center < num_centers )
+    {
+      /* slope at within which to consider a point part of a stem */
+      /*const FT_UInt slope = 1;
+      const FT_UInt topslope = (256 * 3) / 10; */
+
+      /* 10 to 20 with 4 matches seems good,                   */
+      /* but 1 or 2 with 3 stems needs to somehow get included */
+      FT_Int deviation1 = 5;
+      FT_Int deviation2=-1, requirement1 = 4, stem_match_requirement = 3;
+      FT_Int center_difference_in_height;
+      FT_Int center_difference_in_width, valid_center_average;
+      FT_Int smallest_width_ledge, smallest_width_redge;
+      FT_Int x1_difference_in_width, x2_difference_in_width;
+      FT_Bool no_gap_found = FALSE;
+      FT_Bool no_gap_found_ledge = FALSE;
+      FT_Bool no_gap_found_redge = FALSE;
+      FT_Bool stem_detected = FALSE;
+      FT_Int set_width_to, set_center_to;
+
+      /* seems to not do damage */
+      /* May not be effective */
+      requirement1 = height / 4;
+      if ( requirement1 < 5 )
+        requirement1 = 5;
+      deviation1 = 20;
+      deviation2 = 20;
+
+      if ( columns_per_pixel == 1 )
+        deviation1 = deviation2 = 10;
+
+      if ( (FT_Int)bitmap->rows <= 6 )
+        deviation1 = 25;
+
+      if ( (FT_Int)bitmap->rows <= 6 )
+        deviation2 = 25;
+
+      if ( columns_per_pixel == 1    &&
+           (FT_Int)bitmap->rows <= 6 )
+        deviation1 = deviation2 = 12;
+
+      valid_center_average = 0;
+
+      no_gap_found = no_gap_found_ledge = no_gap_found_redge = FALSE;
+      stem_detected = FALSE;
+
+      if ( ppem < 11 )
+        requirement1 = 4;
+
+      if ( ppem > 18 )
+      {
+        stem_match_requirement = height / 4;
+        if ( stem_match_requirement < 3 )
+          stem_match_requirement = 3;
+      }
+
+      smallest_width_ledge = smallest_width_redge = width * 256;
+      stem_matches = 0;
+      stem_matches_ledge = 0;
+      stem_matches_redge = 0;
+      last_matching_center = -1;
+      last_matching_ledge = -1;
+      last_matching_redge = -1;
+
+      /* set currently looked at center to center value */
+      this_center = center;
+      next_center = 0;
+
+      /* For each center, compare with all other centers to see if others */
+      /* match the properties of this one                                 */
+      while ( next_center < num_centers )
+      {
+
+        /* calculate differences */
+        center_difference_in_width = abs ( centers[this_center].x
+                                             - centers[next_center].x );
+        center_difference_in_height = abs ( centers[this_center].y
+                                              - centers[next_center].y );
+        x1_difference_in_width = abs ( centers[this_center].x1
+                                         - centers[next_center].x1 );
+        x2_difference_in_width = abs ( centers[this_center].x2
+                                         - centers[next_center].x2 );
+
+
+        /* property - stem center points that align                        */
+        /* if the center is within range, the center is less than          */
+        /* 1/2 the height away, and at least one edge is also within range */
+        if ( center_difference_in_width
+               < center_difference_in_height * deviation1     &&
+             center_difference_in_height
+               <= (FT_Int)bitmap->rows / 2                    &&
+             /* prevents w from getting caught ---- but also kills m */
+             ( x1_difference_in_width
+                 < center_difference_in_height * deviation2 ||
+               x2_difference_in_width
+                 < center_difference_in_height * deviation2 ) )
+        {
+          stem_matches += 1;
+          valid_center_average += centers[next_center].x;
+
+          /* try to find where the matching centers are far apart */
+          if ( last_matching_center >= 0 &&
+               abs( centers[last_matching_center].y
+                      - centers[next_center].y ) >= (FT_Int)bitmap->rows / 2 )
+
+          /* try to find where matching centers are next to each other */
+          if ( last_matching_center >= 0 &&
+               abs( centers[last_matching_center].y
+                      - centers[next_center].y ) == 1 )
+            no_gap_found = TRUE;
+
+          last_matching_center = next_center;
+        }
+
+        if ( strategy_also_use_edge_detection_for_stems )
+        {
+          /* property - stem left edge points that align */
+          /* if the center is within range,              */
+          /* the center is less than 1/2 the height away */
+          if ( x1_difference_in_width
+                 < center_difference_in_height * deviation1            &&
+               center_difference_in_height <= (FT_Int)bitmap->rows / 2 )
+          {
+            stem_matches_ledge += 1;
+            /* may not need for edges */
+            /*valid_center_average += centers[next_center].x;  */
+
+            if ( centers[next_center].x2 - centers[next_center].x1
+                   < smallest_width_ledge )
+              smallest_width_ledge = centers[next_center].x2
+                                       - centers[next_center].x1;
+
+            /* try to find where the matching centers are far apart */
+            if ( last_matching_ledge >= 0            &&
+                 abs( centers[last_matching_ledge].y
+                        - centers[next_center].y)
+                   >= (FT_Int)bitmap->rows / 2       )
+
+            /* try to find where matching centers are next to each other */
+            if ( last_matching_ledge >= 0               &&
+                 abs( centers[last_matching_ledge].y
+                        - centers[next_center].y ) == 1 )
+              no_gap_found_ledge = TRUE;
+            last_matching_ledge = next_center;
+          }
+        }
+
+        if ( strategy_also_use_edge_detection_for_stems )
+        {
+          /* property - stem right edge points that align               */
+          /* if the center is within range, the center is less than 1/2 */
+          /* the height away                                            */
+          if ( x2_difference_in_width
+                 < center_difference_in_height * deviation1 &&
+               center_difference_in_height
+                 <= (FT_Int)bitmap->rows / 2                )
+          {
+            stem_matches_redge += 1;
+            /* may not need for edges */
+            /*valid_center_average += centers[next_center].x; */
+
+            if ( centers[next_center].x2 - centers[next_center].x1
+                   < smallest_width_redge )
+              smallest_width_redge = centers[next_center].x2
+                                       - centers[next_center].x1;
+
+            /* try to find where the matching centers are far apart */
+            if ( last_matching_redge >= 0 &&
+                 abs( centers[last_matching_redge].y
+                       - centers[next_center].y ) >= (FT_Int)bitmap->rows / 2 )
+
+            /* try to find where matching centers are next to each other */
+            if ( last_matching_redge >= 0 &&
+                 abs( centers[last_matching_redge].y
+                        - centers[next_center].y ) == 1 )
+              no_gap_found_redge = TRUE;
+
+            last_matching_redge = next_center;
+          }
+        }
+
+        next_center++;
+      }
+
+      if ( stem_matches > 0 )
+        valid_center_average /= stem_matches;
+
+      if ( ( stem_matches >= stem_match_requirement             ||
+             ( ( (FT_Int)bitmap->rows <= 6 || ppem < 11 )   &&
+                 stem_matches >= 2                          &&
+                 abs ( valid_center_average
+                       - centers[center].x) < deviation1 /2 ) ||
+            /* try to catch tightly aligned stuff where the matching centers */
+            /* are next to each other only                                   */
+             ( stem_matches == 2                            &&
+                 abs( valid_center_average
+                      - centers[center].x) <= deviation1 /2 &&
+                 no_gap_found                               &&
+                 ppem < 18 )                                    )     &&
+            /* catches things like times 16 u but gets a lot of w's too */
+            /* stem width is less than 1/3 of the bitmap width,         */
+            /* or bitmap_width is small                                 */
+            ( centers[center].x2 - centers[center].x1
+                   < (m_horiAdvance * 12) / 2                       ||
+                m_horiAdvance * 12 <= columns_per_pixel * one_pixel ) )
+      {
+        stem_detected = TRUE;
+        set_width_to  = centers[center].x2 - centers[center].x1;
+        set_center_to = centers[center].x;
+      }
+
+      /* see if edges found anything */
+      if ( strategy_also_use_edge_detection_for_stems && !stem_detected )
+      {
+        /* Require no gap for edges */
+        /* stem width less than 1/3 bitmap width, or bitmap_width is small */
+        /* The stem occurs on the left side of glyph only */
+        if ( ( stem_matches_ledge >= stem_match_requirement &&
+               no_gap_found_ledge                           )        &&
+             ( centers[center].x2 - centers[center].x1
+                 < ( m_horiAdvance * 12 ) / 2 ||
+               m_horiAdvance * 12 <= columns_per_pixel * one_pixel ) &&
+             centers[center].x < ( m_horiAdvance * 12 ) / 2          )
+        {
+          stem_detected = TRUE;
+          set_width_to  = smallest_width_ledge;
+          set_center_to = centers[center].x1 + set_width_to / 2;
+          stem_matches  = stem_matches_ledge;
+        }
+        /* Require no gap for edges                                           */
+        /* stem width is less than 1/3 bitmap width, or bitmap_width is small */
+        /* The stem occurs on the right side of glyph only                    */
+        else if ( ( stem_matches_redge >= stem_match_requirement  &&
+                    no_gap_found_redge                            )       &&
+                  ( centers[center].x2 - centers[center].x1
+                      < ( m_horiAdvance * 12 ) / 2 ||
+                    m_horiAdvance * 12 <= columns_per_pixel * one_pixel ) &&
+                  centers[center].x > (m_horiAdvance * 12) / 2            )
+        {
+          stem_detected = TRUE;
+          set_width_to  = smallest_width_redge;
+          set_center_to = centers[center].x2 - set_width_to / 2;
+          stem_matches  = stem_matches_redge;
+        }
+      }
+
+
+      /*store and/or replace highest occurrences with 3 or more centers */
+      /* because this matched, it will become the top dog regardless */
+      if ( stem_detected && (stem_matches > possible_stems[0].height) )
+      {
+        /* if this is the first stem just go ahead */
+        if ( valid_possible_stems == 0 )
+        {
+          valid_possible_stems = 1;
+          possible_stems[0].center = set_center_to;
+          possible_stems[0].count  = stem_matches;
+          possible_stems[0].width  = set_width_to;
+          possible_stems[0].height = stem_matches;
+        }
+
+        /* otherwise, if there is already a stem */
+        else if ( valid_possible_stems == 1 )
+        {
+          /* if stem is within range of existing one, replace existing one */
+
+          /* if the stem isn't within the range of this one swap it with   */
+          /* next one first                                                */
+          if ( abs ( set_center_to - possible_stems[0].center )
+                 >= one_pixel * 2 )
+          {
+            swap_stem ( &possible_stems[0], &possible_stems[1] );
+            valid_possible_stems = 2;
+          }
+          possible_stems[0].center = set_center_to;
+          possible_stems[0].count  = stem_matches;
+          possible_stems[0].width  = set_width_to;
+          possible_stems[0].height = stem_matches;
+        }
+
+        /* otherwise if there are already 2 stems */
+        else if ( valid_possible_stems >= 2 )
+        {
+          /* if the stem is within the range of existing one, replace     */
+          /* existing one                                                 */
+          if ( abs ( set_center_to - possible_stems[0].center )
+                 <= one_pixel * 2 )
+          {
+            possible_stems[0].center = set_center_to;
+            possible_stems[0].count  = stem_matches;
+            possible_stems[0].width  = set_width_to;
+            possible_stems[0].height = stem_matches;
+          }
+          /* if the stem isn't within the range of this one */
+          else
+          {
+            /* see if within range of next one and swap if so and proceed */
+            /* overwriting it                                             */
+            if ( abs ( set_center_to - possible_stems[1].center )
+                   <= one_pixel * 2 )
+              swap_stem ( &possible_stems[0], &possible_stems[1] );
+
+            /* otherwise see if in range of third one */
+            else if ( abs ( set_center_to - possible_stems[2].center )
+                        <= one_pixel * 2 )
+              swap_stem ( &possible_stems[0], &possible_stems[2] );
+
+            /* otherwise this is the new top dog, so demote everything */
+            else
+            {
+              swap_stem ( &possible_stems[1], &possible_stems[2] );
+              swap_stem ( &possible_stems[0], &possible_stems[1] );
+              valid_possible_stems += 1;
+            }
+            possible_stems[0].center = set_center_to;
+            possible_stems[0].count  = stem_matches;
+            possible_stems[0].width  = set_width_to;
+            possible_stems[0].height = stem_matches;
+          }
+        }
+      }
+
+      else if ( stem_matches > possible_stems[1].height &&
+                set_center_to != 0                      )
+      {
+
+        /* make sure it doesn't match the first stem */
+        if ( abs ( set_center_to - possible_stems[0].center ) >= one_pixel * 2 )
+        {
+
+          /* if this is the second stem */
+          if ( valid_possible_stems == 1 )
+            valid_possible_stems = 2;
+
+          /* otherwise if there is already a stem here */
+          else if ( valid_possible_stems >= 2 )
+          {
+            /* if it doesn't match the second stem, proceed to swap out    */
+            /* with the third.  if it does, replace it                     */
+            if ( abs ( set_center_to - possible_stems[1].center )
+                   >= one_pixel * 2 )
+            {
+              swap_stem ( &possible_stems[1], &possible_stems[2] );
+              valid_possible_stems +=1;
+            }
+          }
+          possible_stems[1].center = set_center_to;
+          possible_stems[1].count  = stem_matches;
+          possible_stems[1].width  = set_width_to;
+          possible_stems[1].height = stem_matches;
+        }
+      }
+
+      else if ( stem_matches > possible_stems[2].height &&
+                set_center_to != 0                      )
+      {
+        /* if it doesn't match the first or second one */
+        if ( abs( set_center_to - possible_stems[0].center) >= one_pixel * 2 &&
+             abs( set_center_to - possible_stems[1].center) >= one_pixel * 2 )
+        {
+          if ( valid_possible_stems == 2 )
+            valid_possible_stems += 1;
+
+          possible_stems[2].center = set_center_to;
+          possible_stems[2].count  = stem_matches;
+          possible_stems[2].width  = set_width_to;
+          possible_stems[1].height = stem_matches;
+        }
+      }
+
+      if ( valid_possible_stems > 3 )
+        valid_possible_stems = 3;
+
+      center++;
+    }
+
+    /* promote to stem */
+    if ( valid_possible_stems > 0 )
+    {
+      stems[0].center    = possible_stems[0].center;
+      stems[0].count     = possible_stems[0].count;
+      stems[0].width     = possible_stems[0].width;
+      stems[0].height    = possible_stems[0].height;
+      stems[0].generated = FALSE;
+      valid_stems++;
+    }
+
+    if ( valid_stems == 1         &&
+         valid_possible_stems > 1 )
+    {
+      stems[1].center    = possible_stems[1].center;
+      stems[1].count     = possible_stems[1].count;
+      stems[1].width     = possible_stems[1].width;
+      stems[1].height    = possible_stems[1].height;
+      stems[1].generated = FALSE;
+      valid_stems++;
+    }
+
+    if ( valid_stems == 2              &&
+         valid_possible_stems > 2      &&
+         possible_stems[2].center != 0 )
+    {
+      stems[2].center    = possible_stems[2].center;
+      stems[2].count     = possible_stems[2].count;
+      stems[2].width     = possible_stems[2].width;
+      stems[2].height    = possible_stems[2].height;
+      stems[2].generated = FALSE;
+      valid_stems++;
+    }
+
+    /* sort stems in x direction */
+    if ( valid_stems == 3 )
+    {
+      if ( stems[0].center > stems[1].center )
+        swap_stem ( &stems[0], &stems[1] );
+
+      if ( stems[0].center > stems[2].center )
+        swap_stem ( &stems[1], &stems[2] );
+
+      if ( stems[1].center > stems[2].center )
+        swap_stem ( &stems[1], &stems[2] );
+
+      if ( stems[0].center > stems[1].center )
+        swap_stem ( &stems[0], &stems[1] );
+
+      /* only look at first and last stem for now */
+      swap_stem ( &stems[1], &stems[2] );
+    }
+
+   /* synthesize stems - Works, but needs work */
+   if ( ( strategy_synthesize_stems      ||
+          known_stem_values->synth_stems ) &&
+          valid_stems  == 0                &&
+          ppem > 10                        )
+    {
+      /* if the leftmost segment's leftmost point is the same as the glyph's */
+      /* leftmost point, and it is of reasonable width, and is not on the    */
+      /* top or bottom of the bitmap                                         */
+      if ( leftmost_segment_not_extrema->x1
+             == leftmost_point_not_extrema             &&
+           abs ( leftmost_segment_not_extrema->x2
+                   - leftmost_segment_not_extrema->x1 )
+             < ( rightmost_point_not_extrema
+                   - leftmost_point_not_extrema ) / 3  &&
+           leftmost_segment_not_extrema->y < height    &&
+           leftmost_segment_not_extrema->y > 1         )
+      {
+        stems[valid_stems].center = ( leftmost_segment_not_extrema->x2
+                                        + leftmost_segment_not_extrema->x1 ) / 2;
+        stems[valid_stems].width = leftmost_segment_not_extrema->x2
+                                        - leftmost_segment_not_extrema->x1;
+        stems[valid_stems].generated = TRUE;
+        valid_stems += 1;
+      }
+
+
+      if ( rightmost_segment_not_extrema->x2
+             == rightmost_point_not_extrema             &&
+           abs ( rightmost_segment_not_extrema->x2
+                   - rightmost_segment_not_extrema->x1 )
+             < ( rightmost_point_not_extrema
+                   - leftmost_point_not_extrema ) / 3   &&
+           rightmost_segment_not_extrema->y < height    &&
+           rightmost_segment_not_extrema->y > 1         )
+      {
+        stems[valid_stems].center = ( rightmost_segment_not_extrema->x2
+                                      + rightmost_segment_not_extrema->x1 ) / 2;
+        stems[valid_stems].width = rightmost_segment_not_extrema->x2
+                                      - rightmost_segment_not_extrema->x1;
+        stems[valid_stems].generated = TRUE;
+        valid_stems += 1;
+      }
+
+    }
+
+    /* sort stems in x direction */
+    if ( valid_stems > 1 && stems[0].center > stems[1].center )
+      swap_stem ( &stems[0], &stems[1] );
+
+    if ( valid_stems == 0 && known_stem_values->stem_translating != 0 )
+    {
+      *translate_value += known_stem_values->stem_translating;
+
+      if ( strategy_use_strengths )
+      {
+        /* consider 1/2 pixel the max when strength is at 100%,
+           unless translate is already greater than that */
+        FT_Int strength_cutoff = 32;
+
+
+        if ( abs ( *translate_value ) > strength_cutoff)
+          strength_cutoff = *translate_value;
+
+        max_strength = ( strength_cutoff * alignment_strength ) / 100;
+
+        if ( *translate_value < -max_strength )
+          *translate_value = -max_strength;
+        else if  ( *translate_value > max_strength )
+          *translate_value = max_strength;
+      }
+    }
+    else
+    /* Start snapping */
+    {
+      FT_Int  center_offset;
+      FT_Int  modulus;
+      FT_Int  delta, delta2;
+      FT_Long stem_distance = 1, new_distance = 1;
+      FT_Int  distance_floor, distance_ceiling;
+      FT_Int  translate_value2 = 0;
+      FT_Int  main_stem = 0;
+      FT_Int  lbearing = m_horiBearingX * 12;
+      FT_Int  bitmap_stem_location = stems[0].center;
+      FT_Int  advance_stem_location = bitmap_stem_location
+                                        + lbearing - one_pixel;
+      FT_Int  advance_width = m_horiAdvance * 12;
+      FT_Int  original_advance_width = 12 * ( slot->linearHoriAdvance >> 10 );
+      FT_Int  glyph_width = rightmost_point - leftmost_point;
+      FT_Int  stem_width = stems[0].width;
+      FT_Int  advance_leftmost_location = leftmost_point
+                                            + lbearing - one_pixel;
+      FT_Int  advance_rightmost_location = rightmost_point
+                                             + lbearing - one_pixel;
+
+#define proposed_transformed_point(point) \
+  point * (float)(new_distance) / (float)(stem_distance) \
+  + *translate_value * 12 - ( stems[main_stem].center * (float)(new_distance) \
+  / (float)(stem_distance) - stems[main_stem].center)
+
+#define proposed_translated_point(point) point + *translate_value * 12
+
+      center_offset = one_pixel / 2;   /* half pixel */
+      modulus = one_pixel;            /* whole pixel */
+
+      /* Determine center_offset via known values */
+      if ( known_stem_values->stem_width >= 0 )
+      {
+        if ( known_stem_values->stem_width % 2 == 0 )
+          center_offset = 0;
+        else
+          center_offset = one_pixel / 2;
+      }
+      /* otherwise do intelligent guessing, if set */
+      else if ( strategy_auto_change_center_offset &&
+                ppem >= STEM_WIDTH_2_PPEM          &&
+                stems[0].width < one_pixel * 1.45  )
+        center_offset = one_pixel / 2;
+      else if ( strategy_auto_change_center_offset &&
+                ppem >= STEM_WIDTH_2_PPEM          &&
+                stems[0].width >= one_pixel * 1.45 &&
+                stems[0].width < one_pixel * 2.6   )
+        center_offset = 0;
+      else if ( strategy_auto_change_center_offset &&
+                ppem >= STEM_WIDTH_2_PPEM          &&
+                stems[0].width >= one_pixel * 2.6  &&
+                stems[0].width < one_pixel * 3.6   )
+        center_offset = one_pixel / 2;
+      else if ( strategy_auto_change_center_offset &&
+                ppem >= STEM_WIDTH_2_PPEM          )
+        center_offset =
+          ( one_pixel
+             * ( ( ( (int)( stems[0].width + one_pixel / 2 ) )
+                             / one_pixel ) % 2 ) ) / 2;
+
+      /* Snap to closest translate and scale values by default */
+      if ( valid_stems >= 1 )
+      {
+        /* closest snapping point for stem 0 */
+        delta = ( stems[0].center  + center_offset ) % modulus;
+
+        if ( delta < modulus / 2 )
+          /* snap left */
+          *translate_value = -delta / ( columns_per_pixel * 4 );
+        else
+           /* snap right */
+          *translate_value = ( modulus - delta ) / ( columns_per_pixel * 4 );
+      }
+
+      if ( strategy_use_d_correction )
+      {
+        /* if the only stem is in the last 1/3 of glyph width, the advance */
+        /* is 6 pixels, the ppem 11, and doing so doesn't violate bitmap , */
+        /* boundaries force it to snap right                               */
+        if ( valid_stems == 1                                  &&
+             advance_stem_location > (advance_width * 2) / 3   &&
+             advance_width == 6 * one_pixel                    &&
+             rightmost_point + modulus - delta
+               <= ( width - (columns_per_pixel * 2) / 3) * 256 &&
+             ppem == 11                                        )
+          *translate_value = ( modulus - delta ) / ( columns_per_pixel * 4 );
+      }
+
+      if ( strategy_use_strengths )
+      {
+        /* consider 1/2 pixel the max when strength is at 100%,
+           unless translate is already greater than that */
+        FT_Int strength_cutoff = 32;
+        if ( abs ( *translate_value ) > strength_cutoff )
+          strength_cutoff = *translate_value;
+
+        max_strength = ( strength_cutoff * alignment_strength ) / 100;
+
+        if ( *translate_value < -max_strength )
+          *translate_value = -max_strength;
+        else if  ( *translate_value > max_strength )
+          *translate_value = max_strength;
+      }
+
+      /* If 2 stems is detected, scale distance
+         between in order to land on pixels */
+      if ( valid_stems >= 2 )
+      {
+        stem_distance = abs ( stems[1].center - stems[0].center );
+
+        delta = stem_distance % modulus;
+        new_distance = stem_distance - delta;
+
+        distance_floor = stem_distance - delta;
+        distance_ceiling = stem_distance + ( modulus - delta );
+
+        if ( delta < modulus / 2 )
+          new_distance = distance_floor;
+        else
+          new_distance = distance_ceiling;
+
+        if ( columns_per_pixel == 3                                    &&
+             valid_stems == 3                                          &&
+             strategy_use_m_control                                    &&
+             ( width - 2 * columns_per_pixel ) > 6 * columns_per_pixel &&
+             ppem > 8                                                  &&
+             ( advance_stem_location - advance_leftmost_location )
+               < stems[main_stem].width * 2                            )
+        {
+          /* Possibly use 2 only when compatible widths is on? */
+          FT_Int mod_factor = 2;
+
+          if ( verbose )
+            printf ( "USING M CONTROL ");
+
+          distance_floor = stem_distance
+                             - stem_distance % ( modulus * mod_factor ) ;
+          distance_ceiling = distance_floor + modulus * mod_factor;
+
+          new_distance = distance_ceiling;
+
+          /* force certain ideal situations */
+          /* these 2 are mostly safe to do */
+          if ( distance_ceiling
+                 + one_pixel * columns_per_pixel == advance_width &&
+               stem_width < one_pixel * 1.25                      )
+            new_distance = distance_ceiling;
+          /* NEED TO FIGURE OUT A WAY TO DETERMINE WHETHER
+             THAT NUDGE IS UP OR DOWN */
+          else if ( stem_distance + one_pixel * 2.6 >= advance_width &&
+            stem_width < one_pixel * 1.25                            )
+            new_distance = distance_ceiling;
+
+          if ( proposed_transformed_point ( leftmost_point )
+                 < one_third_pixel * 2                       ||
+               proposed_transformed_point ( rightmost_point )
+                 > ( width -2 ) * one_third_pixel            )
+            new_distance = distance_floor;
+
+          /* NEED TO IGNORE SERIF Ms HERE */
+          /* perhaps check bitmap boundaries instead??? */
+          if ( strategy_bearing_correction && new_distance == distance_ceiling )
+          {
+            /* Correct if bearings are made substantially worse
+               (more than 1/3 a pixel beyond advance) */
+            if ( proposed_transformed_point( advance_rightmost_location )
+                   > advance_width + one_third_pixel                     &&
+                 proposed_transformed_point( advance_rightmost_location )
+                   > advance_rightmost_location                          &&
+                -proposed_transformed_point( advance_leftmost_location )
+                   < advance_rightmost_location - advance_width          )
+              new_distance = distance_floor;
+          }
+
+          if ( known_stem_values->m >= 0 )
+          {
+            if ( known_stem_values->m == 0 )
+              new_distance = distance_floor;
+            else
+              new_distance = distance_ceiling;
+          }
+
+          if ( ( rightmost_point - leftmost_point) -
+                ( ( rightmost_point * *scale_value)
+                  - ( leftmost_point * *scale_value ) ) >= one_pixel * 1.5 )
+          {
+            *scale_value = 1.0;
+            *translate_value = 0;
+            goto Exit;
+          }
+
+        }
+        else if ( columns_per_pixel == 1                                &&
+                  valid_stems == 3 &&
+                  strategy_use_m_control && valid_stems == 3            &&
+                  width >= 6 * columns_per_pixel                        &&
+                  ppem > 8                                              &&
+                  ( advance_stem_location - advance_leftmost_location )
+                    < stems[main_stem].width * 2                        )
+        {
+          /* Possibly use 2 only when compatible widths is on? */
+          FT_Int mod_factor = 2;
+
+          if ( verbose )
+            printf ("USING M CONTROL ");
+          distance_floor = stem_distance - stem_distance
+                                             % ( modulus * mod_factor) ;
+          distance_ceiling = distance_floor + modulus * mod_factor;
+
+          new_distance = distance_ceiling;
+
+          /* force certain ideal situations */
+          /* these 2 are mostly safe to do */
+          if ( distance_ceiling
+                 + one_pixel * columns_per_pixel == advance_width &&
+               stem_width < one_pixel * 1.25                      )
+            new_distance = distance_ceiling;
+          /* NEED TO FIGURE OUT A WAY TO DETERMINE WHETHER
+            THAT NUDGE IS UP OR DOWN */
+          else if ( stem_distance + one_pixel * 2.6 >= advance_width &&
+                    stem_width < one_pixel * 1.25                    )
+            new_distance = distance_ceiling;
+
+          if ( proposed_transformed_point( leftmost_point ) < 0 ||
+               proposed_transformed_point( rightmost_point )
+                 > width * one_pixel - 2 * one_third_pixel      )
+            new_distance = distance_floor;
+
+          /* NEED TO IGNORE SERIF Ms HERE */
+          /* perhaps check bitmap boundaries instead??? */
+          if ( strategy_bearing_correction && new_distance == distance_ceiling )
+          {
+            /* Correct if bearings are made substantially worse
+               (more than 1/3 a pixel beyond advance) */
+            if ( proposed_transformed_point( advance_rightmost_location )
+                   > advance_width + one_third_pixel                      &&
+                proposed_transformed_point( advance_rightmost_location )
+                   > advance_rightmost_location                           &&
+                -proposed_transformed_point( advance_leftmost_location )
+                   < advance_rightmost_location - advance_width           )
+              new_distance = distance_floor;
+          }
+
+          if ( known_stem_values->m >= 0 )
+          {
+            if ( known_stem_values->m == 0 )
+              new_distance = distance_floor;
+            else
+              new_distance = distance_ceiling;
+          }
+
+
+          if ( ( rightmost_point - leftmost_point )
+                 - ( ( rightmost_point * *scale_value )
+                      - ( leftmost_point * *scale_value ) ) >= one_pixel * 1.5 )
+          {
+            *scale_value = 1.0;
+            *translate_value = 0;
+            goto Exit;
+          }
+
+        }
+        else
+        {
+          if ( strategy_fit_to_width )
+            new_distance = advance_width - 3 * one_pixel;
+          else if ( known_stem_values->stem_scaling >= 0 )
+          {
+            if ( known_stem_values->stem_scaling > 0 )
+              new_distance = distance_ceiling;
+            else
+              new_distance = distance_floor;
+
+            /* enforce advance width boundaries */
+            /* TOO RESTRICTIVE ON SERIF FONTS */
+            if ( proposed_transformed_point( advance_rightmost_location )
+                   >= advance_width                                      ||
+                 proposed_transformed_point( advance_leftmost_location )
+                   <= 0                                                  )
+              new_distance = distance_floor;
+
+            /* enforce literal bitmap boundaries if no translate room */
+            if ( ( proposed_transformed_point(rightmost_point) >= width * 256
+                || proposed_transformed_point(leftmost_point ) <= one_pixel )
+              && new_distance + one_pixel * 3 > advance_width )
+              new_distance = distance_floor;
+
+          }
+          else if ( strategy_translate_using_closest_stem )
+          {
+            /* closest snapping point for stem 1 */
+            delta2 = ( stems[1].center  + center_offset ) % modulus;
+
+            if ( delta2 < modulus / 2 )
+              /* snap left */
+              translate_value2 = -delta2 / ( columns_per_pixel * 4 );
+            else
+               /* snap right */
+              translate_value2 = ( modulus - delta2 )
+                                     / ( columns_per_pixel * 4 );
+
+            if ( abs ( translate_value2 ) < abs ( *translate_value ) )
+            {
+              *translate_value = translate_value2;
+              main_stem = 1;
+            }
+
+          }
+          else if ( strategy_scale_to_closest_centers )
+          {
+            /* closest snapping point for stem 0 */
+            delta  = ( stems[0].center + center_offset ) % modulus;
+            delta2 = ( stems[1].center + center_offset ) % modulus;
+
+            if ( delta < modulus / 2 )
+              /* stretch left */
+              new_distance = delta + stem_distance;
+            else
+              /* stretch right */
+              new_distance = delta - modulus + stem_distance;
+
+            if ( delta2 < modulus / 2 )
+              new_distance -= delta2;  /* stretch left */
+            else
+              new_distance += modulus - delta2; /* stretch right */
+
+          }
+          else if ( strategy_scale_to_closest_centers_up_only )
+          {
+            FT_Int net_change = 0;
+
+            /* closest snapping point for stem 0 */
+            delta  = ( stems[0].center + center_offset ) % modulus;
+            delta2 = ( stems[1].center + center_offset ) % modulus;
+
+            if ( delta < modulus / 2 )
+              net_change = delta;  /* stretch left */
+            else
+              net_change = -( modulus - delta );      /* stretch right */
+
+            if ( delta2 < modulus / 2 )
+              net_change -= delta2;  /* stretch left */
+            else
+              net_change += modulus - delta2;      /* stretch right */
+
+            if ( net_change > 0                                              &&
+                 proposed_transformed_point( advance_rightmost_location )
+                   < advance_width                                           &&
+                 proposed_transformed_point( advance_leftmost_location ) > 0 )
+              new_distance = distance_ceiling;
+          }
+
+          else if ( strategy_always_use_distance_ceiling )
+          {
+            if ( proposed_transformed_point( advance_rightmost_location )
+                   < advance_width                                           &&
+                 proposed_transformed_point( advance_leftmost_location ) > 0 )
+            new_distance = distance_ceiling;
+          }
+        }
+
+        if ( strategy_use_strengths )
+        {
+          FT_Int strength_cutoff = center_offset;
+
+
+          delta2 = new_distance - stem_distance;
+
+          if ( abs ( delta2 ) > strength_cutoff )
+            strength_cutoff = delta2;
+
+          max_strength = ( strength_cutoff * fitting_strength ) / 100;
+
+          if ( delta2 < -max_strength )
+            new_distance = stem_distance - max_strength;
+          else if ( delta2 > max_strength )
+            new_distance = stem_distance + max_strength;
+        }
+
+        *scale_value = (float)( new_distance ) / (float)( stem_distance );
+        *translate_value = *translate_value
+           - ( (float)( stems[main_stem].center * (float)new_distance )
+                      / (float)stem_distance - stems[main_stem].center ) / 12;
+
+        if ( valid_stems == 2 )
+          *embolden_value = ( 64.0 / *scale_value - 64.0 );
+
+        if ( valid_stems == 3 )
+          *embolden_value = ( 64.0 / *scale_value - 64.0 ) / 1.5;
+      }
+
+      if ( verbose )
+        printf ( "%lu stems:", valid_stems );
+
+      if ( valid_stems == 1 && verbose )
+        printf ( "1 stem:    bitmapwidth:%d glyphwidth:%f glyph_width:%f center:%f bearing:%f advance:%f lhadvance:%f stemwidth:%f %d %d",
+                (width - 6) / columns_per_pixel,
+                (float)m_width / 64.0,
+                (float)glyph_width / (float)one_pixel,
+                (float)( (float)advance_stem_location ) / (float)one_pixel,
+                (float)m_horiBearingX / 64.0,
+                (float)m_horiAdvance / 64.0,
+                (float)linearHoriAdvance / 64.0,
+                (float)stems[0].width / (float)one_pixel,
+                advance_width, original_advance_width );
+      else if ( valid_stems >= 2 && verbose )
+        printf ( "%lu stems: bitmapwidth:%d center1:%f center2:%f difference:%f bearing:%f advance:%f advstemloc:%f ",
+                valid_stems,
+                (width - 6) / columns_per_pixel,
+                ( (float)advance_stem_location ) / (float)one_pixel,
+                ( (float)advance_stem_location
+                    + (float)abs ( stems[1].center
+                                     - stems[0].center) ) / (float)one_pixel,
+                ( (float)abs ( stems[1].center
+                                 - stems[0].center ) ) / (float)one_pixel,
+                (float)m_horiBearingX / 64.0,
+                (float)m_horiAdvance / 64.0,
+                (float)advance_stem_location / (float)one_pixel );
+
+      if ( strategy_bearing_correction )
+      {
+        /* Correct if negative bearings are made substantially worse */
+        /* (more than 1/3 a pixel)                                   */
+        if ( proposed_transformed_point( advance_rightmost_location )
+               > advance_width                                       &&
+             proposed_transformed_point( advance_rightmost_location )
+               > advance_rightmost_location                          &&
+             -proposed_transformed_point( advance_leftmost_location )
+               < advance_rightmost_location - advance_width          &&
+             *translate_value
+               > one_third_pixel / ( columns_per_pixel * 4 )         )
+        {
+          *translate_value -=64 ;
+          if ( verbose )
+            printf ( "TRANSLATING -64 " );
+        }
+      }
+      goto Exit;
+    }
+
+  Exit:
+
+#define transformed_point( point ) point * *scale_value + *translate_value * 12
+
+    if ( strategy_correct_out_of_bounds_outlines )
+    {
+      /* Correct if outside bitmap */
+      if ( transformed_point( rightmost_point )
+             >= width * 256 - 2 * one_third_pixel &&
+           transformed_point( leftmost_point )
+             > one_pixel + 2 * one_third_pixel    )
+        *translate_value -=64 ;
+      else if ( transformed_point( leftmost_point )
+                  <= one_pixel / 2                                &&
+                transformed_point( rightmost_point )
+                  <= width * 256 - ( one_pixel +  one_pixel / 2 ) )
+        *translate_value += 64;
+    }
+
+    STVALUES
+    free ( centers );
+    free ( segments );
+    free ( stem_centers );
+    free ( stems );
+    free ( leftmost_segment );
+  }
+
+
+  /* Gamma correction */
+  static void
+  _ft_lcd_gamma_correction_correction ( FT_Bitmap*      bitmap,
+                                        FT_Render_Mode  mode,
+                                        FT_GlyphSlot    slot,
+                                        float           gamma_correction_lt,
+                                        float           gamma_correction_value )
+  {
+    if ( gamma_correction_value != 1.0 )
+    {
+      FT_UInt   width  = (FT_UInt)bitmap->width;
+      FT_UInt   height = (FT_UInt)bitmap->rows;
+      FT_Byte*  line   = bitmap->buffer;
+      float     ppem   = (float)slot->face->size->metrics.x_ppem;
+
+
+      if ( !slot->face || !slot->face->size ) return;
+
+      if ( ppem >= 5 )
+        for ( height = (FT_UInt)bitmap->rows;
+              height > 0;
+              height--, line += bitmap->pitch )
+        {
+          FT_UInt  xx;
+
+
+          for ( xx = 0; xx < width; xx += 1 )
+          {
+            /*normal*/
+            /*line[xx] = pseudo_gamma ( line[xx], gamma_correction_value );*/
+
+            /* sloped */
+            /*line[xx] = pseudo_gamma ( line[xx], gamma_correction_value - 5
+            * (1-gamma_correction_value)/(gamma_correction_lt -5)
+            + ((1-gamma_correction_value)/(gamma_correction_lt -5)) * ppem );*/
+
+            /* 1/3-sloped */
+            line[xx] = pseudo_gamma ( line[xx], gamma_correction_value - 5
+            * ( ( 1 - gamma_correction_value )
+                / ( 3 * ( gamma_correction_lt -5 ) ) )
+            + ( ( 1 - gamma_correction_value )
+                / ( 3 * ( gamma_correction_lt -5) ) ) * ppem );
+          }
+        }
+    }
+  }
+
+#endif
 
   /* convert a slot's glyph image into a bitmap */
   static FT_Error
@@ -103,25 +2328,162 @@
                             FT_Render_Mode    required_mode )
   {
     FT_Error     error;
-    FT_Outline*  outline = &slot->outline;
-    FT_Bitmap*   bitmap  = &slot->bitmap;
-    FT_Memory    memory  = render->root.memory;
+    FT_Outline*  outline = NULL;
+    FT_Outline*  outline_orig = NULL;
     FT_BBox      cbox;
-    FT_Pos       x_shift = 0;
-    FT_Pos       y_shift = 0;
-    FT_Pos       x_left, y_top;
-    FT_Pos       width, height, pitch;
+    FT_Pos       width, height, pitch, ppem;
 #ifndef FT_CONFIG_OPTION_SUBPIXEL_RENDERING
     FT_Pos       height_org, width_org;
 #endif
+    FT_Bitmap*   bitmap  = &slot->bitmap;
+    FT_Memory    memory  = render->root.memory;
     FT_Int       hmul    = mode == FT_RENDER_MODE_LCD;
     FT_Int       vmul    = mode == FT_RENDER_MODE_LCD_V;
+    FT_Pos       x_shift = 0;
+    FT_Pos       y_shift = 0;
+    FT_Pos       x_left, y_top;
 
     FT_Raster_Params  params;
 
-    FT_Bool  have_outline_shifted = FALSE;
-    FT_Bool  have_buffer          = FALSE;
+    FT_Bool  have_translated_origin = FALSE;
+    FT_Bool  have_outline_shifted   = FALSE;
+    FT_Bool  have_buffer            = FALSE;
+
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    FT_Matrix    scaleMat;
+    FT_Long      translate_value = 0;
+    float        scale_value = 1.0;
+    FT_Int       align_called = 0;
+
+
+    int          chromeos_style_sharpening_strength = 0;
+    int          alignment_strength = 0;
+    int          fitting_strength = 0;
+    int          fringe_filter_strength = 0;
+    int          grayscale_filter_strength = 0;
+
+    int          autohint_horizontal_stem_darken_strength = 0;
+    int          autohint_vertical_stem_darken_strength = 0;
+
+    int          windows_style_sharpening_strength = 0;
+    float        gamma_correction_value = 1;
+    float        gamma_correction_lt = 0;
+
+    FT_Int       brightness_value = 0.0;
+    FT_Int       contrast_value = 0.0;
 
+    FT_Int       snapping_sliding_scale_value = 0;
+
+    FT_Int       global_embolden_x_value = 0;
+    FT_Int       global_embolden_y_value = 0;
+
+    FT_Int       bold_embolden_x_value = 0;
+    FT_Int       bold_embolden_y_value = 0;
+
+    FT_Byte      chromeos_cutoff;
+    double       chromeos_gamma_value;
+
+    float        embolden_value = 0.0;
+    FT_Bool      autohinted = FALSE;
+    FT_Bool      use_various_tweaks = FALSE;
+    FT_Pos       cur_width = infinality_cur_width;
+
+    const FT_Int MIN_PPEM = 1;
+    /*const FT_Int    MAX_PPEM = 100;    */
+
+    FT_Bool use_known_settings_on_selected_fonts;
+
+    if ( slot->face                       &&
+         slot->face->size                 &&
+         slot->face->size->metrics.x_ppem )
+      ppem = slot->face->size->metrics.x_ppem;
+    else
+      ppem = 0;
+
+    if ( cur_width )
+    {
+        autohinted = TRUE;
+    }
+    if( ftinf ){
+        const float *f=ftinf->gamma_correction;
+
+        use_known_settings_on_selected_fonts=ftinf->use_known_settings_on_selected_fonts;
+        use_various_tweaks=ftinf->use_various_tweaks;
+        snapping_sliding_scale_value=ftinf->stem_snapping_sliding_scale;
+
+        alignment_strength=ftinf->stem_alignment_strength;
+        if ( snapping_sliding_scale_value != 0 )
+            alignment_strength = sliding_scale(10, snapping_sliding_scale_value, alignment_strength, 100, ppem);
+
+        fitting_strength=ftinf->stem_fitting_strength;
+        if ( snapping_sliding_scale_value != 0 )
+            fitting_strength = sliding_scale(10, snapping_sliding_scale_value, fitting_strength, 100, ppem);
+
+        chromeos_style_sharpening_strength=ftinf->chromeos_style_sharpening_strength;
+
+        if ( ppem > 10 )
+            chromeos_style_sharpening_strength =
+                ( chromeos_style_sharpening_strength * ppem ) / 10;
+
+        if ( chromeos_style_sharpening_strength > 100 )
+            chromeos_style_sharpening_strength = 100;
+
+        brightness_value=ftinf->brightness;
+        contrast_value=ftinf->contrast;
+
+        windows_style_sharpening_strength=ftinf->windows_style_sharpening_strength;
+
+        /* Decrease effect slightly to have a more linear increase in sharpness */
+        windows_style_sharpening_strength =
+            ( ( windows_style_sharpening_strength
+                * windows_style_sharpening_strength ) / 100
+              + windows_style_sharpening_strength ) / 2;
+
+        gamma_correction_lt = f[0];
+        gamma_correction_value = f[1] / 100.0f;
+
+        fringe_filter_strength=ftinf->fringe_filter_strength;
+        grayscale_filter_strength=ftinf->grayscale_filter_strength;
+
+        autohint_horizontal_stem_darken_strength=ftinf->autohint_horizontal_stem_darken_strength;
+        autohint_vertical_stem_darken_strength=ftinf->autohint_vertical_stem_darken_strength;
+
+        global_embolden_x_value=ftinf->global_embolden_x_value;
+        global_embolden_y_value=ftinf->global_embolden_y_value;
+
+        bold_embolden_x_value=ftinf->bold_embolden_x_value;
+        bold_embolden_y_value=ftinf->bold_embolden_y_value;
+    } else {
+        use_known_settings_on_selected_fonts=FALSE;
+    }
+
+    /* set gamma value to 1 if out of range */
+    if ( slot->face                       &&
+         slot->face->size                 &&
+         slot->face->size->metrics.x_ppem )
+    {
+      if ( slot->face->size->metrics.x_ppem >= gamma_correction_lt )
+        gamma_correction_value = 1;
+    }
+    else
+      gamma_correction_value = 1;
+
+    if( use_various_tweaks     &&
+        slot->face             &&
+        slot->face->style_name )
+    {
+      /* needs to also check for artifical italics */
+      if ( strcasestr(slot->face->style_name, "Italic" )  ||
+           strcasestr(slot->face->style_name, "Oblique" ) )
+      {
+        windows_style_sharpening_strength = 0;
+        chromeos_style_sharpening_strength = 0;
+      }
+    }
+
+    /*if (fitting_strength == 100) scale_value = 1.1;*/
+
+#endif
 
     /* check glyph image format */
     if ( slot->format != render->glyph_format )
@@ -137,26 +2499,119 @@
       goto Exit;
     }
 
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+RERENDER:
+    if ( align_called == 1 )
+    {
+      scaleMat.xx = FT_FixedFromFloat(scale_value);
+      scaleMat.xy = 0;
+      scaleMat.yx = 0;
+      scaleMat.yy = ( 1 << 16 );
+
+      FT_Outline_Copy(outline_orig, outline);
+
+      if ( scale_value != 1.0 )
+        FT_Outline_Transform( outline, &scaleMat );
+
+      FT_Outline_Translate( outline, translate_value, 0 );
+
+      FT_Outline_EmboldenXY( outline, embolden_value, 0 );
+    }
+    else
+    {
+#endif
+    outline = &slot->outline;
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+      /* Need to get this PRIOR to embolden, otherwise bad things happen */
+      FT_Outline_Get_CBox( outline, &cbox );
+
+      /* Various hacks that need to be turned into a new rule set */
+      /*if ( !autohinted
+        && use_known_settings_on_selected_fonts
+        && mode == FT_RENDER_MODE_LCD
+        && slot->face->family_name
+        && slot->face->style_name
+        && ( strcasestr(slot->face->family_name, "Courier New" )
+          && ( strcasestr(slot->face->style_name, "Regular" )
+            || strcasestr(slot->face->style_name, "Italic" ) ) ) )
+        FT_Outline_Embolden( outline, 24 );*/
+
+      if ( slot->face )
+      {
+        if ( !autohinted                                              &&
+            use_known_settings_on_selected_fonts                     &&
+            mode == FT_RENDER_MODE_LCD                               &&
+            slot->face->family_name                                  &&
+            slot->face->style_name                                   &&
+            strcasestr( slot->face->family_name, "Times New Roman" ) &&
+            strcasestr( slot->face->style_name, "Italic" )           )
+          FT_Outline_EmboldenXY( outline, 12, 0 );
+
+        if ( use_known_settings_on_selected_fonts              &&
+            autohinted                                        &&
+            mode == FT_RENDER_MODE_LCD                        &&
+            slot->face->family_name                           &&
+            slot->face->style_name                            &&
+            strcasestr(slot->face->family_name, "FreeSerif" ) &&
+            strcasestr(slot->face->style_name, "Italic" )     )
+          FT_Outline_EmboldenXY( outline, 8, 0 );
+
+        if ( global_embolden_x_value != 0 || global_embolden_y_value != 0 )
+              FT_Outline_EmboldenXY( outline,
+                                    global_embolden_x_value,
+                                    global_embolden_y_value );
+
+        if ( ( bold_embolden_x_value != 0 || bold_embolden_y_value != 0 ) &&
+            ( slot->face->style_name                             &&
+            ( strcasestr(slot->face->style_name, "Bold" ) ||
+              strcasestr(slot->face->style_name, "Black"  )    ||
+              ( slot->face->style_flags                      &&
+                slot->face->style_flags & FT_STYLE_FLAG_BOLD ) ) )       )
+          FT_Outline_EmboldenXY( outline,
+                                  bold_embolden_x_value,
+                                  bold_embolden_y_value );
+      }
+
+      FT_Outline_Copy( outline, outline_orig );
+    }
+
+    /* translate the outline to the new origin if needed */
+    if ( align_called == 0 )
+    {
+      FT_Pos enlarge_cbox = 0;
+
+      /* enlarge for grayscale rendering */
+      if ( mode == FT_RENDER_MODE_NORMAL )
+        enlarge_cbox = 64;
+
+      if ( origin )
+      {
+        FT_Outline_Translate( outline, origin->x, origin->y );
+        have_translated_origin = TRUE;
+      }
+
+      /* compute the control box, and grid fit it */
+      /*FT_Outline_Get_CBox( outline, &cbox );*/
+
+      cbox.xMin = FT_PIX_FLOOR( cbox.xMin - enlarge_cbox );
+      cbox.yMin = FT_PIX_FLOOR( cbox.yMin );
+      cbox.xMax = FT_PIX_CEIL( cbox.xMax + enlarge_cbox );
+      cbox.yMax = FT_PIX_CEIL( cbox.yMax );
+#else
     if ( origin )
     {
-      x_shift = origin->x;
-      y_shift = origin->y;
+      FT_Outline_Translate( outline, origin->x, origin->y );
+      have_translated_origin = TRUE;
     }
 
     /* compute the control box, and grid fit it */
-    /* taking into account the origin shift     */
     FT_Outline_Get_CBox( outline, &cbox );
 
-    cbox.xMin = FT_PIX_FLOOR( cbox.xMin + x_shift );
-    cbox.yMin = FT_PIX_FLOOR( cbox.yMin + y_shift );
-    cbox.xMax = FT_PIX_CEIL( cbox.xMax + x_shift );
-    cbox.yMax = FT_PIX_CEIL( cbox.yMax + y_shift );
-
-    x_shift -= cbox.xMin;
-    y_shift -= cbox.yMin;
-
-    x_left  = cbox.xMin >> 6;
-    y_top   = cbox.yMax >> 6;
+    cbox.xMin = FT_PIX_FLOOR( cbox.xMin );
+    cbox.yMin = FT_PIX_FLOOR( cbox.yMin );
+    cbox.xMax = FT_PIX_CEIL( cbox.xMax );
+    cbox.yMax = FT_PIX_CEIL( cbox.yMax );
+#endif
 
     width  = (FT_ULong)( cbox.xMax - cbox.xMin ) >> 6;
     height = (FT_ULong)( cbox.yMax - cbox.yMin ) >> 6;
@@ -166,16 +2621,29 @@
     height_org = height;
 #endif
 
+    /* release old bitmap buffer */
+    if ( slot->internal->flags & FT_GLYPH_OWN_BITMAP )
+    {
+      FT_FREE( bitmap->buffer );
+      slot->internal->flags &= ~FT_GLYPH_OWN_BITMAP;
+    }
+
+    /* allocate new one */
     pitch = width;
     if ( hmul )
     {
-      width *= 3;
-      pitch  = FT_PAD_CEIL( width, 4 );
+      width = width * 3;
+      pitch = FT_PAD_CEIL( width, 4 );
     }
 
     if ( vmul )
       height *= 3;
 
+    x_shift = cbox.xMin;
+    y_shift = cbox.yMin;
+    x_left  = cbox.xMin >> 6;
+    y_top   = cbox.yMax >> 6;
+
 #ifdef FT_CONFIG_OPTION_SUBPIXEL_RENDERING
 
     if ( slot->library->lcd_filter_func )
@@ -185,33 +2653,25 @@
 
       if ( hmul )
       {
-        x_shift += 64 * ( extra >> 1 );
-        x_left  -= extra >> 1;
+        x_shift -= 64 * ( extra >> 1 );
         width   += 3 * extra;
         pitch    = FT_PAD_CEIL( width, 4 );
+        x_left  -= extra >> 1;
       }
 
       if ( vmul )
       {
-        y_shift += 64 * ( extra >> 1 );
-        y_top   += extra >> 1;
+        y_shift -= 64 * ( extra >> 1 );
         height  += 3 * extra;
+        y_top   += extra >> 1;
       }
     }
-
 #endif
-
-    /*
-     * XXX: on 16bit system, we return an error for huge bitmap
-     * to prevent an overflow.
-     */
-    if ( x_left > FT_INT_MAX || y_top > FT_INT_MAX ||
-         x_left < FT_INT_MIN || y_top < FT_INT_MIN )
-    {
-      error = FT_THROW( Invalid_Pixel_Size );
-      goto Exit;
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
     }
 
+#endif
+
     /* Required check is (pitch * height < FT_ULONG_MAX),        */
     /* but we care realistic cases only.  Always pitch <= width. */
     if ( width > 0x7FFF || height > 0x7FFF )
@@ -222,6 +2682,22 @@
       goto Exit;
     }
 
+    bitmap->pixel_mode = FT_PIXEL_MODE_GRAY;
+    bitmap->num_grays  = 256;
+    bitmap->width      = (unsigned int)width;
+    bitmap->rows       = (unsigned int)height;
+    bitmap->pitch      = pitch;
+
+    /* translate outline to render it into the bitmap */
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    if ( align_called == 0 )
+    {
+#endif
+    FT_Outline_Translate( outline, -x_shift, -y_shift );
+    have_outline_shifted = TRUE;
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    }
+#endif
     /* release old bitmap buffer */
     if ( slot->internal->flags & FT_GLYPH_OWN_BITMAP )
     {
@@ -229,7 +2705,6 @@
       slot->internal->flags &= ~FT_GLYPH_OWN_BITMAP;
     }
 
-    /* allocate new one */
     if ( FT_ALLOC( bitmap->buffer, (FT_ULong)( pitch * height ) ) )
       goto Exit;
     else
@@ -237,23 +2712,6 @@
 
     slot->internal->flags |= FT_GLYPH_OWN_BITMAP;
 
-    slot->format      = FT_GLYPH_FORMAT_BITMAP;
-    slot->bitmap_left = (FT_Int)x_left;
-    slot->bitmap_top  = (FT_Int)y_top;
-
-    bitmap->pixel_mode = FT_PIXEL_MODE_GRAY;
-    bitmap->num_grays  = 256;
-    bitmap->width      = (unsigned int)width;
-    bitmap->rows       = (unsigned int)height;
-    bitmap->pitch      = pitch;
-
-    /* translate outline to render it into the bitmap */
-    if ( x_shift || y_shift )
-    {
-      FT_Outline_Translate( outline, x_shift, y_shift );
-      have_outline_shifted = TRUE;
-    }
-
     /* set up parameters */
     params.target = bitmap;
     params.source = outline;
@@ -299,9 +2757,153 @@
     if ( error )
       goto Exit;
 
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    if ( ppem <= MAX_PPEM && ppem >= MIN_PPEM )
+    {
+      if ( align_called == 0                                  &&  cur_width / ppem < 10 &&
+           ( alignment_strength > 0 || fitting_strength > 0 ) )
+        _lcd_stem_align ( bitmap,
+                          mode,
+                          slot,
+                          &translate_value,
+                          &scale_value,
+                          alignment_strength,
+                          fitting_strength,
+                          &embolden_value );
+
+      if ( align_called == 0                              &&
+           ( translate_value != 0 || scale_value != 1.0 ) )
+      {
+        align_called = 1;
+        goto RERENDER;
+      }
+
+      if ( mode == FT_RENDER_MODE_LCD )
+      {
+
+        if ( fringe_filter_strength > 0 /*&& autohinted*/ )
+          _ft_lcd_fringe_filter( bitmap,
+                                 mode,
+                                 fringe_filter_strength,
+                                 slot->library );
+
+        /*if ( autohinted)
+          _ft_lcd_stem_end_filter( bitmap, mode, 100, slot->library );*/
+
+        if ( gamma_correction_lt > 0 && gamma_correction_value != 1.0 )
+          _ft_lcd_gamma_correction_correction( bitmap,
+                                               mode,
+                                               slot,
+                                               gamma_correction_lt,
+                                               gamma_correction_value );
+
+        chromeos_cutoff = (FT_Byte)( 0.5 * 255.0 )
+                            * ( chromeos_style_sharpening_strength / 100.0 );
+        chromeos_gamma_value = 1;
+
+        if ( chromeos_style_sharpening_strength > 0 )
+          _ft_lcd_chromeos_sharpen( bitmap,
+                                    mode,
+                                    chromeos_cutoff,
+                                    chromeos_gamma_value );
+
+        if ( ppem > 8 )
+          if ( windows_style_sharpening_strength > 0 )
+            _ft_lcd_windows_sharpen( bitmap,
+                                     mode,
+                                     windows_style_sharpening_strength,
+                                     slot->library );
+
+        if ( autohinted                                    &&
+             ( cur_width * 100 ) / 64
+               > autohint_horizontal_stem_darken_strength  &&
+             autohint_horizontal_stem_darken_strength != 0 )
+          autohint_horizontal_stem_darken_strength = ( cur_width * 100 ) / 64;
+
+        if ( autohint_horizontal_stem_darken_strength > 100)
+          autohint_horizontal_stem_darken_strength = 100;
+
+        /* only do on autohinted fonts */
+        /* Necessary to do on some non-thin fonts, which is why it is outside */
+        /* of the below conditional */
+        if ( autohint_horizontal_stem_darken_strength > 0 && autohinted )
+          _ft_lcd_darken_x ( bitmap,
+                             mode,
+                             autohint_horizontal_stem_darken_strength,
+                             slot->library );
+
+        /* Enhance thin fonts */
+        if ( autohinted )
+        {
+          /* if forcibly set use that, otherwise make a good estimate */
+          float contrast, brightness;
+          ftinf_get_bc( slot->face->family_name, ppem, &brightness, &contrast);
+          if ( slot->face && !_ft_bitmap_bc ( bitmap, brightness, contrast ) )
+          {
+            FT_Bool is_fixed_name = FALSE;
+
+            if ( slot->face->family_name                      &&
+                 strcasestr(slot->face->family_name, "Mono" ) )
+              is_fixed_name = TRUE;
+
+            /* Darken vertical stems */
+            _ft_lcd_darken_y ( bitmap,
+                               mode,
+                               autohint_vertical_stem_darken_strength,
+                               slot->library );
+
+            /* Adjust brightness / contrast automatically based on stem width */
+            if ( cur_width != 0 && cur_width < 30 )
+              cur_width = 30;
+
+            if ( cur_width >= 30 && cur_width <= 60 )
+            {
+              float ppem_factor       = sliding_scale ( 5, 11, 0.0, 1.0, ppem );
+              float brightness_factor = sliding_scale ( 30, 52, -.3, 0.0,
+                                                        cur_width );
+              float contrast_factor   = sliding_scale ( 30, 52, .45, 0.0,
+                                                        cur_width );
+              _ft_bitmap_bc ( bitmap,
+                              ppem_factor * brightness_factor,
+                              ppem_factor * contrast_factor );
+
+              /* Only cap variable width thin-stemmed fonts */
+              if ( !FT_IS_FIXED_WIDTH( slot->face ) && !is_fixed_name )
+                _ft_bitmap_cap ( bitmap,
+                                 ( cur_width * 150 ) / 64,
+                                 slot->library );
+            }
+          }
+        }
+
+
+        if ( slot->library->lcd_filter_func )
+          slot->library->lcd_filter_func( bitmap, mode, slot->library );
+
+        if ( grayscale_filter_strength > 0 )
+          _ft_lcd_grayscale_filter( bitmap,
+                                    mode,
+                                    grayscale_filter_strength,
+                                    slot->library );
+
+      }
+
+      /* Global values */
+      if ( brightness_value != 0 || contrast_value != 0 )
+        _ft_bitmap_bc ( bitmap,
+                        (float)brightness_value / 300.0,
+                        (float)contrast_value / 300.0);
+
+      FT_Outline_Done( slot->library, outline_orig );
+    }
+    else if ( mode == FT_RENDER_MODE_LCD     &&
+              slot->library->lcd_filter_func )
+          slot->library->lcd_filter_func( bitmap, mode, slot->library );
+#else
     if ( slot->library->lcd_filter_func )
       slot->library->lcd_filter_func( bitmap, mode, slot->library );
 
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
 #else /* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */
 
     /* render outline into bitmap */
@@ -359,6 +2961,20 @@
 
 #endif /* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */
 
+    /*
+     * XXX: on 16bit system, we return an error for huge bitmap
+     * to prevent an overflow.
+     */
+    if ( x_left > FT_INT_MAX || y_top > FT_INT_MAX )
+    {
+      error = FT_THROW( Invalid_Pixel_Size );
+      goto Exit;
+    }
+
+    slot->format      = FT_GLYPH_FORMAT_BITMAP;
+    slot->bitmap_left = (FT_Int)x_left;
+    slot->bitmap_top  = (FT_Int)y_top;
+
     /* everything is fine; don't deallocate buffer */
     have_buffer = FALSE;
 
@@ -366,7 +2982,9 @@
 
   Exit:
     if ( have_outline_shifted )
-      FT_Outline_Translate( outline, -x_shift, -y_shift );
+      FT_Outline_Translate( outline, x_shift, y_shift );
+    if ( have_translated_origin )
+      FT_Outline_Translate( outline, -origin->x, -origin->y );
     if ( have_buffer )
     {
       FT_FREE( bitmap->buffer );
diff -ruN freetype-2.7-orig/src/truetype/ttinterp.c freetype-2.7/src/truetype/ttinterp.c
--- freetype-2.7-orig/src/truetype/ttinterp.c	2016-09-08 08:53:04.000000000 +0200
+++ freetype-2.7/src/truetype/ttinterp.c	2016-09-09 16:01:22.468500777 +0200
@@ -5721,6 +5721,7 @@
 
       if ( exc->ignore_x_mode                                 &&
            exc->GS.freeVector.x != 0                          &&
+           exc->GS.freeVector.y == 0                          &&
            !( exc->sph_tweak_flags & SPH_TWEAK_NORMAL_ROUND ) )
         control_value_cutin = 0;
     }
diff -ruN freetype-2.7-orig/src/truetype/ttinterp.c.orig freetype-2.7/src/truetype/ttinterp.c.orig
--- freetype-2.7-orig/src/truetype/ttinterp.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ freetype-2.7/src/truetype/ttinterp.c.orig	2016-09-08 08:53:04.000000000 +0200
@@ -0,0 +1,8356 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ttinterp.c                                                             */
+/*                                                                         */
+/*    TrueType bytecode interpreter (body).                                */
+/*                                                                         */
+/*  Copyright 1996-2016 by                                                 */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+/* Greg Hitchcock from Microsoft has helped a lot in resolving unclear */
+/* issues; many thanks!                                                */
+
+
+#include <ft2build.h>
+#include FT_INTERNAL_DEBUG_H
+#include FT_INTERNAL_CALC_H
+#include FT_TRIGONOMETRY_H
+#include FT_SYSTEM_H
+#include FT_TRUETYPE_DRIVER_H
+#include FT_MULTIPLE_MASTERS_H
+
+#include "ttinterp.h"
+#include "tterrors.h"
+#include "ttsubpix.h"
+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
+#include "ttgxvar.h"
+#endif
+
+
+#ifdef TT_USE_BYTECODE_INTERPRETER
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */
+  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */
+  /* messages during execution.                                            */
+  /*                                                                       */
+#undef  FT_COMPONENT
+#define FT_COMPONENT  trace_ttinterp
+
+
+#define NO_SUBPIXEL_HINTING                                                  \
+          ( ((TT_Driver)FT_FACE_DRIVER( exc->face ))->interpreter_version == \
+            TT_INTERPRETER_VERSION_35 )
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+#define SUBPIXEL_HINTING_INFINALITY                                          \
+          ( ((TT_Driver)FT_FACE_DRIVER( exc->face ))->interpreter_version == \
+            TT_INTERPRETER_VERSION_38 )
+#endif
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
+#define SUBPIXEL_HINTING_MINIMAL                                             \
+          ( ((TT_Driver)FT_FACE_DRIVER( exc->face ))->interpreter_version == \
+            TT_INTERPRETER_VERSION_40 )
+#endif
+
+#define PROJECT( v1, v2 )                                                \
+          exc->func_project( exc, (v1)->x - (v2)->x, (v1)->y - (v2)->y )
+
+#define DUALPROJ( v1, v2 )                                                \
+          exc->func_dualproj( exc, (v1)->x - (v2)->x, (v1)->y - (v2)->y )
+
+#define FAST_PROJECT( v )                          \
+          exc->func_project( exc, (v)->x, (v)->y )
+
+#define FAST_DUALPROJ( v )                          \
+          exc->func_dualproj( exc, (v)->x, (v)->y )
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Two simple bounds-checking macros.                                    */
+  /*                                                                       */
+#define BOUNDS( x, n )   ( (FT_UInt)(x)  >= (FT_UInt)(n)  )
+#define BOUNDSL( x, n )  ( (FT_ULong)(x) >= (FT_ULong)(n) )
+
+
+#undef  SUCCESS
+#define SUCCESS  0
+
+#undef  FAILURE
+#define FAILURE  1
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /*                        CODERANGE FUNCTIONS                            */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    TT_Goto_CodeRange                                                  */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Switches to a new code range (updates the code related elements in */
+  /*    `exec', and `IP').                                                 */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    range :: The new execution code range.                             */
+  /*                                                                       */
+  /*    IP    :: The new IP in the new code range.                         */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    exec  :: The target execution context.                             */
+  /*                                                                       */
+  FT_LOCAL_DEF( void )
+  TT_Goto_CodeRange( TT_ExecContext  exec,
+                     FT_Int          range,
+                     FT_Long         IP )
+  {
+    TT_CodeRange*  coderange;
+
+
+    FT_ASSERT( range >= 1 && range <= 3 );
+
+    coderange = &exec->codeRangeTable[range - 1];
+
+    FT_ASSERT( coderange->base != NULL );
+
+    /* NOTE: Because the last instruction of a program may be a CALL */
+    /*       which will return to the first byte *after* the code    */
+    /*       range, we test for IP <= Size instead of IP < Size.     */
+    /*                                                               */
+    FT_ASSERT( IP <= coderange->size );
+
+    exec->code     = coderange->base;
+    exec->codeSize = coderange->size;
+    exec->IP       = IP;
+    exec->curRange = range;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    TT_Set_CodeRange                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Sets a code range.                                                 */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    range  :: The code range index.                                    */
+  /*                                                                       */
+  /*    base   :: The new code base.                                       */
+  /*                                                                       */
+  /*    length :: The range size in bytes.                                 */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    exec   :: The target execution context.                            */
+  /*                                                                       */
+  FT_LOCAL_DEF( void )
+  TT_Set_CodeRange( TT_ExecContext  exec,
+                    FT_Int          range,
+                    void*           base,
+                    FT_Long         length )
+  {
+    FT_ASSERT( range >= 1 && range <= 3 );
+
+    exec->codeRangeTable[range - 1].base = (FT_Byte*)base;
+    exec->codeRangeTable[range - 1].size = length;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    TT_Clear_CodeRange                                                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Clears a code range.                                               */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    range :: The code range index.                                     */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    exec  :: The target execution context.                             */
+  /*                                                                       */
+  FT_LOCAL_DEF( void )
+  TT_Clear_CodeRange( TT_ExecContext  exec,
+                      FT_Int          range )
+  {
+    FT_ASSERT( range >= 1 && range <= 3 );
+
+    exec->codeRangeTable[range - 1].base = NULL;
+    exec->codeRangeTable[range - 1].size = 0;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /*                   EXECUTION CONTEXT ROUTINES                          */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    TT_Done_Context                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Destroys a given context.                                          */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    exec   :: A handle to the target execution context.                */
+  /*                                                                       */
+  /*    memory :: A handle to the parent memory object.                    */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    Only the glyph loader and debugger should call this function.      */
+  /*                                                                       */
+  FT_LOCAL_DEF( void )
+  TT_Done_Context( TT_ExecContext  exec )
+  {
+    FT_Memory  memory = exec->memory;
+
+
+    /* points zone */
+    exec->maxPoints   = 0;
+    exec->maxContours = 0;
+
+    /* free stack */
+    FT_FREE( exec->stack );
+    exec->stackSize = 0;
+
+    /* free call stack */
+    FT_FREE( exec->callStack );
+    exec->callSize = 0;
+    exec->callTop  = 0;
+
+    /* free glyph code range */
+    FT_FREE( exec->glyphIns );
+    exec->glyphSize = 0;
+
+    exec->size = NULL;
+    exec->face = NULL;
+
+    FT_FREE( exec );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    Init_Context                                                       */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Initializes a context object.                                      */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    memory :: A handle to the parent memory object.                    */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    exec   :: A handle to the target execution context.                */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0 means success.                             */
+  /*                                                                       */
+  static FT_Error
+  Init_Context( TT_ExecContext  exec,
+                FT_Memory       memory )
+  {
+    FT_Error  error;
+
+
+    FT_TRACE1(( "Init_Context: new object at 0x%08p\n", exec ));
+
+    exec->memory   = memory;
+    exec->callSize = 32;
+
+    if ( FT_NEW_ARRAY( exec->callStack, exec->callSize ) )
+      goto Fail_Memory;
+
+    /* all values in the context are set to 0 already, but this is */
+    /* here as a remainder                                         */
+    exec->maxPoints   = 0;
+    exec->maxContours = 0;
+
+    exec->stackSize = 0;
+    exec->glyphSize = 0;
+
+    exec->stack    = NULL;
+    exec->glyphIns = NULL;
+
+    exec->face = NULL;
+    exec->size = NULL;
+
+    return FT_Err_Ok;
+
+  Fail_Memory:
+    FT_ERROR(( "Init_Context: not enough memory for %p\n", exec ));
+    TT_Done_Context( exec );
+
+    return error;
+ }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    Update_Max                                                         */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Checks the size of a buffer and reallocates it if necessary.       */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    memory     :: A handle to the parent memory object.                */
+  /*                                                                       */
+  /*    multiplier :: The size in bytes of each element in the buffer.     */
+  /*                                                                       */
+  /*    new_max    :: The new capacity (size) of the buffer.               */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    size       :: The address of the buffer's current size expressed   */
+  /*                  in elements.                                         */
+  /*                                                                       */
+  /*    buff       :: The address of the buffer base pointer.              */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0 means success.                             */
+  /*                                                                       */
+  FT_LOCAL_DEF( FT_Error )
+  Update_Max( FT_Memory  memory,
+              FT_ULong*  size,
+              FT_ULong   multiplier,
+              void*      _pbuff,
+              FT_ULong   new_max )
+  {
+    FT_Error  error;
+    void**    pbuff = (void**)_pbuff;
+
+
+    if ( *size < new_max )
+    {
+      if ( FT_REALLOC( *pbuff, *size * multiplier, new_max * multiplier ) )
+        return error;
+      *size = new_max;
+    }
+
+    return FT_Err_Ok;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    TT_Load_Context                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Prepare an execution context for glyph hinting.                    */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    face :: A handle to the source face object.                        */
+  /*                                                                       */
+  /*    size :: A handle to the source size object.                        */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    exec :: A handle to the target execution context.                  */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    FreeType error code.  0 means success.                             */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    Only the glyph loader and debugger should call this function.      */
+  /*                                                                       */
+  FT_LOCAL_DEF( FT_Error )
+  TT_Load_Context( TT_ExecContext  exec,
+                   TT_Face         face,
+                   TT_Size         size )
+  {
+    FT_Int          i;
+    FT_ULong        tmp;
+    TT_MaxProfile*  maxp;
+    FT_Error        error;
+
+
+    exec->face = face;
+    maxp       = &face->max_profile;
+    exec->size = size;
+
+    if ( size )
+    {
+      exec->numFDefs   = size->num_function_defs;
+      exec->maxFDefs   = size->max_function_defs;
+      exec->numIDefs   = size->num_instruction_defs;
+      exec->maxIDefs   = size->max_instruction_defs;
+      exec->FDefs      = size->function_defs;
+      exec->IDefs      = size->instruction_defs;
+      exec->pointSize  = size->point_size;
+      exec->tt_metrics = size->ttmetrics;
+      exec->metrics    = size->metrics;
+
+      exec->maxFunc    = size->max_func;
+      exec->maxIns     = size->max_ins;
+
+      for ( i = 0; i < TT_MAX_CODE_RANGES; i++ )
+        exec->codeRangeTable[i] = size->codeRangeTable[i];
+
+      /* set graphics state */
+      exec->GS = size->GS;
+
+      exec->cvtSize = size->cvt_size;
+      exec->cvt     = size->cvt;
+
+      exec->storeSize = size->storage_size;
+      exec->storage   = size->storage;
+
+      exec->twilight  = size->twilight;
+
+      /* In case of multi-threading it can happen that the old size object */
+      /* no longer exists, thus we must clear all glyph zone references.   */
+      ft_memset( &exec->zp0, 0, sizeof ( exec->zp0 ) );
+      exec->zp1 = exec->zp0;
+      exec->zp2 = exec->zp0;
+    }
+
+    /* XXX: We reserve a little more elements on the stack to deal safely */
+    /*      with broken fonts like arialbs, courbs, timesbs, etc.         */
+    tmp = (FT_ULong)exec->stackSize;
+    error = Update_Max( exec->memory,
+                        &tmp,
+                        sizeof ( FT_F26Dot6 ),
+                        (void*)&exec->stack,
+                        maxp->maxStackElements + 32 );
+    exec->stackSize = (FT_Long)tmp;
+    if ( error )
+      return error;
+
+    tmp = exec->glyphSize;
+    error = Update_Max( exec->memory,
+                        &tmp,
+                        sizeof ( FT_Byte ),
+                        (void*)&exec->glyphIns,
+                        maxp->maxSizeOfInstructions );
+    exec->glyphSize = (FT_UShort)tmp;
+    if ( error )
+      return error;
+
+    exec->pts.n_points   = 0;
+    exec->pts.n_contours = 0;
+
+    exec->zp1 = exec->pts;
+    exec->zp2 = exec->pts;
+    exec->zp0 = exec->pts;
+
+    exec->instruction_trap = FALSE;
+
+    return FT_Err_Ok;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    TT_Save_Context                                                    */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Saves the code ranges in a `size' object.                          */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    exec :: A handle to the source execution context.                  */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    size :: A handle to the target size object.                        */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    Only the glyph loader and debugger should call this function.      */
+  /*                                                                       */
+  FT_LOCAL_DEF( void )
+  TT_Save_Context( TT_ExecContext  exec,
+                   TT_Size         size )
+  {
+    FT_Int  i;
+
+
+    /* XXX: Will probably disappear soon with all the code range */
+    /*      management, which is now rather obsolete.            */
+    /*                                                           */
+    size->num_function_defs    = exec->numFDefs;
+    size->num_instruction_defs = exec->numIDefs;
+
+    size->max_func = exec->maxFunc;
+    size->max_ins  = exec->maxIns;
+
+    for ( i = 0; i < TT_MAX_CODE_RANGES; i++ )
+      size->codeRangeTable[i] = exec->codeRangeTable[i];
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    TT_Run_Context                                                     */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Executes one or more instructions in the execution context.        */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    debug :: A Boolean flag.  If set, the function sets some internal  */
+  /*             variables and returns immediately, otherwise TT_RunIns()  */
+  /*             is called.                                                */
+  /*                                                                       */
+  /*             This is commented out currently.                          */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    exec  :: A handle to the target execution context.                 */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    TrueType error code.  0 means success.                             */
+  /*                                                                       */
+  FT_LOCAL_DEF( FT_Error )
+  TT_Run_Context( TT_ExecContext  exec )
+  {
+    TT_Goto_CodeRange( exec, tt_coderange_glyph, 0 );
+
+    exec->zp0 = exec->pts;
+    exec->zp1 = exec->pts;
+    exec->zp2 = exec->pts;
+
+    exec->GS.gep0 = 1;
+    exec->GS.gep1 = 1;
+    exec->GS.gep2 = 1;
+
+    exec->GS.projVector.x = 0x4000;
+    exec->GS.projVector.y = 0x0000;
+
+    exec->GS.freeVector = exec->GS.projVector;
+    exec->GS.dualVector = exec->GS.projVector;
+
+    exec->GS.round_state = 1;
+    exec->GS.loop        = 1;
+
+    /* some glyphs leave something on the stack. so we clean it */
+    /* before a new execution.                                  */
+    exec->top     = 0;
+    exec->callTop = 0;
+
+    return exec->face->interpreter( exec );
+  }
+
+
+  /* The default value for `scan_control' is documented as FALSE in the */
+  /* TrueType specification.  This is confusing since it implies a      */
+  /* Boolean value.  However, this is not the case, thus both the       */
+  /* default values of our `scan_type' and `scan_control' fields (which */
+  /* the documentation's `scan_control' variable is split into) are     */
+  /* zero.                                                              */
+
+  const TT_GraphicsState  tt_default_graphics_state =
+  {
+    0, 0, 0,
+    { 0x4000, 0 },
+    { 0x4000, 0 },
+    { 0x4000, 0 },
+
+    1, 64, 1,
+    TRUE, 68, 0, 0, 9, 3,
+    0, FALSE, 0, 1, 1, 1
+  };
+
+
+  /* documentation is in ttinterp.h */
+
+  FT_EXPORT_DEF( TT_ExecContext )
+  TT_New_Context( TT_Driver  driver )
+  {
+    FT_Memory  memory;
+    FT_Error   error;
+
+    TT_ExecContext  exec = NULL;
+
+
+    if ( !driver )
+      goto Fail;
+
+    memory = driver->root.root.memory;
+
+    /* allocate object */
+    if ( FT_NEW( exec ) )
+      goto Fail;
+
+    /* initialize it; in case of error this deallocates `exec' too */
+    error = Init_Context( exec, memory );
+    if ( error )
+      goto Fail;
+
+    return exec;
+
+  Fail:
+    return NULL;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Before an opcode is executed, the interpreter verifies that there are */
+  /* enough arguments on the stack, with the help of the `Pop_Push_Count'  */
+  /* table.                                                                */
+  /*                                                                       */
+  /* For each opcode, the first column gives the number of arguments that  */
+  /* are popped from the stack; the second one gives the number of those   */
+  /* that are pushed in result.                                            */
+  /*                                                                       */
+  /* Opcodes which have a varying number of parameters in the data stream  */
+  /* (NPUSHB, NPUSHW) are handled specially; they have a negative value in */
+  /* the `opcode_length' table, and the value in `Pop_Push_Count' is set   */
+  /* to zero.                                                              */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+#undef  PACK
+#define PACK( x, y )  ( ( x << 4 ) | y )
+
+
+  static
+  const FT_Byte  Pop_Push_Count[256] =
+  {
+    /* opcodes are gathered in groups of 16 */
+    /* please keep the spaces as they are   */
+
+    /*  SVTCA  y  */  PACK( 0, 0 ),
+    /*  SVTCA  x  */  PACK( 0, 0 ),
+    /*  SPvTCA y  */  PACK( 0, 0 ),
+    /*  SPvTCA x  */  PACK( 0, 0 ),
+    /*  SFvTCA y  */  PACK( 0, 0 ),
+    /*  SFvTCA x  */  PACK( 0, 0 ),
+    /*  SPvTL //  */  PACK( 2, 0 ),
+    /*  SPvTL +   */  PACK( 2, 0 ),
+    /*  SFvTL //  */  PACK( 2, 0 ),
+    /*  SFvTL +   */  PACK( 2, 0 ),
+    /*  SPvFS     */  PACK( 2, 0 ),
+    /*  SFvFS     */  PACK( 2, 0 ),
+    /*  GPv       */  PACK( 0, 2 ),
+    /*  GFv       */  PACK( 0, 2 ),
+    /*  SFvTPv    */  PACK( 0, 0 ),
+    /*  ISECT     */  PACK( 5, 0 ),
+
+    /*  SRP0      */  PACK( 1, 0 ),
+    /*  SRP1      */  PACK( 1, 0 ),
+    /*  SRP2      */  PACK( 1, 0 ),
+    /*  SZP0      */  PACK( 1, 0 ),
+    /*  SZP1      */  PACK( 1, 0 ),
+    /*  SZP2      */  PACK( 1, 0 ),
+    /*  SZPS      */  PACK( 1, 0 ),
+    /*  SLOOP     */  PACK( 1, 0 ),
+    /*  RTG       */  PACK( 0, 0 ),
+    /*  RTHG      */  PACK( 0, 0 ),
+    /*  SMD       */  PACK( 1, 0 ),
+    /*  ELSE      */  PACK( 0, 0 ),
+    /*  JMPR      */  PACK( 1, 0 ),
+    /*  SCvTCi    */  PACK( 1, 0 ),
+    /*  SSwCi     */  PACK( 1, 0 ),
+    /*  SSW       */  PACK( 1, 0 ),
+
+    /*  DUP       */  PACK( 1, 2 ),
+    /*  POP       */  PACK( 1, 0 ),
+    /*  CLEAR     */  PACK( 0, 0 ),
+    /*  SWAP      */  PACK( 2, 2 ),
+    /*  DEPTH     */  PACK( 0, 1 ),
+    /*  CINDEX    */  PACK( 1, 1 ),
+    /*  MINDEX    */  PACK( 1, 0 ),
+    /*  AlignPTS  */  PACK( 2, 0 ),
+    /*  INS_$28   */  PACK( 0, 0 ),
+    /*  UTP       */  PACK( 1, 0 ),
+    /*  LOOPCALL  */  PACK( 2, 0 ),
+    /*  CALL      */  PACK( 1, 0 ),
+    /*  FDEF      */  PACK( 1, 0 ),
+    /*  ENDF      */  PACK( 0, 0 ),
+    /*  MDAP[0]   */  PACK( 1, 0 ),
+    /*  MDAP[1]   */  PACK( 1, 0 ),
+
+    /*  IUP[0]    */  PACK( 0, 0 ),
+    /*  IUP[1]    */  PACK( 0, 0 ),
+    /*  SHP[0]    */  PACK( 0, 0 ), /* loops */
+    /*  SHP[1]    */  PACK( 0, 0 ), /* loops */
+    /*  SHC[0]    */  PACK( 1, 0 ),
+    /*  SHC[1]    */  PACK( 1, 0 ),
+    /*  SHZ[0]    */  PACK( 1, 0 ),
+    /*  SHZ[1]    */  PACK( 1, 0 ),
+    /*  SHPIX     */  PACK( 1, 0 ), /* loops */
+    /*  IP        */  PACK( 0, 0 ), /* loops */
+    /*  MSIRP[0]  */  PACK( 2, 0 ),
+    /*  MSIRP[1]  */  PACK( 2, 0 ),
+    /*  AlignRP   */  PACK( 0, 0 ), /* loops */
+    /*  RTDG      */  PACK( 0, 0 ),
+    /*  MIAP[0]   */  PACK( 2, 0 ),
+    /*  MIAP[1]   */  PACK( 2, 0 ),
+
+    /*  NPushB    */  PACK( 0, 0 ),
+    /*  NPushW    */  PACK( 0, 0 ),
+    /*  WS        */  PACK( 2, 0 ),
+    /*  RS        */  PACK( 1, 1 ),
+    /*  WCvtP     */  PACK( 2, 0 ),
+    /*  RCvt      */  PACK( 1, 1 ),
+    /*  GC[0]     */  PACK( 1, 1 ),
+    /*  GC[1]     */  PACK( 1, 1 ),
+    /*  SCFS      */  PACK( 2, 0 ),
+    /*  MD[0]     */  PACK( 2, 1 ),
+    /*  MD[1]     */  PACK( 2, 1 ),
+    /*  MPPEM     */  PACK( 0, 1 ),
+    /*  MPS       */  PACK( 0, 1 ),
+    /*  FlipON    */  PACK( 0, 0 ),
+    /*  FlipOFF   */  PACK( 0, 0 ),
+    /*  DEBUG     */  PACK( 1, 0 ),
+
+    /*  LT        */  PACK( 2, 1 ),
+    /*  LTEQ      */  PACK( 2, 1 ),
+    /*  GT        */  PACK( 2, 1 ),
+    /*  GTEQ      */  PACK( 2, 1 ),
+    /*  EQ        */  PACK( 2, 1 ),
+    /*  NEQ       */  PACK( 2, 1 ),
+    /*  ODD       */  PACK( 1, 1 ),
+    /*  EVEN      */  PACK( 1, 1 ),
+    /*  IF        */  PACK( 1, 0 ),
+    /*  EIF       */  PACK( 0, 0 ),
+    /*  AND       */  PACK( 2, 1 ),
+    /*  OR        */  PACK( 2, 1 ),
+    /*  NOT       */  PACK( 1, 1 ),
+    /*  DeltaP1   */  PACK( 1, 0 ),
+    /*  SDB       */  PACK( 1, 0 ),
+    /*  SDS       */  PACK( 1, 0 ),
+
+    /*  ADD       */  PACK( 2, 1 ),
+    /*  SUB       */  PACK( 2, 1 ),
+    /*  DIV       */  PACK( 2, 1 ),
+    /*  MUL       */  PACK( 2, 1 ),
+    /*  ABS       */  PACK( 1, 1 ),
+    /*  NEG       */  PACK( 1, 1 ),
+    /*  FLOOR     */  PACK( 1, 1 ),
+    /*  CEILING   */  PACK( 1, 1 ),
+    /*  ROUND[0]  */  PACK( 1, 1 ),
+    /*  ROUND[1]  */  PACK( 1, 1 ),
+    /*  ROUND[2]  */  PACK( 1, 1 ),
+    /*  ROUND[3]  */  PACK( 1, 1 ),
+    /*  NROUND[0] */  PACK( 1, 1 ),
+    /*  NROUND[1] */  PACK( 1, 1 ),
+    /*  NROUND[2] */  PACK( 1, 1 ),
+    /*  NROUND[3] */  PACK( 1, 1 ),
+
+    /*  WCvtF     */  PACK( 2, 0 ),
+    /*  DeltaP2   */  PACK( 1, 0 ),
+    /*  DeltaP3   */  PACK( 1, 0 ),
+    /*  DeltaCn[0] */ PACK( 1, 0 ),
+    /*  DeltaCn[1] */ PACK( 1, 0 ),
+    /*  DeltaCn[2] */ PACK( 1, 0 ),
+    /*  SROUND    */  PACK( 1, 0 ),
+    /*  S45Round  */  PACK( 1, 0 ),
+    /*  JROT      */  PACK( 2, 0 ),
+    /*  JROF      */  PACK( 2, 0 ),
+    /*  ROFF      */  PACK( 0, 0 ),
+    /*  INS_$7B   */  PACK( 0, 0 ),
+    /*  RUTG      */  PACK( 0, 0 ),
+    /*  RDTG      */  PACK( 0, 0 ),
+    /*  SANGW     */  PACK( 1, 0 ),
+    /*  AA        */  PACK( 1, 0 ),
+
+    /*  FlipPT    */  PACK( 0, 0 ), /* loops */
+    /*  FlipRgON  */  PACK( 2, 0 ),
+    /*  FlipRgOFF */  PACK( 2, 0 ),
+    /*  INS_$83   */  PACK( 0, 0 ),
+    /*  INS_$84   */  PACK( 0, 0 ),
+    /*  ScanCTRL  */  PACK( 1, 0 ),
+    /*  SDPvTL[0] */  PACK( 2, 0 ),
+    /*  SDPvTL[1] */  PACK( 2, 0 ),
+    /*  GetINFO   */  PACK( 1, 1 ),
+    /*  IDEF      */  PACK( 1, 0 ),
+    /*  ROLL      */  PACK( 3, 3 ),
+    /*  MAX       */  PACK( 2, 1 ),
+    /*  MIN       */  PACK( 2, 1 ),
+    /*  ScanTYPE  */  PACK( 1, 0 ),
+    /*  InstCTRL  */  PACK( 2, 0 ),
+    /*  INS_$8F   */  PACK( 0, 0 ),
+
+    /*  INS_$90  */   PACK( 0, 0 ),
+    /*  GETVAR   */   PACK( 0, 0 ), /* will be handled specially */
+    /*  GETDATA  */   PACK( 0, 1 ),
+    /*  INS_$93  */   PACK( 0, 0 ),
+    /*  INS_$94  */   PACK( 0, 0 ),
+    /*  INS_$95  */   PACK( 0, 0 ),
+    /*  INS_$96  */   PACK( 0, 0 ),
+    /*  INS_$97  */   PACK( 0, 0 ),
+    /*  INS_$98  */   PACK( 0, 0 ),
+    /*  INS_$99  */   PACK( 0, 0 ),
+    /*  INS_$9A  */   PACK( 0, 0 ),
+    /*  INS_$9B  */   PACK( 0, 0 ),
+    /*  INS_$9C  */   PACK( 0, 0 ),
+    /*  INS_$9D  */   PACK( 0, 0 ),
+    /*  INS_$9E  */   PACK( 0, 0 ),
+    /*  INS_$9F  */   PACK( 0, 0 ),
+
+    /*  INS_$A0  */   PACK( 0, 0 ),
+    /*  INS_$A1  */   PACK( 0, 0 ),
+    /*  INS_$A2  */   PACK( 0, 0 ),
+    /*  INS_$A3  */   PACK( 0, 0 ),
+    /*  INS_$A4  */   PACK( 0, 0 ),
+    /*  INS_$A5  */   PACK( 0, 0 ),
+    /*  INS_$A6  */   PACK( 0, 0 ),
+    /*  INS_$A7  */   PACK( 0, 0 ),
+    /*  INS_$A8  */   PACK( 0, 0 ),
+    /*  INS_$A9  */   PACK( 0, 0 ),
+    /*  INS_$AA  */   PACK( 0, 0 ),
+    /*  INS_$AB  */   PACK( 0, 0 ),
+    /*  INS_$AC  */   PACK( 0, 0 ),
+    /*  INS_$AD  */   PACK( 0, 0 ),
+    /*  INS_$AE  */   PACK( 0, 0 ),
+    /*  INS_$AF  */   PACK( 0, 0 ),
+
+    /*  PushB[0]  */  PACK( 0, 1 ),
+    /*  PushB[1]  */  PACK( 0, 2 ),
+    /*  PushB[2]  */  PACK( 0, 3 ),
+    /*  PushB[3]  */  PACK( 0, 4 ),
+    /*  PushB[4]  */  PACK( 0, 5 ),
+    /*  PushB[5]  */  PACK( 0, 6 ),
+    /*  PushB[6]  */  PACK( 0, 7 ),
+    /*  PushB[7]  */  PACK( 0, 8 ),
+    /*  PushW[0]  */  PACK( 0, 1 ),
+    /*  PushW[1]  */  PACK( 0, 2 ),
+    /*  PushW[2]  */  PACK( 0, 3 ),
+    /*  PushW[3]  */  PACK( 0, 4 ),
+    /*  PushW[4]  */  PACK( 0, 5 ),
+    /*  PushW[5]  */  PACK( 0, 6 ),
+    /*  PushW[6]  */  PACK( 0, 7 ),
+    /*  PushW[7]  */  PACK( 0, 8 ),
+
+    /*  MDRP[00]  */  PACK( 1, 0 ),
+    /*  MDRP[01]  */  PACK( 1, 0 ),
+    /*  MDRP[02]  */  PACK( 1, 0 ),
+    /*  MDRP[03]  */  PACK( 1, 0 ),
+    /*  MDRP[04]  */  PACK( 1, 0 ),
+    /*  MDRP[05]  */  PACK( 1, 0 ),
+    /*  MDRP[06]  */  PACK( 1, 0 ),
+    /*  MDRP[07]  */  PACK( 1, 0 ),
+    /*  MDRP[08]  */  PACK( 1, 0 ),
+    /*  MDRP[09]  */  PACK( 1, 0 ),
+    /*  MDRP[10]  */  PACK( 1, 0 ),
+    /*  MDRP[11]  */  PACK( 1, 0 ),
+    /*  MDRP[12]  */  PACK( 1, 0 ),
+    /*  MDRP[13]  */  PACK( 1, 0 ),
+    /*  MDRP[14]  */  PACK( 1, 0 ),
+    /*  MDRP[15]  */  PACK( 1, 0 ),
+
+    /*  MDRP[16]  */  PACK( 1, 0 ),
+    /*  MDRP[17]  */  PACK( 1, 0 ),
+    /*  MDRP[18]  */  PACK( 1, 0 ),
+    /*  MDRP[19]  */  PACK( 1, 0 ),
+    /*  MDRP[20]  */  PACK( 1, 0 ),
+    /*  MDRP[21]  */  PACK( 1, 0 ),
+    /*  MDRP[22]  */  PACK( 1, 0 ),
+    /*  MDRP[23]  */  PACK( 1, 0 ),
+    /*  MDRP[24]  */  PACK( 1, 0 ),
+    /*  MDRP[25]  */  PACK( 1, 0 ),
+    /*  MDRP[26]  */  PACK( 1, 0 ),
+    /*  MDRP[27]  */  PACK( 1, 0 ),
+    /*  MDRP[28]  */  PACK( 1, 0 ),
+    /*  MDRP[29]  */  PACK( 1, 0 ),
+    /*  MDRP[30]  */  PACK( 1, 0 ),
+    /*  MDRP[31]  */  PACK( 1, 0 ),
+
+    /*  MIRP[00]  */  PACK( 2, 0 ),
+    /*  MIRP[01]  */  PACK( 2, 0 ),
+    /*  MIRP[02]  */  PACK( 2, 0 ),
+    /*  MIRP[03]  */  PACK( 2, 0 ),
+    /*  MIRP[04]  */  PACK( 2, 0 ),
+    /*  MIRP[05]  */  PACK( 2, 0 ),
+    /*  MIRP[06]  */  PACK( 2, 0 ),
+    /*  MIRP[07]  */  PACK( 2, 0 ),
+    /*  MIRP[08]  */  PACK( 2, 0 ),
+    /*  MIRP[09]  */  PACK( 2, 0 ),
+    /*  MIRP[10]  */  PACK( 2, 0 ),
+    /*  MIRP[11]  */  PACK( 2, 0 ),
+    /*  MIRP[12]  */  PACK( 2, 0 ),
+    /*  MIRP[13]  */  PACK( 2, 0 ),
+    /*  MIRP[14]  */  PACK( 2, 0 ),
+    /*  MIRP[15]  */  PACK( 2, 0 ),
+
+    /*  MIRP[16]  */  PACK( 2, 0 ),
+    /*  MIRP[17]  */  PACK( 2, 0 ),
+    /*  MIRP[18]  */  PACK( 2, 0 ),
+    /*  MIRP[19]  */  PACK( 2, 0 ),
+    /*  MIRP[20]  */  PACK( 2, 0 ),
+    /*  MIRP[21]  */  PACK( 2, 0 ),
+    /*  MIRP[22]  */  PACK( 2, 0 ),
+    /*  MIRP[23]  */  PACK( 2, 0 ),
+    /*  MIRP[24]  */  PACK( 2, 0 ),
+    /*  MIRP[25]  */  PACK( 2, 0 ),
+    /*  MIRP[26]  */  PACK( 2, 0 ),
+    /*  MIRP[27]  */  PACK( 2, 0 ),
+    /*  MIRP[28]  */  PACK( 2, 0 ),
+    /*  MIRP[29]  */  PACK( 2, 0 ),
+    /*  MIRP[30]  */  PACK( 2, 0 ),
+    /*  MIRP[31]  */  PACK( 2, 0 )
+  };
+
+
+#ifdef FT_DEBUG_LEVEL_TRACE
+
+  /* the first hex digit gives the length of the opcode name; the space */
+  /* after the digit is here just to increase readability of the source */
+  /* code                                                               */
+
+  static
+  const char*  const opcode_name[256] =
+  {
+    "7 SVTCA y",
+    "7 SVTCA x",
+    "8 SPvTCA y",
+    "8 SPvTCA x",
+    "8 SFvTCA y",
+    "8 SFvTCA x",
+    "8 SPvTL ||",
+    "7 SPvTL +",
+    "8 SFvTL ||",
+    "7 SFvTL +",
+    "5 SPvFS",
+    "5 SFvFS",
+    "3 GPv",
+    "3 GFv",
+    "6 SFvTPv",
+    "5 ISECT",
+
+    "4 SRP0",
+    "4 SRP1",
+    "4 SRP2",
+    "4 SZP0",
+    "4 SZP1",
+    "4 SZP2",
+    "4 SZPS",
+    "5 SLOOP",
+    "3 RTG",
+    "4 RTHG",
+    "3 SMD",
+    "4 ELSE",
+    "4 JMPR",
+    "6 SCvTCi",
+    "5 SSwCi",
+    "3 SSW",
+
+    "3 DUP",
+    "3 POP",
+    "5 CLEAR",
+    "4 SWAP",
+    "5 DEPTH",
+    "6 CINDEX",
+    "6 MINDEX",
+    "8 AlignPTS",
+    "7 INS_$28",
+    "3 UTP",
+    "8 LOOPCALL",
+    "4 CALL",
+    "4 FDEF",
+    "4 ENDF",
+    "7 MDAP[0]",
+    "7 MDAP[1]",
+
+    "6 IUP[0]",
+    "6 IUP[1]",
+    "6 SHP[0]",
+    "6 SHP[1]",
+    "6 SHC[0]",
+    "6 SHC[1]",
+    "6 SHZ[0]",
+    "6 SHZ[1]",
+    "5 SHPIX",
+    "2 IP",
+    "8 MSIRP[0]",
+    "8 MSIRP[1]",
+    "7 AlignRP",
+    "4 RTDG",
+    "7 MIAP[0]",
+    "7 MIAP[1]",
+
+    "6 NPushB",
+    "6 NPushW",
+    "2 WS",
+    "2 RS",
+    "5 WCvtP",
+    "4 RCvt",
+    "5 GC[0]",
+    "5 GC[1]",
+    "4 SCFS",
+    "5 MD[0]",
+    "5 MD[1]",
+    "5 MPPEM",
+    "3 MPS",
+    "6 FlipON",
+    "7 FlipOFF",
+    "5 DEBUG",
+
+    "2 LT",
+    "4 LTEQ",
+    "2 GT",
+    "4 GTEQ",
+    "2 EQ",
+    "3 NEQ",
+    "3 ODD",
+    "4 EVEN",
+    "2 IF",
+    "3 EIF",
+    "3 AND",
+    "2 OR",
+    "3 NOT",
+    "7 DeltaP1",
+    "3 SDB",
+    "3 SDS",
+
+    "3 ADD",
+    "3 SUB",
+    "3 DIV",
+    "3 MUL",
+    "3 ABS",
+    "3 NEG",
+    "5 FLOOR",
+    "7 CEILING",
+    "8 ROUND[0]",
+    "8 ROUND[1]",
+    "8 ROUND[2]",
+    "8 ROUND[3]",
+    "9 NROUND[0]",
+    "9 NROUND[1]",
+    "9 NROUND[2]",
+    "9 NROUND[3]",
+
+    "5 WCvtF",
+    "7 DeltaP2",
+    "7 DeltaP3",
+    "A DeltaCn[0]",
+    "A DeltaCn[1]",
+    "A DeltaCn[2]",
+    "6 SROUND",
+    "8 S45Round",
+    "4 JROT",
+    "4 JROF",
+    "4 ROFF",
+    "7 INS_$7B",
+    "4 RUTG",
+    "4 RDTG",
+    "5 SANGW",
+    "2 AA",
+
+    "6 FlipPT",
+    "8 FlipRgON",
+    "9 FlipRgOFF",
+    "7 INS_$83",
+    "7 INS_$84",
+    "8 ScanCTRL",
+    "9 SDPvTL[0]",
+    "9 SDPvTL[1]",
+    "7 GetINFO",
+    "4 IDEF",
+    "4 ROLL",
+    "3 MAX",
+    "3 MIN",
+    "8 ScanTYPE",
+    "8 InstCTRL",
+    "7 INS_$8F",
+
+    "7 INS_$90",
+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
+    "6 GETVAR",
+    "7 GETDATA",
+#else
+    "7 INS_$91",
+    "7 INS_$92",
+#endif
+    "7 INS_$93",
+    "7 INS_$94",
+    "7 INS_$95",
+    "7 INS_$96",
+    "7 INS_$97",
+    "7 INS_$98",
+    "7 INS_$99",
+    "7 INS_$9A",
+    "7 INS_$9B",
+    "7 INS_$9C",
+    "7 INS_$9D",
+    "7 INS_$9E",
+    "7 INS_$9F",
+
+    "7 INS_$A0",
+    "7 INS_$A1",
+    "7 INS_$A2",
+    "7 INS_$A3",
+    "7 INS_$A4",
+    "7 INS_$A5",
+    "7 INS_$A6",
+    "7 INS_$A7",
+    "7 INS_$A8",
+    "7 INS_$A9",
+    "7 INS_$AA",
+    "7 INS_$AB",
+    "7 INS_$AC",
+    "7 INS_$AD",
+    "7 INS_$AE",
+    "7 INS_$AF",
+
+    "8 PushB[0]",
+    "8 PushB[1]",
+    "8 PushB[2]",
+    "8 PushB[3]",
+    "8 PushB[4]",
+    "8 PushB[5]",
+    "8 PushB[6]",
+    "8 PushB[7]",
+    "8 PushW[0]",
+    "8 PushW[1]",
+    "8 PushW[2]",
+    "8 PushW[3]",
+    "8 PushW[4]",
+    "8 PushW[5]",
+    "8 PushW[6]",
+    "8 PushW[7]",
+
+    "8 MDRP[00]",
+    "8 MDRP[01]",
+    "8 MDRP[02]",
+    "8 MDRP[03]",
+    "8 MDRP[04]",
+    "8 MDRP[05]",
+    "8 MDRP[06]",
+    "8 MDRP[07]",
+    "8 MDRP[08]",
+    "8 MDRP[09]",
+    "8 MDRP[10]",
+    "8 MDRP[11]",
+    "8 MDRP[12]",
+    "8 MDRP[13]",
+    "8 MDRP[14]",
+    "8 MDRP[15]",
+
+    "8 MDRP[16]",
+    "8 MDRP[17]",
+    "8 MDRP[18]",
+    "8 MDRP[19]",
+    "8 MDRP[20]",
+    "8 MDRP[21]",
+    "8 MDRP[22]",
+    "8 MDRP[23]",
+    "8 MDRP[24]",
+    "8 MDRP[25]",
+    "8 MDRP[26]",
+    "8 MDRP[27]",
+    "8 MDRP[28]",
+    "8 MDRP[29]",
+    "8 MDRP[30]",
+    "8 MDRP[31]",
+
+    "8 MIRP[00]",
+    "8 MIRP[01]",
+    "8 MIRP[02]",
+    "8 MIRP[03]",
+    "8 MIRP[04]",
+    "8 MIRP[05]",
+    "8 MIRP[06]",
+    "8 MIRP[07]",
+    "8 MIRP[08]",
+    "8 MIRP[09]",
+    "8 MIRP[10]",
+    "8 MIRP[11]",
+    "8 MIRP[12]",
+    "8 MIRP[13]",
+    "8 MIRP[14]",
+    "8 MIRP[15]",
+
+    "8 MIRP[16]",
+    "8 MIRP[17]",
+    "8 MIRP[18]",
+    "8 MIRP[19]",
+    "8 MIRP[20]",
+    "8 MIRP[21]",
+    "8 MIRP[22]",
+    "8 MIRP[23]",
+    "8 MIRP[24]",
+    "8 MIRP[25]",
+    "8 MIRP[26]",
+    "8 MIRP[27]",
+    "8 MIRP[28]",
+    "8 MIRP[29]",
+    "8 MIRP[30]",
+    "8 MIRP[31]"
+  };
+
+#endif /* FT_DEBUG_LEVEL_TRACE */
+
+
+  static
+  const FT_Char  opcode_length[256] =
+  {
+    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
+    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
+    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
+    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
+
+   -1,-2, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
+    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
+    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
+    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
+
+    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
+    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
+    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
+    2, 3, 4, 5,  6, 7, 8, 9,  3, 5, 7, 9, 11,13,15,17,
+
+    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
+    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
+    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
+    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1
+  };
+
+#undef PACK
+
+
+#ifndef FT_CONFIG_OPTION_NO_ASSEMBLER
+
+#if defined( __arm__ )                                 && \
+    ( defined( __thumb2__ ) || !defined( __thumb__ ) )
+
+#define TT_MulFix14  TT_MulFix14_arm
+
+  static FT_Int32
+  TT_MulFix14_arm( FT_Int32  a,
+                   FT_Int    b )
+  {
+    FT_Int32  t, t2;
+
+
+#if defined( __CC_ARM ) || defined( __ARMCC__ )
+
+    __asm
+    {
+      smull t2, t,  b,  a           /* (lo=t2,hi=t) = a*b */
+      mov   a,  t,  asr #31         /* a   = (hi >> 31) */
+      add   a,  a,  #0x2000         /* a  += 0x2000 */
+      adds  t2, t2, a               /* t2 += a */
+      adc   t,  t,  #0              /* t  += carry */
+      mov   a,  t2, lsr #14         /* a   = t2 >> 14 */
+      orr   a,  a,  t,  lsl #18     /* a  |= t << 18 */
+    }
+
+#elif defined( __GNUC__ )
+
+    __asm__ __volatile__ (
+      "smull  %1, %2, %4, %3\n\t"       /* (lo=%1,hi=%2) = a*b */
+      "mov    %0, %2, asr #31\n\t"      /* %0  = (hi >> 31) */
+#if defined( __clang__ ) && defined( __thumb2__ )
+      "add.w  %0, %0, #0x2000\n\t"      /* %0 += 0x2000 */
+#else
+      "add    %0, %0, #0x2000\n\t"      /* %0 += 0x2000 */
+#endif
+      "adds   %1, %1, %0\n\t"           /* %1 += %0 */
+      "adc    %2, %2, #0\n\t"           /* %2 += carry */
+      "mov    %0, %1, lsr #14\n\t"      /* %0  = %1 >> 16 */
+      "orr    %0, %0, %2, lsl #18\n\t"  /* %0 |= %2 << 16 */
+      : "=r"(a), "=&r"(t2), "=&r"(t)
+      : "r"(a), "r"(b)
+      : "cc" );
+
+#endif
+
+    return a;
+  }
+
+#endif /* __arm__ && ( __thumb2__ || !__thumb__ ) */
+
+#endif /* !FT_CONFIG_OPTION_NO_ASSEMBLER */
+
+
+#if defined( __GNUC__ )                              && \
+    ( defined( __i386__ ) || defined( __x86_64__ ) )
+
+#define TT_MulFix14  TT_MulFix14_long_long
+
+  /* Temporarily disable the warning that C90 doesn't support `long long'. */
+#if ( __GNUC__ * 100 + __GNUC_MINOR__ ) >= 406
+#pragma GCC diagnostic push
+#endif
+#pragma GCC diagnostic ignored "-Wlong-long"
+
+  /* This is declared `noinline' because inlining the function results */
+  /* in slower code.  The `pure' attribute indicates that the result   */
+  /* only depends on the parameters.                                   */
+  static __attribute__(( noinline ))
+         __attribute__(( pure )) FT_Int32
+  TT_MulFix14_long_long( FT_Int32  a,
+                         FT_Int    b )
+  {
+
+    long long  ret = (long long)a * b;
+
+    /* The following line assumes that right shifting of signed values */
+    /* will actually preserve the sign bit.  The exact behaviour is    */
+    /* undefined, but this is true on x86 and x86_64.                  */
+    long long  tmp = ret >> 63;
+
+
+    ret += 0x2000 + tmp;
+
+    return (FT_Int32)( ret >> 14 );
+  }
+
+#if ( __GNUC__ * 100 + __GNUC_MINOR__ ) >= 406
+#pragma GCC diagnostic pop
+#endif
+
+#endif /* __GNUC__ && ( __i386__ || __x86_64__ ) */
+
+
+#ifndef TT_MulFix14
+
+  /* Compute (a*b)/2^14 with maximum accuracy and rounding.  */
+  /* This is optimized to be faster than calling FT_MulFix() */
+  /* for platforms where sizeof(int) == 2.                   */
+  static FT_Int32
+  TT_MulFix14( FT_Int32  a,
+               FT_Int    b )
+  {
+    FT_Int32   sign;
+    FT_UInt32  ah, al, mid, lo, hi;
+
+
+    sign = a ^ b;
+
+    if ( a < 0 )
+      a = -a;
+    if ( b < 0 )
+      b = -b;
+
+    ah = (FT_UInt32)( ( a >> 16 ) & 0xFFFFU );
+    al = (FT_UInt32)( a & 0xFFFFU );
+
+    lo    = al * b;
+    mid   = ah * b;
+    hi    = mid >> 16;
+    mid   = ( mid << 16 ) + ( 1 << 13 ); /* rounding */
+    lo   += mid;
+    if ( lo < mid )
+      hi += 1;
+
+    mid = ( lo >> 14 ) | ( hi << 18 );
+
+    return sign >= 0 ? (FT_Int32)mid : -(FT_Int32)mid;
+  }
+
+#endif  /* !TT_MulFix14 */
+
+
+#if defined( __GNUC__ )        && \
+    ( defined( __i386__ )   ||    \
+      defined( __x86_64__ ) ||    \
+      defined( __arm__ )    )
+
+#define TT_DotFix14  TT_DotFix14_long_long
+
+#if ( __GNUC__ * 100 + __GNUC_MINOR__ ) >= 406
+#pragma GCC diagnostic push
+#endif
+#pragma GCC diagnostic ignored "-Wlong-long"
+
+  static __attribute__(( pure )) FT_Int32
+  TT_DotFix14_long_long( FT_Int32  ax,
+                         FT_Int32  ay,
+                         FT_Int    bx,
+                         FT_Int    by )
+  {
+    /* Temporarily disable the warning that C90 doesn't support */
+    /* `long long'.                                             */
+
+    long long  temp1 = (long long)ax * bx;
+    long long  temp2 = (long long)ay * by;
+
+
+    temp1 += temp2;
+    temp2  = temp1 >> 63;
+    temp1 += 0x2000 + temp2;
+
+    return (FT_Int32)( temp1 >> 14 );
+
+  }
+
+#if ( __GNUC__ * 100 + __GNUC_MINOR__ ) >= 406
+#pragma GCC diagnostic pop
+#endif
+
+#endif /* __GNUC__ && (__arm__ || __i386__ || __x86_64__) */
+
+
+#ifndef TT_DotFix14
+
+  /* compute (ax*bx+ay*by)/2^14 with maximum accuracy and rounding */
+  static FT_Int32
+  TT_DotFix14( FT_Int32  ax,
+               FT_Int32  ay,
+               FT_Int    bx,
+               FT_Int    by )
+  {
+    FT_Int32   m, s, hi1, hi2, hi;
+    FT_UInt32  l, lo1, lo2, lo;
+
+
+    /* compute ax*bx as 64-bit value */
+    l = (FT_UInt32)( ( ax & 0xFFFFU ) * bx );
+    m = ( ax >> 16 ) * bx;
+
+    lo1 = l + ( (FT_UInt32)m << 16 );
+    hi1 = ( m >> 16 ) + ( (FT_Int32)l >> 31 ) + ( lo1 < l );
+
+    /* compute ay*by as 64-bit value */
+    l = (FT_UInt32)( ( ay & 0xFFFFU ) * by );
+    m = ( ay >> 16 ) * by;
+
+    lo2 = l + ( (FT_UInt32)m << 16 );
+    hi2 = ( m >> 16 ) + ( (FT_Int32)l >> 31 ) + ( lo2 < l );
+
+    /* add them */
+    lo = lo1 + lo2;
+    hi = hi1 + hi2 + ( lo < lo1 );
+
+    /* divide the result by 2^14 with rounding */
+    s   = hi >> 31;
+    l   = lo + (FT_UInt32)s;
+    hi += s + ( l < lo );
+    lo  = l;
+
+    l   = lo + 0x2000U;
+    hi += ( l < lo );
+
+    return (FT_Int32)( ( (FT_UInt32)hi << 18 ) | ( l >> 14 ) );
+  }
+
+#endif /* TT_DotFix14 */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    Current_Ratio                                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Returns the current aspect ratio scaling factor depending on the   */
+  /*    projection vector's state and device resolutions.                  */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    The aspect ratio in 16.16 format, always <= 1.0 .                  */
+  /*                                                                       */
+  static FT_Long
+  Current_Ratio( TT_ExecContext  exc )
+  {
+    if ( !exc->tt_metrics.ratio )
+    {
+      if ( exc->GS.projVector.y == 0 )
+        exc->tt_metrics.ratio = exc->tt_metrics.x_ratio;
+
+      else if ( exc->GS.projVector.x == 0 )
+        exc->tt_metrics.ratio = exc->tt_metrics.y_ratio;
+
+      else
+      {
+        FT_F26Dot6  x, y;
+
+
+        x = TT_MulFix14( exc->tt_metrics.x_ratio,
+                         exc->GS.projVector.x );
+        y = TT_MulFix14( exc->tt_metrics.y_ratio,
+                         exc->GS.projVector.y );
+        exc->tt_metrics.ratio = FT_Hypot( x, y );
+      }
+    }
+    return exc->tt_metrics.ratio;
+  }
+
+
+  FT_CALLBACK_DEF( FT_Long )
+  Current_Ppem( TT_ExecContext  exc )
+  {
+    return exc->tt_metrics.ppem;
+  }
+
+
+  FT_CALLBACK_DEF( FT_Long )
+  Current_Ppem_Stretched( TT_ExecContext  exc )
+  {
+    return FT_MulFix( exc->tt_metrics.ppem, Current_Ratio( exc ) );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Functions related to the control value table (CVT).                   */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  FT_CALLBACK_DEF( FT_F26Dot6 )
+  Read_CVT( TT_ExecContext  exc,
+            FT_ULong        idx )
+  {
+    return exc->cvt[idx];
+  }
+
+
+  FT_CALLBACK_DEF( FT_F26Dot6 )
+  Read_CVT_Stretched( TT_ExecContext  exc,
+                      FT_ULong        idx )
+  {
+    return FT_MulFix( exc->cvt[idx], Current_Ratio( exc ) );
+  }
+
+
+  FT_CALLBACK_DEF( void )
+  Write_CVT( TT_ExecContext  exc,
+             FT_ULong        idx,
+             FT_F26Dot6      value )
+  {
+    exc->cvt[idx] = value;
+  }
+
+
+  FT_CALLBACK_DEF( void )
+  Write_CVT_Stretched( TT_ExecContext  exc,
+                       FT_ULong        idx,
+                       FT_F26Dot6      value )
+  {
+    exc->cvt[idx] = FT_DivFix( value, Current_Ratio( exc ) );
+  }
+
+
+  FT_CALLBACK_DEF( void )
+  Move_CVT( TT_ExecContext  exc,
+            FT_ULong        idx,
+            FT_F26Dot6      value )
+  {
+    exc->cvt[idx] += value;
+  }
+
+
+  FT_CALLBACK_DEF( void )
+  Move_CVT_Stretched( TT_ExecContext  exc,
+                      FT_ULong        idx,
+                      FT_F26Dot6      value )
+  {
+    exc->cvt[idx] += FT_DivFix( value, Current_Ratio( exc ) );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    GetShortIns                                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Returns a short integer taken from the instruction stream at       */
+  /*    address IP.                                                        */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    Short read at code[IP].                                            */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    This one could become a macro.                                     */
+  /*                                                                       */
+  static FT_Short
+  GetShortIns( TT_ExecContext  exc )
+  {
+    /* Reading a byte stream so there is no endianness (DaveP) */
+    exc->IP += 2;
+    return (FT_Short)( ( exc->code[exc->IP - 2] << 8 ) +
+                         exc->code[exc->IP - 1]      );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    Ins_Goto_CodeRange                                                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Goes to a certain code range in the instruction stream.            */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    aRange :: The index of the code range.                             */
+  /*                                                                       */
+  /*    aIP    :: The new IP address in the code range.                    */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    SUCCESS or FAILURE.                                                */
+  /*                                                                       */
+  static FT_Bool
+  Ins_Goto_CodeRange( TT_ExecContext  exc,
+                      FT_Int          aRange,
+                      FT_Long         aIP )
+  {
+    TT_CodeRange*  range;
+
+
+    if ( aRange < 1 || aRange > 3 )
+    {
+      exc->error = FT_THROW( Bad_Argument );
+      return FAILURE;
+    }
+
+    range = &exc->codeRangeTable[aRange - 1];
+
+    if ( range->base == NULL )     /* invalid coderange */
+    {
+      exc->error = FT_THROW( Invalid_CodeRange );
+      return FAILURE;
+    }
+
+    /* NOTE: Because the last instruction of a program may be a CALL */
+    /*       which will return to the first byte *after* the code    */
+    /*       range, we test for aIP <= Size, instead of aIP < Size.  */
+
+    if ( aIP > range->size )
+    {
+      exc->error = FT_THROW( Code_Overflow );
+      return FAILURE;
+    }
+
+    exc->code     = range->base;
+    exc->codeSize = range->size;
+    exc->IP       = aIP;
+    exc->curRange = aRange;
+
+    return SUCCESS;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    Direct_Move                                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Moves a point by a given distance along the freedom vector.  The   */
+  /*    point will be `touched'.                                           */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    point    :: The index of the point to move.                        */
+  /*                                                                       */
+  /*    distance :: The distance to apply.                                 */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    zone     :: The affected glyph zone.                               */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    See `ttinterp.h' for details on backwards compatibility mode.      */
+  /*    `Touches' the point.                                               */
+  /*                                                                       */
+  static void
+  Direct_Move( TT_ExecContext  exc,
+               TT_GlyphZone    zone,
+               FT_UShort       point,
+               FT_F26Dot6      distance )
+  {
+    FT_F26Dot6  v;
+
+
+    v = exc->GS.freeVector.x;
+
+    if ( v != 0 )
+    {
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+      if ( SUBPIXEL_HINTING_INFINALITY                            &&
+           ( !exc->ignore_x_mode                                ||
+             ( exc->sph_tweak_flags & SPH_TWEAK_ALLOW_X_DMOVE ) ) )
+        zone->cur[point].x += FT_MulDiv( distance, v, exc->F_dot_P );
+      else
+#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
+      /* Exception to the post-IUP curfew: Allow the x component of */
+      /* diagonal moves, but only post-IUP.  DejaVu tries to adjust */
+      /* diagonal stems like on `Z' and `z' post-IUP.               */
+      if ( SUBPIXEL_HINTING_MINIMAL && !exc->backwards_compatibility )
+        zone->cur[point].x += FT_MulDiv( distance, v, exc->F_dot_P );
+      else
+#endif
+
+      if ( NO_SUBPIXEL_HINTING )
+        zone->cur[point].x += FT_MulDiv( distance, v, exc->F_dot_P );
+
+      zone->tags[point] |= FT_CURVE_TAG_TOUCH_X;
+    }
+
+    v = exc->GS.freeVector.y;
+
+    if ( v != 0 )
+    {
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
+      if ( !( SUBPIXEL_HINTING_MINIMAL     &&
+              exc->backwards_compatibility &&
+              exc->iupx_called             &&
+              exc->iupy_called             ) )
+#endif
+        zone->cur[point].y += FT_MulDiv( distance, v, exc->F_dot_P );
+
+      zone->tags[point] |= FT_CURVE_TAG_TOUCH_Y;
+    }
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    Direct_Move_Orig                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Moves the *original* position of a point by a given distance along */
+  /*    the freedom vector.  Obviously, the point will not be `touched'.   */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    point    :: The index of the point to move.                        */
+  /*                                                                       */
+  /*    distance :: The distance to apply.                                 */
+  /*                                                                       */
+  /* <InOut>                                                               */
+  /*    zone     :: The affected glyph zone.                               */
+  /*                                                                       */
+  static void
+  Direct_Move_Orig( TT_ExecContext  exc,
+                    TT_GlyphZone    zone,
+                    FT_UShort       point,
+                    FT_F26Dot6      distance )
+  {
+    FT_F26Dot6  v;
+
+
+    v = exc->GS.freeVector.x;
+
+    if ( v != 0 )
+      zone->org[point].x += FT_MulDiv( distance, v, exc->F_dot_P );
+
+    v = exc->GS.freeVector.y;
+
+    if ( v != 0 )
+      zone->org[point].y += FT_MulDiv( distance, v, exc->F_dot_P );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Special versions of Direct_Move()                                     */
+  /*                                                                       */
+  /*   The following versions are used whenever both vectors are both      */
+  /*   along one of the coordinate unit vectors, i.e. in 90% of the cases. */
+  /*   See `ttinterp.h' for details on backwards compatibility mode.       */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  static void
+  Direct_Move_X( TT_ExecContext  exc,
+                 TT_GlyphZone    zone,
+                 FT_UShort       point,
+                 FT_F26Dot6      distance )
+  {
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+    if ( SUBPIXEL_HINTING_INFINALITY && !exc->ignore_x_mode )
+      zone->cur[point].x += distance;
+    else
+#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
+    if ( SUBPIXEL_HINTING_MINIMAL && !exc->backwards_compatibility )
+      zone->cur[point].x += distance;
+    else
+#endif
+
+    if ( NO_SUBPIXEL_HINTING )
+      zone->cur[point].x += distance;
+
+    zone->tags[point]  |= FT_CURVE_TAG_TOUCH_X;
+  }
+
+
+  static void
+  Direct_Move_Y( TT_ExecContext  exc,
+                 TT_GlyphZone    zone,
+                 FT_UShort       point,
+                 FT_F26Dot6      distance )
+  {
+    FT_UNUSED( exc );
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
+    if ( !( SUBPIXEL_HINTING_MINIMAL             &&
+            exc->backwards_compatibility         &&
+            exc->iupx_called && exc->iupy_called ) )
+#endif
+      zone->cur[point].y += distance;
+
+    zone->tags[point] |= FT_CURVE_TAG_TOUCH_Y;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Special versions of Direct_Move_Orig()                                */
+  /*                                                                       */
+  /*   The following versions are used whenever both vectors are both      */
+  /*   along one of the coordinate unit vectors, i.e. in 90% of the cases. */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  static void
+  Direct_Move_Orig_X( TT_ExecContext  exc,
+                      TT_GlyphZone    zone,
+                      FT_UShort       point,
+                      FT_F26Dot6      distance )
+  {
+    FT_UNUSED( exc );
+
+    zone->org[point].x += distance;
+  }
+
+
+  static void
+  Direct_Move_Orig_Y( TT_ExecContext  exc,
+                      TT_GlyphZone    zone,
+                      FT_UShort       point,
+                      FT_F26Dot6      distance )
+  {
+    FT_UNUSED( exc );
+
+    zone->org[point].y += distance;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    Round_None                                                         */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Does not round, but adds engine compensation.                      */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    distance     :: The distance (not) to round.                       */
+  /*                                                                       */
+  /*    compensation :: The engine compensation.                           */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    The compensated distance.                                          */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The TrueType specification says very few about the relationship    */
+  /*    between rounding and engine compensation.  However, it seems from  */
+  /*    the description of super round that we should add the compensation */
+  /*    before rounding.                                                   */
+  /*                                                                       */
+  static FT_F26Dot6
+  Round_None( TT_ExecContext  exc,
+              FT_F26Dot6      distance,
+              FT_F26Dot6      compensation )
+  {
+    FT_F26Dot6  val;
+
+    FT_UNUSED( exc );
+
+
+    if ( distance >= 0 )
+    {
+      val = distance + compensation;
+      if ( val < 0 )
+        val = 0;
+    }
+    else
+    {
+      val = distance - compensation;
+      if ( val > 0 )
+        val = 0;
+    }
+    return val;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    Round_To_Grid                                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Rounds value to grid after adding engine compensation.             */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    distance     :: The distance to round.                             */
+  /*                                                                       */
+  /*    compensation :: The engine compensation.                           */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    Rounded distance.                                                  */
+  /*                                                                       */
+  static FT_F26Dot6
+  Round_To_Grid( TT_ExecContext  exc,
+                 FT_F26Dot6      distance,
+                 FT_F26Dot6      compensation )
+  {
+    FT_F26Dot6  val;
+
+    FT_UNUSED( exc );
+
+
+    if ( distance >= 0 )
+    {
+      val = FT_PIX_ROUND( distance + compensation );
+      if ( val < 0 )
+        val = 0;
+    }
+    else
+    {
+      val = -FT_PIX_ROUND( compensation - distance );
+      if ( val > 0 )
+        val = 0;
+    }
+
+    return val;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    Round_To_Half_Grid                                                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Rounds value to half grid after adding engine compensation.        */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    distance     :: The distance to round.                             */
+  /*                                                                       */
+  /*    compensation :: The engine compensation.                           */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    Rounded distance.                                                  */
+  /*                                                                       */
+  static FT_F26Dot6
+  Round_To_Half_Grid( TT_ExecContext  exc,
+                      FT_F26Dot6      distance,
+                      FT_F26Dot6      compensation )
+  {
+    FT_F26Dot6  val;
+
+    FT_UNUSED( exc );
+
+
+    if ( distance >= 0 )
+    {
+      val = FT_PIX_FLOOR( distance + compensation ) + 32;
+      if ( val < 0 )
+        val = 32;
+    }
+    else
+    {
+      val = -( FT_PIX_FLOOR( compensation - distance ) + 32 );
+      if ( val > 0 )
+        val = -32;
+    }
+
+    return val;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    Round_Down_To_Grid                                                 */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Rounds value down to grid after adding engine compensation.        */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    distance     :: The distance to round.                             */
+  /*                                                                       */
+  /*    compensation :: The engine compensation.                           */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    Rounded distance.                                                  */
+  /*                                                                       */
+  static FT_F26Dot6
+  Round_Down_To_Grid( TT_ExecContext  exc,
+                      FT_F26Dot6      distance,
+                      FT_F26Dot6      compensation )
+  {
+    FT_F26Dot6  val;
+
+    FT_UNUSED( exc );
+
+
+    if ( distance >= 0 )
+    {
+      val = FT_PIX_FLOOR( distance + compensation );
+      if ( val < 0 )
+        val = 0;
+    }
+    else
+    {
+      val = -FT_PIX_FLOOR( compensation - distance );
+      if ( val > 0 )
+        val = 0;
+    }
+
+    return val;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    Round_Up_To_Grid                                                   */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Rounds value up to grid after adding engine compensation.          */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    distance     :: The distance to round.                             */
+  /*                                                                       */
+  /*    compensation :: The engine compensation.                           */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    Rounded distance.                                                  */
+  /*                                                                       */
+  static FT_F26Dot6
+  Round_Up_To_Grid( TT_ExecContext  exc,
+                    FT_F26Dot6      distance,
+                    FT_F26Dot6      compensation )
+  {
+    FT_F26Dot6  val;
+
+    FT_UNUSED( exc );
+
+
+    if ( distance >= 0 )
+    {
+      val = FT_PIX_CEIL( distance + compensation );
+      if ( val < 0 )
+        val = 0;
+    }
+    else
+    {
+      val = -FT_PIX_CEIL( compensation - distance );
+      if ( val > 0 )
+        val = 0;
+    }
+
+    return val;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    Round_To_Double_Grid                                               */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Rounds value to double grid after adding engine compensation.      */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    distance     :: The distance to round.                             */
+  /*                                                                       */
+  /*    compensation :: The engine compensation.                           */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    Rounded distance.                                                  */
+  /*                                                                       */
+  static FT_F26Dot6
+  Round_To_Double_Grid( TT_ExecContext  exc,
+                        FT_F26Dot6      distance,
+                        FT_F26Dot6      compensation )
+  {
+    FT_F26Dot6  val;
+
+    FT_UNUSED( exc );
+
+
+    if ( distance >= 0 )
+    {
+      val = FT_PAD_ROUND( distance + compensation, 32 );
+      if ( val < 0 )
+        val = 0;
+    }
+    else
+    {
+      val = -FT_PAD_ROUND( compensation - distance, 32 );
+      if ( val > 0 )
+        val = 0;
+    }
+
+    return val;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    Round_Super                                                        */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Super-rounds value to grid after adding engine compensation.       */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    distance     :: The distance to round.                             */
+  /*                                                                       */
+  /*    compensation :: The engine compensation.                           */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    Rounded distance.                                                  */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    The TrueType specification says very little about the relationship */
+  /*    between rounding and engine compensation.  However, it seems from  */
+  /*    the description of super round that we should add the compensation */
+  /*    before rounding.                                                   */
+  /*                                                                       */
+  static FT_F26Dot6
+  Round_Super( TT_ExecContext  exc,
+               FT_F26Dot6      distance,
+               FT_F26Dot6      compensation )
+  {
+    FT_F26Dot6  val;
+
+
+    if ( distance >= 0 )
+    {
+      val = ( distance - exc->phase + exc->threshold + compensation ) &
+              -exc->period;
+      val += exc->phase;
+      if ( val < 0 )
+        val = exc->phase;
+    }
+    else
+    {
+      val = -( ( exc->threshold - exc->phase - distance + compensation ) &
+               -exc->period );
+      val -= exc->phase;
+      if ( val > 0 )
+        val = -exc->phase;
+    }
+
+    return val;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    Round_Super_45                                                     */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Super-rounds value to grid after adding engine compensation.       */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    distance     :: The distance to round.                             */
+  /*                                                                       */
+  /*    compensation :: The engine compensation.                           */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    Rounded distance.                                                  */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    There is a separate function for Round_Super_45() as we may need   */
+  /*    greater precision.                                                 */
+  /*                                                                       */
+  static FT_F26Dot6
+  Round_Super_45( TT_ExecContext  exc,
+                  FT_F26Dot6      distance,
+                  FT_F26Dot6      compensation )
+  {
+    FT_F26Dot6  val;
+
+
+    if ( distance >= 0 )
+    {
+      val = ( ( distance - exc->phase + exc->threshold + compensation ) /
+                exc->period ) * exc->period;
+      val += exc->phase;
+      if ( val < 0 )
+        val = exc->phase;
+    }
+    else
+    {
+      val = -( ( ( exc->threshold - exc->phase - distance + compensation ) /
+                   exc->period ) * exc->period );
+      val -= exc->phase;
+      if ( val > 0 )
+        val = -exc->phase;
+    }
+
+    return val;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    Compute_Round                                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Sets the rounding mode.                                            */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    round_mode :: The rounding mode to be used.                        */
+  /*                                                                       */
+  static void
+  Compute_Round( TT_ExecContext  exc,
+                 FT_Byte         round_mode )
+  {
+    switch ( round_mode )
+    {
+    case TT_Round_Off:
+      exc->func_round = (TT_Round_Func)Round_None;
+      break;
+
+    case TT_Round_To_Grid:
+      exc->func_round = (TT_Round_Func)Round_To_Grid;
+      break;
+
+    case TT_Round_Up_To_Grid:
+      exc->func_round = (TT_Round_Func)Round_Up_To_Grid;
+      break;
+
+    case TT_Round_Down_To_Grid:
+      exc->func_round = (TT_Round_Func)Round_Down_To_Grid;
+      break;
+
+    case TT_Round_To_Half_Grid:
+      exc->func_round = (TT_Round_Func)Round_To_Half_Grid;
+      break;
+
+    case TT_Round_To_Double_Grid:
+      exc->func_round = (TT_Round_Func)Round_To_Double_Grid;
+      break;
+
+    case TT_Round_Super:
+      exc->func_round = (TT_Round_Func)Round_Super;
+      break;
+
+    case TT_Round_Super_45:
+      exc->func_round = (TT_Round_Func)Round_Super_45;
+      break;
+    }
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    SetSuperRound                                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Sets Super Round parameters.                                       */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    GridPeriod :: The grid period.                                     */
+  /*                                                                       */
+  /*    selector   :: The SROUND opcode.                                   */
+  /*                                                                       */
+  static void
+  SetSuperRound( TT_ExecContext  exc,
+                 FT_F2Dot14      GridPeriod,
+                 FT_Long         selector )
+  {
+    switch ( (FT_Int)( selector & 0xC0 ) )
+    {
+      case 0:
+        exc->period = GridPeriod / 2;
+        break;
+
+      case 0x40:
+        exc->period = GridPeriod;
+        break;
+
+      case 0x80:
+        exc->period = GridPeriod * 2;
+        break;
+
+      /* This opcode is reserved, but... */
+      case 0xC0:
+        exc->period = GridPeriod;
+        break;
+    }
+
+    switch ( (FT_Int)( selector & 0x30 ) )
+    {
+    case 0:
+      exc->phase = 0;
+      break;
+
+    case 0x10:
+      exc->phase = exc->period / 4;
+      break;
+
+    case 0x20:
+      exc->phase = exc->period / 2;
+      break;
+
+    case 0x30:
+      exc->phase = exc->period * 3 / 4;
+      break;
+    }
+
+    if ( ( selector & 0x0F ) == 0 )
+      exc->threshold = exc->period - 1;
+    else
+      exc->threshold = ( (FT_Int)( selector & 0x0F ) - 4 ) * exc->period / 8;
+
+    /* convert to F26Dot6 format */
+    exc->period    >>= 8;
+    exc->phase     >>= 8;
+    exc->threshold >>= 8;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    Project                                                            */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Computes the projection of vector given by (v2-v1) along the       */
+  /*    current projection vector.                                         */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    v1 :: First input vector.                                          */
+  /*    v2 :: Second input vector.                                         */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    The distance in F26dot6 format.                                    */
+  /*                                                                       */
+  static FT_F26Dot6
+  Project( TT_ExecContext  exc,
+           FT_Pos          dx,
+           FT_Pos          dy )
+  {
+    return TT_DotFix14( dx, dy,
+                        exc->GS.projVector.x,
+                        exc->GS.projVector.y );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    Dual_Project                                                       */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Computes the projection of the vector given by (v2-v1) along the   */
+  /*    current dual vector.                                               */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    v1 :: First input vector.                                          */
+  /*    v2 :: Second input vector.                                         */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    The distance in F26dot6 format.                                    */
+  /*                                                                       */
+  static FT_F26Dot6
+  Dual_Project( TT_ExecContext  exc,
+                FT_Pos          dx,
+                FT_Pos          dy )
+  {
+    return TT_DotFix14( dx, dy,
+                        exc->GS.dualVector.x,
+                        exc->GS.dualVector.y );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    Project_x                                                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Computes the projection of the vector given by (v2-v1) along the   */
+  /*    horizontal axis.                                                   */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    v1 :: First input vector.                                          */
+  /*    v2 :: Second input vector.                                         */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    The distance in F26dot6 format.                                    */
+  /*                                                                       */
+  static FT_F26Dot6
+  Project_x( TT_ExecContext  exc,
+             FT_Pos          dx,
+             FT_Pos          dy )
+  {
+    FT_UNUSED( exc );
+    FT_UNUSED( dy );
+
+    return dx;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    Project_y                                                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Computes the projection of the vector given by (v2-v1) along the   */
+  /*    vertical axis.                                                     */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    v1 :: First input vector.                                          */
+  /*    v2 :: Second input vector.                                         */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    The distance in F26dot6 format.                                    */
+  /*                                                                       */
+  static FT_F26Dot6
+  Project_y( TT_ExecContext  exc,
+             FT_Pos          dx,
+             FT_Pos          dy )
+  {
+    FT_UNUSED( exc );
+    FT_UNUSED( dx );
+
+    return dy;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    Compute_Funcs                                                      */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Computes the projection and movement function pointers according   */
+  /*    to the current graphics state.                                     */
+  /*                                                                       */
+  static void
+  Compute_Funcs( TT_ExecContext  exc )
+  {
+    if ( exc->GS.freeVector.x == 0x4000 )
+      exc->F_dot_P = exc->GS.projVector.x;
+    else if ( exc->GS.freeVector.y == 0x4000 )
+      exc->F_dot_P = exc->GS.projVector.y;
+    else
+      exc->F_dot_P =
+        ( (FT_Long)exc->GS.projVector.x * exc->GS.freeVector.x +
+          (FT_Long)exc->GS.projVector.y * exc->GS.freeVector.y ) >> 14;
+
+    if ( exc->GS.projVector.x == 0x4000 )
+      exc->func_project = (TT_Project_Func)Project_x;
+    else if ( exc->GS.projVector.y == 0x4000 )
+      exc->func_project = (TT_Project_Func)Project_y;
+    else
+      exc->func_project = (TT_Project_Func)Project;
+
+    if ( exc->GS.dualVector.x == 0x4000 )
+      exc->func_dualproj = (TT_Project_Func)Project_x;
+    else if ( exc->GS.dualVector.y == 0x4000 )
+      exc->func_dualproj = (TT_Project_Func)Project_y;
+    else
+      exc->func_dualproj = (TT_Project_Func)Dual_Project;
+
+    exc->func_move      = (TT_Move_Func)Direct_Move;
+    exc->func_move_orig = (TT_Move_Func)Direct_Move_Orig;
+
+    if ( exc->F_dot_P == 0x4000L )
+    {
+      if ( exc->GS.freeVector.x == 0x4000 )
+      {
+        exc->func_move      = (TT_Move_Func)Direct_Move_X;
+        exc->func_move_orig = (TT_Move_Func)Direct_Move_Orig_X;
+      }
+      else if ( exc->GS.freeVector.y == 0x4000 )
+      {
+        exc->func_move      = (TT_Move_Func)Direct_Move_Y;
+        exc->func_move_orig = (TT_Move_Func)Direct_Move_Orig_Y;
+      }
+    }
+
+    /* at small sizes, F_dot_P can become too small, resulting   */
+    /* in overflows and `spikes' in a number of glyphs like `w'. */
+
+    if ( FT_ABS( exc->F_dot_P ) < 0x400L )
+      exc->F_dot_P = 0x4000L;
+
+    /* Disable cached aspect ratio */
+    exc->tt_metrics.ratio = 0;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* <Function>                                                            */
+  /*    Normalize                                                          */
+  /*                                                                       */
+  /* <Description>                                                         */
+  /*    Norms a vector.                                                    */
+  /*                                                                       */
+  /* <Input>                                                               */
+  /*    Vx :: The horizontal input vector coordinate.                      */
+  /*    Vy :: The vertical input vector coordinate.                        */
+  /*                                                                       */
+  /* <Output>                                                              */
+  /*    R  :: The normed unit vector.                                      */
+  /*                                                                       */
+  /* <Return>                                                              */
+  /*    Returns FAILURE if a vector parameter is zero.                     */
+  /*                                                                       */
+  /* <Note>                                                                */
+  /*    In case Vx and Vy are both zero, `Normalize' returns SUCCESS, and  */
+  /*    R is undefined.                                                    */
+  /*                                                                       */
+  static FT_Bool
+  Normalize( FT_F26Dot6      Vx,
+             FT_F26Dot6      Vy,
+             FT_UnitVector*  R )
+  {
+    FT_Vector V;
+
+
+    if ( Vx == 0 && Vy == 0 )
+    {
+      /* XXX: UNDOCUMENTED! It seems that it is possible to try   */
+      /*      to normalize the vector (0,0).  Return immediately. */
+      return SUCCESS;
+    }
+
+    V.x = Vx;
+    V.y = Vy;
+
+    FT_Vector_NormLen( &V );
+
+    R->x = (FT_F2Dot14)( V.x / 4 );
+    R->y = (FT_F2Dot14)( V.y / 4 );
+
+    return SUCCESS;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Here we start with the implementation of the various opcodes.         */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+#define ARRAY_BOUND_ERROR                         \
+    do                                            \
+    {                                             \
+      exc->error = FT_THROW( Invalid_Reference ); \
+      return;                                     \
+    } while (0)
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* MPPEM[]:      Measure Pixel Per EM                                    */
+  /* Opcode range: 0x4B                                                    */
+  /* Stack:        --> Euint16                                             */
+  /*                                                                       */
+  static void
+  Ins_MPPEM( TT_ExecContext  exc,
+             FT_Long*        args )
+  {
+    args[0] = exc->func_cur_ppem( exc );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* MPS[]:        Measure Point Size                                      */
+  /* Opcode range: 0x4C                                                    */
+  /* Stack:        --> Euint16                                             */
+  /*                                                                       */
+  static void
+  Ins_MPS( TT_ExecContext  exc,
+           FT_Long*        args )
+  {
+    if ( NO_SUBPIXEL_HINTING )
+    {
+      /* Microsoft's GDI bytecode interpreter always returns value 12; */
+      /* we return the current PPEM value instead.                     */
+      args[0] = exc->func_cur_ppem( exc );
+    }
+    else
+    {
+      /* A possible practical application of the MPS instruction is to   */
+      /* implement optical scaling and similar features, which should be */
+      /* based on perceptual attributes, thus independent of the         */
+      /* resolution.                                                     */
+      args[0] = exc->pointSize;
+    }
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* DUP[]:        DUPlicate the stack's top element                       */
+  /* Opcode range: 0x20                                                    */
+  /* Stack:        StkElt --> StkElt StkElt                                */
+  /*                                                                       */
+  static void
+  Ins_DUP( FT_Long*  args )
+  {
+    args[1] = args[0];
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* POP[]:        POP the stack's top element                             */
+  /* Opcode range: 0x21                                                    */
+  /* Stack:        StkElt -->                                              */
+  /*                                                                       */
+  static void
+  Ins_POP( void )
+  {
+    /* nothing to do */
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* CLEAR[]:      CLEAR the entire stack                                  */
+  /* Opcode range: 0x22                                                    */
+  /* Stack:        StkElt... -->                                           */
+  /*                                                                       */
+  static void
+  Ins_CLEAR( TT_ExecContext  exc )
+  {
+    exc->new_top = 0;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SWAP[]:       SWAP the stack's top two elements                       */
+  /* Opcode range: 0x23                                                    */
+  /* Stack:        2 * StkElt --> 2 * StkElt                               */
+  /*                                                                       */
+  static void
+  Ins_SWAP( FT_Long*  args )
+  {
+    FT_Long  L;
+
+
+    L       = args[0];
+    args[0] = args[1];
+    args[1] = L;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* DEPTH[]:      return the stack DEPTH                                  */
+  /* Opcode range: 0x24                                                    */
+  /* Stack:        --> uint32                                              */
+  /*                                                                       */
+  static void
+  Ins_DEPTH( TT_ExecContext  exc,
+             FT_Long*        args )
+  {
+    args[0] = exc->top;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* LT[]:         Less Than                                               */
+  /* Opcode range: 0x50                                                    */
+  /* Stack:        int32? int32? --> bool                                  */
+  /*                                                                       */
+  static void
+  Ins_LT( FT_Long*  args )
+  {
+    args[0] = ( args[0] < args[1] );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* LTEQ[]:       Less Than or EQual                                      */
+  /* Opcode range: 0x51                                                    */
+  /* Stack:        int32? int32? --> bool                                  */
+  /*                                                                       */
+  static void
+  Ins_LTEQ( FT_Long*  args )
+  {
+    args[0] = ( args[0] <= args[1] );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* GT[]:         Greater Than                                            */
+  /* Opcode range: 0x52                                                    */
+  /* Stack:        int32? int32? --> bool                                  */
+  /*                                                                       */
+  static void
+  Ins_GT( FT_Long*  args )
+  {
+    args[0] = ( args[0] > args[1] );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* GTEQ[]:       Greater Than or EQual                                   */
+  /* Opcode range: 0x53                                                    */
+  /* Stack:        int32? int32? --> bool                                  */
+  /*                                                                       */
+  static void
+  Ins_GTEQ( FT_Long*  args )
+  {
+    args[0] = ( args[0] >= args[1] );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* EQ[]:         EQual                                                   */
+  /* Opcode range: 0x54                                                    */
+  /* Stack:        StkElt StkElt --> bool                                  */
+  /*                                                                       */
+  static void
+  Ins_EQ( FT_Long*  args )
+  {
+    args[0] = ( args[0] == args[1] );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* NEQ[]:        Not EQual                                               */
+  /* Opcode range: 0x55                                                    */
+  /* Stack:        StkElt StkElt --> bool                                  */
+  /*                                                                       */
+  static void
+  Ins_NEQ( FT_Long*  args )
+  {
+    args[0] = ( args[0] != args[1] );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* ODD[]:        Is ODD                                                  */
+  /* Opcode range: 0x56                                                    */
+  /* Stack:        f26.6 --> bool                                          */
+  /*                                                                       */
+  static void
+  Ins_ODD( TT_ExecContext  exc,
+           FT_Long*        args )
+  {
+    args[0] = ( ( exc->func_round( exc, args[0], 0 ) & 127 ) == 64 );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* EVEN[]:       Is EVEN                                                 */
+  /* Opcode range: 0x57                                                    */
+  /* Stack:        f26.6 --> bool                                          */
+  /*                                                                       */
+  static void
+  Ins_EVEN( TT_ExecContext  exc,
+            FT_Long*        args )
+  {
+    args[0] = ( ( exc->func_round( exc, args[0], 0 ) & 127 ) == 0 );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* AND[]:        logical AND                                             */
+  /* Opcode range: 0x5A                                                    */
+  /* Stack:        uint32 uint32 --> uint32                                */
+  /*                                                                       */
+  static void
+  Ins_AND( FT_Long*  args )
+  {
+    args[0] = ( args[0] && args[1] );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* OR[]:         logical OR                                              */
+  /* Opcode range: 0x5B                                                    */
+  /* Stack:        uint32 uint32 --> uint32                                */
+  /*                                                                       */
+  static void
+  Ins_OR( FT_Long*  args )
+  {
+    args[0] = ( args[0] || args[1] );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* NOT[]:        logical NOT                                             */
+  /* Opcode range: 0x5C                                                    */
+  /* Stack:        StkElt --> uint32                                       */
+  /*                                                                       */
+  static void
+  Ins_NOT( FT_Long*  args )
+  {
+    args[0] = !args[0];
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* ADD[]:        ADD                                                     */
+  /* Opcode range: 0x60                                                    */
+  /* Stack:        f26.6 f26.6 --> f26.6                                   */
+  /*                                                                       */
+  static void
+  Ins_ADD( FT_Long*  args )
+  {
+    args[0] += args[1];
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SUB[]:        SUBtract                                                */
+  /* Opcode range: 0x61                                                    */
+  /* Stack:        f26.6 f26.6 --> f26.6                                   */
+  /*                                                                       */
+  static void
+  Ins_SUB( FT_Long*  args )
+  {
+    args[0] -= args[1];
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* DIV[]:        DIVide                                                  */
+  /* Opcode range: 0x62                                                    */
+  /* Stack:        f26.6 f26.6 --> f26.6                                   */
+  /*                                                                       */
+  static void
+  Ins_DIV( TT_ExecContext  exc,
+           FT_Long*        args )
+  {
+    if ( args[1] == 0 )
+      exc->error = FT_THROW( Divide_By_Zero );
+    else
+      args[0] = FT_MulDiv_No_Round( args[0], 64L, args[1] );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* MUL[]:        MULtiply                                                */
+  /* Opcode range: 0x63                                                    */
+  /* Stack:        f26.6 f26.6 --> f26.6                                   */
+  /*                                                                       */
+  static void
+  Ins_MUL( FT_Long*  args )
+  {
+    args[0] = FT_MulDiv( args[0], args[1], 64L );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* ABS[]:        ABSolute value                                          */
+  /* Opcode range: 0x64                                                    */
+  /* Stack:        f26.6 --> f26.6                                         */
+  /*                                                                       */
+  static void
+  Ins_ABS( FT_Long*  args )
+  {
+    args[0] = FT_ABS( args[0] );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* NEG[]:        NEGate                                                  */
+  /* Opcode range: 0x65                                                    */
+  /* Stack:        f26.6 --> f26.6                                         */
+  /*                                                                       */
+  static void
+  Ins_NEG( FT_Long*  args )
+  {
+    args[0] = -args[0];
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* FLOOR[]:      FLOOR                                                   */
+  /* Opcode range: 0x66                                                    */
+  /* Stack:        f26.6 --> f26.6                                         */
+  /*                                                                       */
+  static void
+  Ins_FLOOR( FT_Long*  args )
+  {
+    args[0] = FT_PIX_FLOOR( args[0] );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* CEILING[]:    CEILING                                                 */
+  /* Opcode range: 0x67                                                    */
+  /* Stack:        f26.6 --> f26.6                                         */
+  /*                                                                       */
+  static void
+  Ins_CEILING( FT_Long*  args )
+  {
+    args[0] = FT_PIX_CEIL( args[0] );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* RS[]:         Read Store                                              */
+  /* Opcode range: 0x43                                                    */
+  /* Stack:        uint32 --> uint32                                       */
+  /*                                                                       */
+  static void
+  Ins_RS( TT_ExecContext  exc,
+          FT_Long*        args )
+  {
+    FT_ULong  I = (FT_ULong)args[0];
+
+
+    if ( BOUNDSL( I, exc->storeSize ) )
+    {
+      if ( exc->pedantic_hinting )
+        ARRAY_BOUND_ERROR;
+      else
+        args[0] = 0;
+    }
+    else
+    {
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+      /* subpixel hinting - avoid Typeman Dstroke and */
+      /* IStroke and Vacuform rounds                  */
+      if ( SUBPIXEL_HINTING_INFINALITY                 &&
+           exc->ignore_x_mode                          &&
+           ( ( I == 24                             &&
+               ( exc->face->sph_found_func_flags &
+                 ( SPH_FDEF_SPACING_1 |
+                   SPH_FDEF_SPACING_2 )          ) ) ||
+             ( I == 22                      &&
+               ( exc->sph_in_func_flags   &
+                 SPH_FDEF_TYPEMAN_STROKES ) )        ||
+             ( I == 8                              &&
+               ( exc->face->sph_found_func_flags &
+                 SPH_FDEF_VACUFORM_ROUND_1       ) &&
+               exc->iup_called                     ) ) )
+        args[0] = 0;
+      else
+#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
+        args[0] = exc->storage[I];
+    }
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* WS[]:         Write Store                                             */
+  /* Opcode range: 0x42                                                    */
+  /* Stack:        uint32 uint32 -->                                       */
+  /*                                                                       */
+  static void
+  Ins_WS( TT_ExecContext  exc,
+          FT_Long*        args )
+  {
+    FT_ULong  I = (FT_ULong)args[0];
+
+
+    if ( BOUNDSL( I, exc->storeSize ) )
+    {
+      if ( exc->pedantic_hinting )
+        ARRAY_BOUND_ERROR;
+    }
+    else
+      exc->storage[I] = args[1];
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* WCVTP[]:      Write CVT in Pixel units                                */
+  /* Opcode range: 0x44                                                    */
+  /* Stack:        f26.6 uint32 -->                                        */
+  /*                                                                       */
+  static void
+  Ins_WCVTP( TT_ExecContext  exc,
+             FT_Long*        args )
+  {
+    FT_ULong  I = (FT_ULong)args[0];
+
+
+    if ( BOUNDSL( I, exc->cvtSize ) )
+    {
+      if ( exc->pedantic_hinting )
+        ARRAY_BOUND_ERROR;
+    }
+    else
+      exc->func_write_cvt( exc, I, args[1] );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* WCVTF[]:      Write CVT in Funits                                     */
+  /* Opcode range: 0x70                                                    */
+  /* Stack:        uint32 uint32 -->                                       */
+  /*                                                                       */
+  static void
+  Ins_WCVTF( TT_ExecContext  exc,
+             FT_Long*        args )
+  {
+    FT_ULong  I = (FT_ULong)args[0];
+
+
+    if ( BOUNDSL( I, exc->cvtSize ) )
+    {
+      if ( exc->pedantic_hinting )
+        ARRAY_BOUND_ERROR;
+    }
+    else
+      exc->cvt[I] = FT_MulFix( args[1], exc->tt_metrics.scale );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* RCVT[]:       Read CVT                                                */
+  /* Opcode range: 0x45                                                    */
+  /* Stack:        uint32 --> f26.6                                        */
+  /*                                                                       */
+  static void
+  Ins_RCVT( TT_ExecContext  exc,
+            FT_Long*        args )
+  {
+    FT_ULong  I = (FT_ULong)args[0];
+
+
+    if ( BOUNDSL( I, exc->cvtSize ) )
+    {
+      if ( exc->pedantic_hinting )
+        ARRAY_BOUND_ERROR;
+      else
+        args[0] = 0;
+    }
+    else
+      args[0] = exc->func_read_cvt( exc, I );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* AA[]:         Adjust Angle                                            */
+  /* Opcode range: 0x7F                                                    */
+  /* Stack:        uint32 -->                                              */
+  /*                                                                       */
+  static void
+  Ins_AA( void )
+  {
+    /* intentionally no longer supported */
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* DEBUG[]:      DEBUG.  Unsupported.                                    */
+  /* Opcode range: 0x4F                                                    */
+  /* Stack:        uint32 -->                                              */
+  /*                                                                       */
+  /* Note: The original instruction pops a value from the stack.           */
+  /*                                                                       */
+  static void
+  Ins_DEBUG( TT_ExecContext  exc )
+  {
+    exc->error = FT_THROW( Debug_OpCode );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* ROUND[ab]:    ROUND value                                             */
+  /* Opcode range: 0x68-0x6B                                               */
+  /* Stack:        f26.6 --> f26.6                                         */
+  /*                                                                       */
+  static void
+  Ins_ROUND( TT_ExecContext  exc,
+             FT_Long*        args )
+  {
+    args[0] = exc->func_round(
+                exc,
+                args[0],
+                exc->tt_metrics.compensations[exc->opcode - 0x68] );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* NROUND[ab]:   No ROUNDing of value                                    */
+  /* Opcode range: 0x6C-0x6F                                               */
+  /* Stack:        f26.6 --> f26.6                                         */
+  /*                                                                       */
+  static void
+  Ins_NROUND( TT_ExecContext  exc,
+              FT_Long*        args )
+  {
+    args[0] = Round_None(
+                exc,
+                args[0],
+                exc->tt_metrics.compensations[exc->opcode - 0x6C] );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* MAX[]:        MAXimum                                                 */
+  /* Opcode range: 0x8B                                                    */
+  /* Stack:        int32? int32? --> int32                                 */
+  /*                                                                       */
+  static void
+  Ins_MAX( FT_Long*  args )
+  {
+    if ( args[1] > args[0] )
+      args[0] = args[1];
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* MIN[]:        MINimum                                                 */
+  /* Opcode range: 0x8C                                                    */
+  /* Stack:        int32? int32? --> int32                                 */
+  /*                                                                       */
+  static void
+  Ins_MIN( FT_Long*  args )
+  {
+    if ( args[1] < args[0] )
+      args[0] = args[1];
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* MINDEX[]:     Move INDEXed element                                    */
+  /* Opcode range: 0x26                                                    */
+  /* Stack:        int32? --> StkElt                                       */
+  /*                                                                       */
+  static void
+  Ins_MINDEX( TT_ExecContext  exc,
+              FT_Long*        args )
+  {
+    FT_Long  L, K;
+
+
+    L = args[0];
+
+    if ( L <= 0 || L > exc->args )
+    {
+      if ( exc->pedantic_hinting )
+        exc->error = FT_THROW( Invalid_Reference );
+    }
+    else
+    {
+      K = exc->stack[exc->args - L];
+
+      FT_ARRAY_MOVE( &exc->stack[exc->args - L    ],
+                     &exc->stack[exc->args - L + 1],
+                     ( L - 1 ) );
+
+      exc->stack[exc->args - 1] = K;
+    }
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* CINDEX[]:     Copy INDEXed element                                    */
+  /* Opcode range: 0x25                                                    */
+  /* Stack:        int32 --> StkElt                                        */
+  /*                                                                       */
+  static void
+  Ins_CINDEX( TT_ExecContext  exc,
+              FT_Long*        args )
+  {
+    FT_Long  L;
+
+
+    L = args[0];
+
+    if ( L <= 0 || L > exc->args )
+    {
+      if ( exc->pedantic_hinting )
+        exc->error = FT_THROW( Invalid_Reference );
+      args[0] = 0;
+    }
+    else
+      args[0] = exc->stack[exc->args - L];
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* ROLL[]:       ROLL top three elements                                 */
+  /* Opcode range: 0x8A                                                    */
+  /* Stack:        3 * StkElt --> 3 * StkElt                               */
+  /*                                                                       */
+  static void
+  Ins_ROLL( FT_Long*  args )
+  {
+    FT_Long  A, B, C;
+
+
+    A = args[2];
+    B = args[1];
+    C = args[0];
+
+    args[2] = C;
+    args[1] = A;
+    args[0] = B;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* MANAGING THE FLOW OF CONTROL                                          */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SLOOP[]:      Set LOOP variable                                       */
+  /* Opcode range: 0x17                                                    */
+  /* Stack:        int32? -->                                              */
+  /*                                                                       */
+  static void
+  Ins_SLOOP( TT_ExecContext  exc,
+             FT_Long*        args )
+  {
+    if ( args[0] < 0 )
+      exc->error = FT_THROW( Bad_Argument );
+    else
+      exc->GS.loop = args[0];
+  }
+
+
+  static FT_Bool
+  SkipCode( TT_ExecContext  exc )
+  {
+    exc->IP += exc->length;
+
+    if ( exc->IP < exc->codeSize )
+    {
+      exc->opcode = exc->code[exc->IP];
+
+      exc->length = opcode_length[exc->opcode];
+      if ( exc->length < 0 )
+      {
+        if ( exc->IP + 1 >= exc->codeSize )
+          goto Fail_Overflow;
+        exc->length = 2 - exc->length * exc->code[exc->IP + 1];
+      }
+
+      if ( exc->IP + exc->length <= exc->codeSize )
+        return SUCCESS;
+    }
+
+  Fail_Overflow:
+    exc->error = FT_THROW( Code_Overflow );
+    return FAILURE;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* IF[]:         IF test                                                 */
+  /* Opcode range: 0x58                                                    */
+  /* Stack:        StkElt -->                                              */
+  /*                                                                       */
+  static void
+  Ins_IF( TT_ExecContext  exc,
+          FT_Long*        args )
+  {
+    FT_Int   nIfs;
+    FT_Bool  Out;
+
+
+    if ( args[0] != 0 )
+      return;
+
+    nIfs = 1;
+    Out = 0;
+
+    do
+    {
+      if ( SkipCode( exc ) == FAILURE )
+        return;
+
+      switch ( exc->opcode )
+      {
+      case 0x58:      /* IF */
+        nIfs++;
+        break;
+
+      case 0x1B:      /* ELSE */
+        Out = FT_BOOL( nIfs == 1 );
+        break;
+
+      case 0x59:      /* EIF */
+        nIfs--;
+        Out = FT_BOOL( nIfs == 0 );
+        break;
+      }
+    } while ( Out == 0 );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* ELSE[]:       ELSE                                                    */
+  /* Opcode range: 0x1B                                                    */
+  /* Stack:        -->                                                     */
+  /*                                                                       */
+  static void
+  Ins_ELSE( TT_ExecContext  exc )
+  {
+    FT_Int  nIfs;
+
+
+    nIfs = 1;
+
+    do
+    {
+      if ( SkipCode( exc ) == FAILURE )
+        return;
+
+      switch ( exc->opcode )
+      {
+      case 0x58:    /* IF */
+        nIfs++;
+        break;
+
+      case 0x59:    /* EIF */
+        nIfs--;
+        break;
+      }
+    } while ( nIfs != 0 );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* EIF[]:        End IF                                                  */
+  /* Opcode range: 0x59                                                    */
+  /* Stack:        -->                                                     */
+  /*                                                                       */
+  static void
+  Ins_EIF( void )
+  {
+    /* nothing to do */
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* JMPR[]:       JuMP Relative                                           */
+  /* Opcode range: 0x1C                                                    */
+  /* Stack:        int32 -->                                               */
+  /*                                                                       */
+  static void
+  Ins_JMPR( TT_ExecContext  exc,
+            FT_Long*        args )
+  {
+    if ( args[0] == 0 && exc->args == 0 )
+      exc->error = FT_THROW( Bad_Argument );
+    exc->IP += args[0];
+    if ( exc->IP < 0                                             ||
+         ( exc->callTop > 0                                    &&
+           exc->IP > exc->callStack[exc->callTop - 1].Def->end ) )
+      exc->error = FT_THROW( Bad_Argument );
+    exc->step_ins = FALSE;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* JROT[]:       Jump Relative On True                                   */
+  /* Opcode range: 0x78                                                    */
+  /* Stack:        StkElt int32 -->                                        */
+  /*                                                                       */
+  static void
+  Ins_JROT( TT_ExecContext  exc,
+            FT_Long*        args )
+  {
+    if ( args[1] != 0 )
+      Ins_JMPR( exc, args );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* JROF[]:       Jump Relative On False                                  */
+  /* Opcode range: 0x79                                                    */
+  /* Stack:        StkElt int32 -->                                        */
+  /*                                                                       */
+  static void
+  Ins_JROF( TT_ExecContext  exc,
+            FT_Long*        args )
+  {
+    if ( args[1] == 0 )
+      Ins_JMPR( exc, args );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* DEFINING AND USING FUNCTIONS AND INSTRUCTIONS                         */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* FDEF[]:       Function DEFinition                                     */
+  /* Opcode range: 0x2C                                                    */
+  /* Stack:        uint32 -->                                              */
+  /*                                                                       */
+  static void
+  Ins_FDEF( TT_ExecContext  exc,
+            FT_Long*        args )
+  {
+    FT_ULong       n;
+    TT_DefRecord*  rec;
+    TT_DefRecord*  limit;
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+    /* arguments to opcodes are skipped by `SKIP_Code' */
+    FT_Byte    opcode_pattern[9][12] = {
+                 /* #0 inline delta function 1 */
+                 {
+                   0x4B, /* PPEM    */
+                   0x53, /* GTEQ    */
+                   0x23, /* SWAP    */
+                   0x4B, /* PPEM    */
+                   0x51, /* LTEQ    */
+                   0x5A, /* AND     */
+                   0x58, /* IF      */
+                   0x38, /*   SHPIX */
+                   0x1B, /* ELSE    */
+                   0x21, /*   POP   */
+                   0x21, /*   POP   */
+                   0x59  /* EIF     */
+                 },
+                 /* #1 inline delta function 2 */
+                 {
+                   0x4B, /* PPEM    */
+                   0x54, /* EQ      */
+                   0x58, /* IF      */
+                   0x38, /*   SHPIX */
+                   0x1B, /* ELSE    */
+                   0x21, /*   POP   */
+                   0x21, /*   POP   */
+                   0x59  /* EIF     */
+                 },
+                 /* #2 diagonal stroke function */
+                 {
+                   0x20, /* DUP     */
+                   0x20, /* DUP     */
+                   0xB0, /* PUSHB_1 */
+                         /*   1     */
+                   0x60, /* ADD     */
+                   0x46, /* GC_cur  */
+                   0xB0, /* PUSHB_1 */
+                         /*   64    */
+                   0x23, /* SWAP    */
+                   0x42  /* WS      */
+                 },
+                 /* #3 VacuFormRound function */
+                 {
+                   0x45, /* RCVT    */
+                   0x23, /* SWAP    */
+                   0x46, /* GC_cur  */
+                   0x60, /* ADD     */
+                   0x20, /* DUP     */
+                   0xB0  /* PUSHB_1 */
+                         /*   38    */
+                 },
+                 /* #4 TTFautohint bytecode (old) */
+                 {
+                   0x20, /* DUP     */
+                   0x64, /* ABS     */
+                   0xB0, /* PUSHB_1 */
+                         /*   32    */
+                   0x60, /* ADD     */
+                   0x66, /* FLOOR   */
+                   0x23, /* SWAP    */
+                   0xB0  /* PUSHB_1 */
+                 },
+                 /* #5 spacing function 1 */
+                 {
+                   0x01, /* SVTCA_x */
+                   0xB0, /* PUSHB_1 */
+                         /*   24    */
+                   0x43, /* RS      */
+                   0x58  /* IF      */
+                 },
+                 /* #6 spacing function 2 */
+                 {
+                   0x01, /* SVTCA_x */
+                   0x18, /* RTG     */
+                   0xB0, /* PUSHB_1 */
+                         /*   24    */
+                   0x43, /* RS      */
+                   0x58  /* IF      */
+                 },
+                 /* #7 TypeMan Talk DiagEndCtrl function */
+                 {
+                   0x01, /* SVTCA_x */
+                   0x20, /* DUP     */
+                   0xB0, /* PUSHB_1 */
+                         /*   3     */
+                   0x25, /* CINDEX  */
+                 },
+                 /* #8 TypeMan Talk Align */
+                 {
+                   0x06, /* SPVTL   */
+                   0x7D, /* RDTG    */
+                 },
+               };
+    FT_UShort  opcode_patterns   = 9;
+    FT_UShort  opcode_pointer[9] = {  0, 0, 0, 0, 0, 0, 0, 0, 0 };
+    FT_UShort  opcode_size[9]    = { 12, 8, 8, 6, 7, 4, 5, 4, 2 };
+    FT_UShort  i;
+#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
+
+
+    /* some font programs are broken enough to redefine functions! */
+    /* We will then parse the current table.                       */
+
+    rec   = exc->FDefs;
+    limit = rec + exc->numFDefs;
+    n     = (FT_ULong)args[0];
+
+    for ( ; rec < limit; rec++ )
+    {
+      if ( rec->opc == n )
+        break;
+    }
+
+    if ( rec == limit )
+    {
+      /* check that there is enough room for new functions */
+      if ( exc->numFDefs >= exc->maxFDefs )
+      {
+        exc->error = FT_THROW( Too_Many_Function_Defs );
+        return;
+      }
+      exc->numFDefs++;
+    }
+
+    /* Although FDEF takes unsigned 32-bit integer,  */
+    /* func # must be within unsigned 16-bit integer */
+    if ( n > 0xFFFFU )
+    {
+      exc->error = FT_THROW( Too_Many_Function_Defs );
+      return;
+    }
+
+    rec->range          = exc->curRange;
+    rec->opc            = (FT_UInt16)n;
+    rec->start          = exc->IP + 1;
+    rec->active         = TRUE;
+    rec->inline_delta   = FALSE;
+    rec->sph_fdef_flags = 0x0000;
+
+    if ( n > exc->maxFunc )
+      exc->maxFunc = (FT_UInt16)n;
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+    /* We don't know for sure these are typeman functions, */
+    /* however they are only active when RS 22 is called   */
+    if ( n >= 64 && n <= 66 )
+      rec->sph_fdef_flags |= SPH_FDEF_TYPEMAN_STROKES;
+#endif
+
+    /* Now skip the whole function definition. */
+    /* We don't allow nested IDEFS & FDEFs.    */
+
+    while ( SkipCode( exc ) == SUCCESS )
+    {
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+
+      if ( SUBPIXEL_HINTING_INFINALITY )
+      {
+        for ( i = 0; i < opcode_patterns; i++ )
+        {
+          if ( opcode_pointer[i] < opcode_size[i]                  &&
+               exc->opcode == opcode_pattern[i][opcode_pointer[i]] )
+          {
+            opcode_pointer[i] += 1;
+
+            if ( opcode_pointer[i] == opcode_size[i] )
+            {
+              FT_TRACE6(( "sph: Function %d, opcode ptrn: %d, %s %s\n",
+                          i, n,
+                          exc->face->root.family_name,
+                          exc->face->root.style_name ));
+
+              switch ( i )
+              {
+              case 0:
+                rec->sph_fdef_flags             |= SPH_FDEF_INLINE_DELTA_1;
+                exc->face->sph_found_func_flags |= SPH_FDEF_INLINE_DELTA_1;
+                break;
+
+              case 1:
+                rec->sph_fdef_flags             |= SPH_FDEF_INLINE_DELTA_2;
+                exc->face->sph_found_func_flags |= SPH_FDEF_INLINE_DELTA_2;
+                break;
+
+              case 2:
+                switch ( n )
+                {
+                  /* needs to be implemented still */
+                case 58:
+                  rec->sph_fdef_flags             |= SPH_FDEF_DIAGONAL_STROKE;
+                  exc->face->sph_found_func_flags |= SPH_FDEF_DIAGONAL_STROKE;
+                }
+                break;
+
+              case 3:
+                switch ( n )
+                {
+                case 0:
+                  rec->sph_fdef_flags             |= SPH_FDEF_VACUFORM_ROUND_1;
+                  exc->face->sph_found_func_flags |= SPH_FDEF_VACUFORM_ROUND_1;
+                }
+                break;
+
+              case 4:
+                /* probably not necessary to detect anymore */
+                rec->sph_fdef_flags             |= SPH_FDEF_TTFAUTOHINT_1;
+                exc->face->sph_found_func_flags |= SPH_FDEF_TTFAUTOHINT_1;
+                break;
+
+              case 5:
+                switch ( n )
+                {
+                case 0:
+                case 1:
+                case 2:
+                case 4:
+                case 7:
+                case 8:
+                  rec->sph_fdef_flags             |= SPH_FDEF_SPACING_1;
+                  exc->face->sph_found_func_flags |= SPH_FDEF_SPACING_1;
+                }
+                break;
+
+              case 6:
+                switch ( n )
+                {
+                case 0:
+                case 1:
+                case 2:
+                case 4:
+                case 7:
+                case 8:
+                  rec->sph_fdef_flags             |= SPH_FDEF_SPACING_2;
+                  exc->face->sph_found_func_flags |= SPH_FDEF_SPACING_2;
+                }
+                break;
+
+               case 7:
+                 rec->sph_fdef_flags             |= SPH_FDEF_TYPEMAN_DIAGENDCTRL;
+                 exc->face->sph_found_func_flags |= SPH_FDEF_TYPEMAN_DIAGENDCTRL;
+                 break;
+
+               case 8:
+#if 0
+                 rec->sph_fdef_flags             |= SPH_FDEF_TYPEMAN_DIAGENDCTRL;
+                 exc->face->sph_found_func_flags |= SPH_FDEF_TYPEMAN_DIAGENDCTRL;
+#endif
+                 break;
+              }
+              opcode_pointer[i] = 0;
+            }
+          }
+
+          else
+            opcode_pointer[i] = 0;
+        }
+
+        /* Set sph_compatibility_mode only when deltas are detected */
+        exc->face->sph_compatibility_mode =
+          ( ( exc->face->sph_found_func_flags & SPH_FDEF_INLINE_DELTA_1 ) |
+            ( exc->face->sph_found_func_flags & SPH_FDEF_INLINE_DELTA_2 ) );
+      }
+
+#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
+
+      switch ( exc->opcode )
+      {
+      case 0x89:    /* IDEF */
+      case 0x2C:    /* FDEF */
+        exc->error = FT_THROW( Nested_DEFS );
+        return;
+
+      case 0x2D:   /* ENDF */
+        rec->end = exc->IP;
+        return;
+      }
+    }
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* ENDF[]:       END Function definition                                 */
+  /* Opcode range: 0x2D                                                    */
+  /* Stack:        -->                                                     */
+  /*                                                                       */
+  static void
+  Ins_ENDF( TT_ExecContext  exc )
+  {
+    TT_CallRec*  pRec;
+
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+    exc->sph_in_func_flags = 0x0000;
+#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
+
+    if ( exc->callTop <= 0 )     /* We encountered an ENDF without a call */
+    {
+      exc->error = FT_THROW( ENDF_In_Exec_Stream );
+      return;
+    }
+
+    exc->callTop--;
+
+    pRec = &exc->callStack[exc->callTop];
+
+    pRec->Cur_Count--;
+
+    exc->step_ins = FALSE;
+
+    if ( pRec->Cur_Count > 0 )
+    {
+      exc->callTop++;
+      exc->IP = pRec->Def->start;
+    }
+    else
+      /* Loop through the current function */
+      Ins_Goto_CodeRange( exc, pRec->Caller_Range, pRec->Caller_IP );
+
+    /* Exit the current call frame.                      */
+
+    /* NOTE: If the last instruction of a program is a   */
+    /*       CALL or LOOPCALL, the return address is     */
+    /*       always out of the code range.  This is a    */
+    /*       valid address, and it is why we do not test */
+    /*       the result of Ins_Goto_CodeRange() here!    */
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* CALL[]:       CALL function                                           */
+  /* Opcode range: 0x2B                                                    */
+  /* Stack:        uint32? -->                                             */
+  /*                                                                       */
+  static void
+  Ins_CALL( TT_ExecContext  exc,
+            FT_Long*        args )
+  {
+    FT_ULong       F;
+    TT_CallRec*    pCrec;
+    TT_DefRecord*  def;
+
+
+    /* first of all, check the index */
+
+    F = (FT_ULong)args[0];
+    if ( BOUNDSL( F, exc->maxFunc + 1 ) )
+      goto Fail;
+
+    /* Except for some old Apple fonts, all functions in a TrueType */
+    /* font are defined in increasing order, starting from 0.  This */
+    /* means that we normally have                                  */
+    /*                                                              */
+    /*    exc->maxFunc+1 == exc->numFDefs                           */
+    /*    exc->FDefs[n].opc == n for n in 0..exc->maxFunc           */
+    /*                                                              */
+    /* If this isn't true, we need to look up the function table.   */
+
+    def = exc->FDefs + F;
+    if ( exc->maxFunc + 1 != exc->numFDefs || def->opc != F )
+    {
+      /* look up the FDefs table */
+      TT_DefRecord*  limit;
+
+
+      def   = exc->FDefs;
+      limit = def + exc->numFDefs;
+
+      while ( def < limit && def->opc != F )
+        def++;
+
+      if ( def == limit )
+        goto Fail;
+    }
+
+    /* check that the function is active */
+    if ( !def->active )
+      goto Fail;
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+    if ( SUBPIXEL_HINTING_INFINALITY                                    &&
+         exc->ignore_x_mode                                             &&
+         ( ( exc->iup_called                                        &&
+             ( exc->sph_tweak_flags & SPH_TWEAK_NO_CALL_AFTER_IUP ) ) ||
+           ( def->sph_fdef_flags & SPH_FDEF_VACUFORM_ROUND_1 )        ) )
+      goto Fail;
+    else
+      exc->sph_in_func_flags = def->sph_fdef_flags;
+#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
+
+    /* check the call stack */
+    if ( exc->callTop >= exc->callSize )
+    {
+      exc->error = FT_THROW( Stack_Overflow );
+      return;
+    }
+
+    pCrec = exc->callStack + exc->callTop;
+
+    pCrec->Caller_Range = exc->curRange;
+    pCrec->Caller_IP    = exc->IP + 1;
+    pCrec->Cur_Count    = 1;
+    pCrec->Def          = def;
+
+    exc->callTop++;
+
+    Ins_Goto_CodeRange( exc, def->range, def->start );
+
+    exc->step_ins = FALSE;
+
+    return;
+
+  Fail:
+    exc->error = FT_THROW( Invalid_Reference );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* LOOPCALL[]:   LOOP and CALL function                                  */
+  /* Opcode range: 0x2A                                                    */
+  /* Stack:        uint32? Eint16? -->                                     */
+  /*                                                                       */
+  static void
+  Ins_LOOPCALL( TT_ExecContext  exc,
+                FT_Long*        args )
+  {
+    FT_ULong       F;
+    TT_CallRec*    pCrec;
+    TT_DefRecord*  def;
+
+
+    /* first of all, check the index */
+    F = (FT_ULong)args[1];
+    if ( BOUNDSL( F, exc->maxFunc + 1 ) )
+      goto Fail;
+
+    /* Except for some old Apple fonts, all functions in a TrueType */
+    /* font are defined in increasing order, starting from 0.  This */
+    /* means that we normally have                                  */
+    /*                                                              */
+    /*    exc->maxFunc+1 == exc->numFDefs                           */
+    /*    exc->FDefs[n].opc == n for n in 0..exc->maxFunc           */
+    /*                                                              */
+    /* If this isn't true, we need to look up the function table.   */
+
+    def = exc->FDefs + F;
+    if ( exc->maxFunc + 1 != exc->numFDefs || def->opc != F )
+    {
+      /* look up the FDefs table */
+      TT_DefRecord*  limit;
+
+
+      def   = exc->FDefs;
+      limit = def + exc->numFDefs;
+
+      while ( def < limit && def->opc != F )
+        def++;
+
+      if ( def == limit )
+        goto Fail;
+    }
+
+    /* check that the function is active */
+    if ( !def->active )
+      goto Fail;
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+    if ( SUBPIXEL_HINTING_INFINALITY                         &&
+         exc->ignore_x_mode                                  &&
+         ( def->sph_fdef_flags & SPH_FDEF_VACUFORM_ROUND_1 ) )
+      goto Fail;
+    else
+      exc->sph_in_func_flags = def->sph_fdef_flags;
+#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
+
+    /* check stack */
+    if ( exc->callTop >= exc->callSize )
+    {
+      exc->error = FT_THROW( Stack_Overflow );
+      return;
+    }
+
+    if ( args[0] > 0 )
+    {
+      pCrec = exc->callStack + exc->callTop;
+
+      pCrec->Caller_Range = exc->curRange;
+      pCrec->Caller_IP    = exc->IP + 1;
+      pCrec->Cur_Count    = (FT_Int)args[0];
+      pCrec->Def          = def;
+
+      exc->callTop++;
+
+      Ins_Goto_CodeRange( exc, def->range, def->start );
+
+      exc->step_ins = FALSE;
+    }
+
+    return;
+
+  Fail:
+    exc->error = FT_THROW( Invalid_Reference );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* IDEF[]:       Instruction DEFinition                                  */
+  /* Opcode range: 0x89                                                    */
+  /* Stack:        Eint8 -->                                               */
+  /*                                                                       */
+  static void
+  Ins_IDEF( TT_ExecContext  exc,
+            FT_Long*        args )
+  {
+    TT_DefRecord*  def;
+    TT_DefRecord*  limit;
+
+
+    /*  First of all, look for the same function in our table */
+
+    def   = exc->IDefs;
+    limit = def + exc->numIDefs;
+
+    for ( ; def < limit; def++ )
+      if ( def->opc == (FT_ULong)args[0] )
+        break;
+
+    if ( def == limit )
+    {
+      /* check that there is enough room for a new instruction */
+      if ( exc->numIDefs >= exc->maxIDefs )
+      {
+        exc->error = FT_THROW( Too_Many_Instruction_Defs );
+        return;
+      }
+      exc->numIDefs++;
+    }
+
+    /* opcode must be unsigned 8-bit integer */
+    if ( 0 > args[0] || args[0] > 0x00FF )
+    {
+      exc->error = FT_THROW( Too_Many_Instruction_Defs );
+      return;
+    }
+
+    def->opc    = (FT_Byte)args[0];
+    def->start  = exc->IP + 1;
+    def->range  = exc->curRange;
+    def->active = TRUE;
+
+    if ( (FT_ULong)args[0] > exc->maxIns )
+      exc->maxIns = (FT_Byte)args[0];
+
+    /* Now skip the whole function definition. */
+    /* We don't allow nested IDEFs & FDEFs.    */
+
+    while ( SkipCode( exc ) == SUCCESS )
+    {
+      switch ( exc->opcode )
+      {
+      case 0x89:   /* IDEF */
+      case 0x2C:   /* FDEF */
+        exc->error = FT_THROW( Nested_DEFS );
+        return;
+      case 0x2D:   /* ENDF */
+        def->end = exc->IP;
+        return;
+      }
+    }
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* PUSHING DATA ONTO THE INTERPRETER STACK                               */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* NPUSHB[]:     PUSH N Bytes                                            */
+  /* Opcode range: 0x40                                                    */
+  /* Stack:        --> uint32...                                           */
+  /*                                                                       */
+  static void
+  Ins_NPUSHB( TT_ExecContext  exc,
+              FT_Long*        args )
+  {
+    FT_UShort  L, K;
+
+
+    L = (FT_UShort)exc->code[exc->IP + 1];
+
+    if ( BOUNDS( L, exc->stackSize + 1 - exc->top ) )
+    {
+      exc->error = FT_THROW( Stack_Overflow );
+      return;
+    }
+
+    for ( K = 1; K <= L; K++ )
+      args[K - 1] = exc->code[exc->IP + K + 1];
+
+    exc->new_top += L;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* NPUSHW[]:     PUSH N Words                                            */
+  /* Opcode range: 0x41                                                    */
+  /* Stack:        --> int32...                                            */
+  /*                                                                       */
+  static void
+  Ins_NPUSHW( TT_ExecContext  exc,
+              FT_Long*        args )
+  {
+    FT_UShort  L, K;
+
+
+    L = (FT_UShort)exc->code[exc->IP + 1];
+
+    if ( BOUNDS( L, exc->stackSize + 1 - exc->top ) )
+    {
+      exc->error = FT_THROW( Stack_Overflow );
+      return;
+    }
+
+    exc->IP += 2;
+
+    for ( K = 0; K < L; K++ )
+      args[K] = GetShortIns( exc );
+
+    exc->step_ins = FALSE;
+    exc->new_top += L;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* PUSHB[abc]:   PUSH Bytes                                              */
+  /* Opcode range: 0xB0-0xB7                                               */
+  /* Stack:        --> uint32...                                           */
+  /*                                                                       */
+  static void
+  Ins_PUSHB( TT_ExecContext  exc,
+             FT_Long*        args )
+  {
+    FT_UShort  L, K;
+
+
+    L = (FT_UShort)( exc->opcode - 0xB0 + 1 );
+
+    if ( BOUNDS( L, exc->stackSize + 1 - exc->top ) )
+    {
+      exc->error = FT_THROW( Stack_Overflow );
+      return;
+    }
+
+    for ( K = 1; K <= L; K++ )
+      args[K - 1] = exc->code[exc->IP + K];
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* PUSHW[abc]:   PUSH Words                                              */
+  /* Opcode range: 0xB8-0xBF                                               */
+  /* Stack:        --> int32...                                            */
+  /*                                                                       */
+  static void
+  Ins_PUSHW( TT_ExecContext  exc,
+             FT_Long*        args )
+  {
+    FT_UShort  L, K;
+
+
+    L = (FT_UShort)( exc->opcode - 0xB8 + 1 );
+
+    if ( BOUNDS( L, exc->stackSize + 1 - exc->top ) )
+    {
+      exc->error = FT_THROW( Stack_Overflow );
+      return;
+    }
+
+    exc->IP++;
+
+    for ( K = 0; K < L; K++ )
+      args[K] = GetShortIns( exc );
+
+    exc->step_ins = FALSE;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* MANAGING THE GRAPHICS STATE                                           */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  static FT_Bool
+  Ins_SxVTL( TT_ExecContext  exc,
+             FT_UShort       aIdx1,
+             FT_UShort       aIdx2,
+             FT_UnitVector*  Vec )
+  {
+    FT_Long     A, B, C;
+    FT_Vector*  p1;
+    FT_Vector*  p2;
+
+    FT_Byte  opcode = exc->opcode;
+
+
+    if ( BOUNDS( aIdx1, exc->zp2.n_points ) ||
+         BOUNDS( aIdx2, exc->zp1.n_points ) )
+    {
+      if ( exc->pedantic_hinting )
+        exc->error = FT_THROW( Invalid_Reference );
+      return FAILURE;
+    }
+
+    p1 = exc->zp1.cur + aIdx2;
+    p2 = exc->zp2.cur + aIdx1;
+
+    A = p1->x - p2->x;
+    B = p1->y - p2->y;
+
+    /* If p1 == p2, SPvTL and SFvTL behave the same as */
+    /* SPvTCA[X] and SFvTCA[X], respectively.          */
+    /*                                                 */
+    /* Confirmed by Greg Hitchcock.                    */
+
+    if ( A == 0 && B == 0 )
+    {
+      A      = 0x4000;
+      opcode = 0;
+    }
+
+    if ( ( opcode & 1 ) != 0 )
+    {
+      C =  B;   /* counter clockwise rotation */
+      B =  A;
+      A = -C;
+    }
+
+    Normalize( A, B, Vec );
+
+    return SUCCESS;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SVTCA[a]:     Set (F and P) Vectors to Coordinate Axis                */
+  /* Opcode range: 0x00-0x01                                               */
+  /* Stack:        -->                                                     */
+  /*                                                                       */
+  /* SPvTCA[a]:    Set PVector to Coordinate Axis                          */
+  /* Opcode range: 0x02-0x03                                               */
+  /* Stack:        -->                                                     */
+  /*                                                                       */
+  /* SFvTCA[a]:    Set FVector to Coordinate Axis                          */
+  /* Opcode range: 0x04-0x05                                               */
+  /* Stack:        -->                                                     */
+  /*                                                                       */
+  static void
+  Ins_SxyTCA( TT_ExecContext  exc )
+  {
+    FT_Short  AA, BB;
+
+    FT_Byte  opcode = exc->opcode;
+
+
+    AA = (FT_Short)( ( opcode & 1 ) << 14 );
+    BB = (FT_Short)( AA ^ 0x4000 );
+
+    if ( opcode < 4 )
+    {
+      exc->GS.projVector.x = AA;
+      exc->GS.projVector.y = BB;
+
+      exc->GS.dualVector.x = AA;
+      exc->GS.dualVector.y = BB;
+    }
+
+    if ( ( opcode & 2 ) == 0 )
+    {
+      exc->GS.freeVector.x = AA;
+      exc->GS.freeVector.y = BB;
+    }
+
+    Compute_Funcs( exc );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SPvTL[a]:     Set PVector To Line                                     */
+  /* Opcode range: 0x06-0x07                                               */
+  /* Stack:        uint32 uint32 -->                                       */
+  /*                                                                       */
+  static void
+  Ins_SPVTL( TT_ExecContext  exc,
+             FT_Long*        args )
+  {
+    if ( Ins_SxVTL( exc,
+                    (FT_UShort)args[1],
+                    (FT_UShort)args[0],
+                    &exc->GS.projVector ) == SUCCESS )
+    {
+      exc->GS.dualVector = exc->GS.projVector;
+      Compute_Funcs( exc );
+    }
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SFvTL[a]:     Set FVector To Line                                     */
+  /* Opcode range: 0x08-0x09                                               */
+  /* Stack:        uint32 uint32 -->                                       */
+  /*                                                                       */
+  static void
+  Ins_SFVTL( TT_ExecContext  exc,
+             FT_Long*        args )
+  {
+    if ( Ins_SxVTL( exc,
+                    (FT_UShort)args[1],
+                    (FT_UShort)args[0],
+                    &exc->GS.freeVector ) == SUCCESS )
+    {
+      Compute_Funcs( exc );
+    }
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SFvTPv[]:     Set FVector To PVector                                  */
+  /* Opcode range: 0x0E                                                    */
+  /* Stack:        -->                                                     */
+  /*                                                                       */
+  static void
+  Ins_SFVTPV( TT_ExecContext  exc )
+  {
+    exc->GS.freeVector = exc->GS.projVector;
+    Compute_Funcs( exc );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SPvFS[]:      Set PVector From Stack                                  */
+  /* Opcode range: 0x0A                                                    */
+  /* Stack:        f2.14 f2.14 -->                                         */
+  /*                                                                       */
+  static void
+  Ins_SPVFS( TT_ExecContext  exc,
+             FT_Long*        args )
+  {
+    FT_Short  S;
+    FT_Long   X, Y;
+
+
+    /* Only use low 16bits, then sign extend */
+    S = (FT_Short)args[1];
+    Y = (FT_Long)S;
+    S = (FT_Short)args[0];
+    X = (FT_Long)S;
+
+    Normalize( X, Y, &exc->GS.projVector );
+
+    exc->GS.dualVector = exc->GS.projVector;
+    Compute_Funcs( exc );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SFvFS[]:      Set FVector From Stack                                  */
+  /* Opcode range: 0x0B                                                    */
+  /* Stack:        f2.14 f2.14 -->                                         */
+  /*                                                                       */
+  static void
+  Ins_SFVFS( TT_ExecContext  exc,
+             FT_Long*        args )
+  {
+    FT_Short  S;
+    FT_Long   X, Y;
+
+
+    /* Only use low 16bits, then sign extend */
+    S = (FT_Short)args[1];
+    Y = (FT_Long)S;
+    S = (FT_Short)args[0];
+    X = S;
+
+    Normalize( X, Y, &exc->GS.freeVector );
+    Compute_Funcs( exc );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* GPv[]:        Get Projection Vector                                   */
+  /* Opcode range: 0x0C                                                    */
+  /* Stack:        ef2.14 --> ef2.14                                       */
+  /*                                                                       */
+  static void
+  Ins_GPV( TT_ExecContext  exc,
+           FT_Long*        args )
+  {
+    args[0] = exc->GS.projVector.x;
+    args[1] = exc->GS.projVector.y;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* GFv[]:        Get Freedom Vector                                      */
+  /* Opcode range: 0x0D                                                    */
+  /* Stack:        ef2.14 --> ef2.14                                       */
+  /*                                                                       */
+  static void
+  Ins_GFV( TT_ExecContext  exc,
+           FT_Long*        args )
+  {
+    args[0] = exc->GS.freeVector.x;
+    args[1] = exc->GS.freeVector.y;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SRP0[]:       Set Reference Point 0                                   */
+  /* Opcode range: 0x10                                                    */
+  /* Stack:        uint32 -->                                              */
+  /*                                                                       */
+  static void
+  Ins_SRP0( TT_ExecContext  exc,
+            FT_Long*        args )
+  {
+    exc->GS.rp0 = (FT_UShort)args[0];
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SRP1[]:       Set Reference Point 1                                   */
+  /* Opcode range: 0x11                                                    */
+  /* Stack:        uint32 -->                                              */
+  /*                                                                       */
+  static void
+  Ins_SRP1( TT_ExecContext  exc,
+            FT_Long*        args )
+  {
+    exc->GS.rp1 = (FT_UShort)args[0];
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SRP2[]:       Set Reference Point 2                                   */
+  /* Opcode range: 0x12                                                    */
+  /* Stack:        uint32 -->                                              */
+  /*                                                                       */
+  static void
+  Ins_SRP2( TT_ExecContext  exc,
+            FT_Long*        args )
+  {
+    exc->GS.rp2 = (FT_UShort)args[0];
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SMD[]:        Set Minimum Distance                                    */
+  /* Opcode range: 0x1A                                                    */
+  /* Stack:        f26.6 -->                                               */
+  /*                                                                       */
+  static void
+  Ins_SMD( TT_ExecContext  exc,
+           FT_Long*        args )
+  {
+    exc->GS.minimum_distance = args[0];
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SCVTCI[]:     Set Control Value Table Cut In                          */
+  /* Opcode range: 0x1D                                                    */
+  /* Stack:        f26.6 -->                                               */
+  /*                                                                       */
+  static void
+  Ins_SCVTCI( TT_ExecContext  exc,
+              FT_Long*        args )
+  {
+    exc->GS.control_value_cutin = (FT_F26Dot6)args[0];
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SSWCI[]:      Set Single Width Cut In                                 */
+  /* Opcode range: 0x1E                                                    */
+  /* Stack:        f26.6 -->                                               */
+  /*                                                                       */
+  static void
+  Ins_SSWCI( TT_ExecContext  exc,
+             FT_Long*        args )
+  {
+    exc->GS.single_width_cutin = (FT_F26Dot6)args[0];
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SSW[]:        Set Single Width                                        */
+  /* Opcode range: 0x1F                                                    */
+  /* Stack:        int32? -->                                              */
+  /*                                                                       */
+  static void
+  Ins_SSW( TT_ExecContext  exc,
+           FT_Long*        args )
+  {
+    exc->GS.single_width_value = FT_MulFix( args[0],
+                                            exc->tt_metrics.scale );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* FLIPON[]:     Set auto-FLIP to ON                                     */
+  /* Opcode range: 0x4D                                                    */
+  /* Stack:        -->                                                     */
+  /*                                                                       */
+  static void
+  Ins_FLIPON( TT_ExecContext  exc )
+  {
+    exc->GS.auto_flip = TRUE;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* FLIPOFF[]:    Set auto-FLIP to OFF                                    */
+  /* Opcode range: 0x4E                                                    */
+  /* Stack:        -->                                                     */
+  /*                                                                       */
+  static void
+  Ins_FLIPOFF( TT_ExecContext  exc )
+  {
+    exc->GS.auto_flip = FALSE;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SANGW[]:      Set ANGle Weight                                        */
+  /* Opcode range: 0x7E                                                    */
+  /* Stack:        uint32 -->                                              */
+  /*                                                                       */
+  static void
+  Ins_SANGW( void )
+  {
+    /* instruction not supported anymore */
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SDB[]:        Set Delta Base                                          */
+  /* Opcode range: 0x5E                                                    */
+  /* Stack:        uint32 -->                                              */
+  /*                                                                       */
+  static void
+  Ins_SDB( TT_ExecContext  exc,
+           FT_Long*        args )
+  {
+    exc->GS.delta_base = (FT_UShort)args[0];
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SDS[]:        Set Delta Shift                                         */
+  /* Opcode range: 0x5F                                                    */
+  /* Stack:        uint32 -->                                              */
+  /*                                                                       */
+  static void
+  Ins_SDS( TT_ExecContext  exc,
+           FT_Long*        args )
+  {
+    if ( (FT_ULong)args[0] > 6UL )
+      exc->error = FT_THROW( Bad_Argument );
+    else
+      exc->GS.delta_shift = (FT_UShort)args[0];
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* RTHG[]:       Round To Half Grid                                      */
+  /* Opcode range: 0x19                                                    */
+  /* Stack:        -->                                                     */
+  /*                                                                       */
+  static void
+  Ins_RTHG( TT_ExecContext  exc )
+  {
+    exc->GS.round_state = TT_Round_To_Half_Grid;
+    exc->func_round     = (TT_Round_Func)Round_To_Half_Grid;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* RTG[]:        Round To Grid                                           */
+  /* Opcode range: 0x18                                                    */
+  /* Stack:        -->                                                     */
+  /*                                                                       */
+  static void
+  Ins_RTG( TT_ExecContext  exc )
+  {
+    exc->GS.round_state = TT_Round_To_Grid;
+    exc->func_round     = (TT_Round_Func)Round_To_Grid;
+  }
+
+
+  /*************************************************************************/
+  /* RTDG[]:       Round To Double Grid                                    */
+  /* Opcode range: 0x3D                                                    */
+  /* Stack:        -->                                                     */
+  /*                                                                       */
+  static void
+  Ins_RTDG( TT_ExecContext  exc )
+  {
+    exc->GS.round_state = TT_Round_To_Double_Grid;
+    exc->func_round     = (TT_Round_Func)Round_To_Double_Grid;
+  }
+
+
+  /*************************************************************************/
+  /* RUTG[]:       Round Up To Grid                                        */
+  /* Opcode range: 0x7C                                                    */
+  /* Stack:        -->                                                     */
+  /*                                                                       */
+  static void
+  Ins_RUTG( TT_ExecContext  exc )
+  {
+    exc->GS.round_state = TT_Round_Up_To_Grid;
+    exc->func_round     = (TT_Round_Func)Round_Up_To_Grid;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* RDTG[]:       Round Down To Grid                                      */
+  /* Opcode range: 0x7D                                                    */
+  /* Stack:        -->                                                     */
+  /*                                                                       */
+  static void
+  Ins_RDTG( TT_ExecContext  exc )
+  {
+    exc->GS.round_state = TT_Round_Down_To_Grid;
+    exc->func_round     = (TT_Round_Func)Round_Down_To_Grid;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* ROFF[]:       Round OFF                                               */
+  /* Opcode range: 0x7A                                                    */
+  /* Stack:        -->                                                     */
+  /*                                                                       */
+  static void
+  Ins_ROFF( TT_ExecContext  exc )
+  {
+    exc->GS.round_state = TT_Round_Off;
+    exc->func_round     = (TT_Round_Func)Round_None;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SROUND[]:     Super ROUND                                             */
+  /* Opcode range: 0x76                                                    */
+  /* Stack:        Eint8 -->                                               */
+  /*                                                                       */
+  static void
+  Ins_SROUND( TT_ExecContext  exc,
+              FT_Long*        args )
+  {
+    SetSuperRound( exc, 0x4000, args[0] );
+
+    exc->GS.round_state = TT_Round_Super;
+    exc->func_round     = (TT_Round_Func)Round_Super;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* S45ROUND[]:   Super ROUND 45 degrees                                  */
+  /* Opcode range: 0x77                                                    */
+  /* Stack:        uint32 -->                                              */
+  /*                                                                       */
+  static void
+  Ins_S45ROUND( TT_ExecContext  exc,
+                FT_Long*        args )
+  {
+    SetSuperRound( exc, 0x2D41, args[0] );
+
+    exc->GS.round_state = TT_Round_Super_45;
+    exc->func_round     = (TT_Round_Func)Round_Super_45;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* GC[a]:        Get Coordinate projected onto                           */
+  /* Opcode range: 0x46-0x47                                               */
+  /* Stack:        uint32 --> f26.6                                        */
+  /*                                                                       */
+  /* XXX: UNDOCUMENTED: Measures from the original glyph must be taken     */
+  /*      along the dual projection vector!                                */
+  /*                                                                       */
+  static void
+  Ins_GC( TT_ExecContext  exc,
+          FT_Long*        args )
+  {
+    FT_ULong    L;
+    FT_F26Dot6  R;
+
+
+    L = (FT_ULong)args[0];
+
+    if ( BOUNDSL( L, exc->zp2.n_points ) )
+    {
+      if ( exc->pedantic_hinting )
+        exc->error = FT_THROW( Invalid_Reference );
+      R = 0;
+    }
+    else
+    {
+      if ( exc->opcode & 1 )
+        R = FAST_DUALPROJ( &exc->zp2.org[L] );
+      else
+        R = FAST_PROJECT( &exc->zp2.cur[L] );
+    }
+
+    args[0] = R;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SCFS[]:       Set Coordinate From Stack                               */
+  /* Opcode range: 0x48                                                    */
+  /* Stack:        f26.6 uint32 -->                                        */
+  /*                                                                       */
+  /* Formula:                                                              */
+  /*                                                                       */
+  /*   OA := OA + ( value - OA.p )/( f.p ) * f                             */
+  /*                                                                       */
+  static void
+  Ins_SCFS( TT_ExecContext  exc,
+            FT_Long*        args )
+  {
+    FT_Long    K;
+    FT_UShort  L;
+
+
+    L = (FT_UShort)args[0];
+
+    if ( BOUNDS( L, exc->zp2.n_points ) )
+    {
+      if ( exc->pedantic_hinting )
+        exc->error = FT_THROW( Invalid_Reference );
+      return;
+    }
+
+    K = FAST_PROJECT( &exc->zp2.cur[L] );
+
+    exc->func_move( exc, &exc->zp2, L, args[1] - K );
+
+    /* UNDOCUMENTED!  The MS rasterizer does that with */
+    /* twilight points (confirmed by Greg Hitchcock)   */
+    if ( exc->GS.gep2 == 0 )
+      exc->zp2.org[L] = exc->zp2.cur[L];
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* MD[a]:        Measure Distance                                        */
+  /* Opcode range: 0x49-0x4A                                               */
+  /* Stack:        uint32 uint32 --> f26.6                                 */
+  /*                                                                       */
+  /* XXX: UNDOCUMENTED: Measure taken in the original glyph must be along  */
+  /*                    the dual projection vector.                        */
+  /*                                                                       */
+  /* XXX: UNDOCUMENTED: Flag attributes are inverted!                      */
+  /*                      0 => measure distance in original outline        */
+  /*                      1 => measure distance in grid-fitted outline     */
+  /*                                                                       */
+  /* XXX: UNDOCUMENTED: `zp0 - zp1', and not `zp2 - zp1!                   */
+  /*                                                                       */
+  static void
+  Ins_MD( TT_ExecContext  exc,
+          FT_Long*        args )
+  {
+    FT_UShort   K, L;
+    FT_F26Dot6  D;
+
+
+    K = (FT_UShort)args[1];
+    L = (FT_UShort)args[0];
+
+    if ( BOUNDS( L, exc->zp0.n_points ) ||
+         BOUNDS( K, exc->zp1.n_points ) )
+    {
+      if ( exc->pedantic_hinting )
+        exc->error = FT_THROW( Invalid_Reference );
+      D = 0;
+    }
+    else
+    {
+      if ( exc->opcode & 1 )
+        D = PROJECT( exc->zp0.cur + L, exc->zp1.cur + K );
+      else
+      {
+        /* XXX: UNDOCUMENTED: twilight zone special case */
+
+        if ( exc->GS.gep0 == 0 || exc->GS.gep1 == 0 )
+        {
+          FT_Vector*  vec1 = exc->zp0.org + L;
+          FT_Vector*  vec2 = exc->zp1.org + K;
+
+
+          D = DUALPROJ( vec1, vec2 );
+        }
+        else
+        {
+          FT_Vector*  vec1 = exc->zp0.orus + L;
+          FT_Vector*  vec2 = exc->zp1.orus + K;
+
+
+          if ( exc->metrics.x_scale == exc->metrics.y_scale )
+          {
+            /* this should be faster */
+            D = DUALPROJ( vec1, vec2 );
+            D = FT_MulFix( D, exc->metrics.x_scale );
+          }
+          else
+          {
+            FT_Vector  vec;
+
+
+            vec.x = FT_MulFix( vec1->x - vec2->x, exc->metrics.x_scale );
+            vec.y = FT_MulFix( vec1->y - vec2->y, exc->metrics.y_scale );
+
+            D = FAST_DUALPROJ( &vec );
+          }
+        }
+      }
+    }
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+    /* Disable Type 2 Vacuform Rounds - e.g. Arial Narrow */
+    if ( SUBPIXEL_HINTING_INFINALITY &&
+         exc->ignore_x_mode          &&
+         FT_ABS( D ) == 64           )
+      D += 1;
+#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
+
+    args[0] = D;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SDPvTL[a]:    Set Dual PVector to Line                                */
+  /* Opcode range: 0x86-0x87                                               */
+  /* Stack:        uint32 uint32 -->                                       */
+  /*                                                                       */
+  static void
+  Ins_SDPVTL( TT_ExecContext  exc,
+              FT_Long*        args )
+  {
+    FT_Long    A, B, C;
+    FT_UShort  p1, p2;            /* was FT_Int in pas type ERROR */
+
+    FT_Byte  opcode = exc->opcode;
+
+
+    p1 = (FT_UShort)args[1];
+    p2 = (FT_UShort)args[0];
+
+    if ( BOUNDS( p2, exc->zp1.n_points ) ||
+         BOUNDS( p1, exc->zp2.n_points ) )
+    {
+      if ( exc->pedantic_hinting )
+        exc->error = FT_THROW( Invalid_Reference );
+      return;
+    }
+
+    {
+      FT_Vector* v1 = exc->zp1.org + p2;
+      FT_Vector* v2 = exc->zp2.org + p1;
+
+
+      A = v1->x - v2->x;
+      B = v1->y - v2->y;
+
+      /* If v1 == v2, SDPvTL behaves the same as */
+      /* SVTCA[X], respectively.                 */
+      /*                                         */
+      /* Confirmed by Greg Hitchcock.            */
+
+      if ( A == 0 && B == 0 )
+      {
+        A      = 0x4000;
+        opcode = 0;
+      }
+    }
+
+    if ( ( opcode & 1 ) != 0 )
+    {
+      C =  B;   /* counter clockwise rotation */
+      B =  A;
+      A = -C;
+    }
+
+    Normalize( A, B, &exc->GS.dualVector );
+
+    {
+      FT_Vector*  v1 = exc->zp1.cur + p2;
+      FT_Vector*  v2 = exc->zp2.cur + p1;
+
+
+      A = v1->x - v2->x;
+      B = v1->y - v2->y;
+
+      if ( A == 0 && B == 0 )
+      {
+        A      = 0x4000;
+        opcode = 0;
+      }
+    }
+
+    if ( ( opcode & 1 ) != 0 )
+    {
+      C =  B;   /* counter clockwise rotation */
+      B =  A;
+      A = -C;
+    }
+
+    Normalize( A, B, &exc->GS.projVector );
+    Compute_Funcs( exc );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SZP0[]:       Set Zone Pointer 0                                      */
+  /* Opcode range: 0x13                                                    */
+  /* Stack:        uint32 -->                                              */
+  /*                                                                       */
+  static void
+  Ins_SZP0( TT_ExecContext  exc,
+            FT_Long*        args )
+  {
+    switch ( (FT_Int)args[0] )
+    {
+    case 0:
+      exc->zp0 = exc->twilight;
+      break;
+
+    case 1:
+      exc->zp0 = exc->pts;
+      break;
+
+    default:
+      if ( exc->pedantic_hinting )
+        exc->error = FT_THROW( Invalid_Reference );
+      return;
+    }
+
+    exc->GS.gep0 = (FT_UShort)args[0];
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SZP1[]:       Set Zone Pointer 1                                      */
+  /* Opcode range: 0x14                                                    */
+  /* Stack:        uint32 -->                                              */
+  /*                                                                       */
+  static void
+  Ins_SZP1( TT_ExecContext  exc,
+            FT_Long*        args )
+  {
+    switch ( (FT_Int)args[0] )
+    {
+    case 0:
+      exc->zp1 = exc->twilight;
+      break;
+
+    case 1:
+      exc->zp1 = exc->pts;
+      break;
+
+    default:
+      if ( exc->pedantic_hinting )
+        exc->error = FT_THROW( Invalid_Reference );
+      return;
+    }
+
+    exc->GS.gep1 = (FT_UShort)args[0];
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SZP2[]:       Set Zone Pointer 2                                      */
+  /* Opcode range: 0x15                                                    */
+  /* Stack:        uint32 -->                                              */
+  /*                                                                       */
+  static void
+  Ins_SZP2( TT_ExecContext  exc,
+            FT_Long*        args )
+  {
+    switch ( (FT_Int)args[0] )
+    {
+    case 0:
+      exc->zp2 = exc->twilight;
+      break;
+
+    case 1:
+      exc->zp2 = exc->pts;
+      break;
+
+    default:
+      if ( exc->pedantic_hinting )
+        exc->error = FT_THROW( Invalid_Reference );
+      return;
+    }
+
+    exc->GS.gep2 = (FT_UShort)args[0];
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SZPS[]:       Set Zone PointerS                                       */
+  /* Opcode range: 0x16                                                    */
+  /* Stack:        uint32 -->                                              */
+  /*                                                                       */
+  static void
+  Ins_SZPS( TT_ExecContext  exc,
+            FT_Long*        args )
+  {
+    switch ( (FT_Int)args[0] )
+    {
+    case 0:
+      exc->zp0 = exc->twilight;
+      break;
+
+    case 1:
+      exc->zp0 = exc->pts;
+      break;
+
+    default:
+      if ( exc->pedantic_hinting )
+        exc->error = FT_THROW( Invalid_Reference );
+      return;
+    }
+
+    exc->zp1 = exc->zp0;
+    exc->zp2 = exc->zp0;
+
+    exc->GS.gep0 = (FT_UShort)args[0];
+    exc->GS.gep1 = (FT_UShort)args[0];
+    exc->GS.gep2 = (FT_UShort)args[0];
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* INSTCTRL[]:   INSTruction ConTRoL                                     */
+  /* Opcode range: 0x8E                                                    */
+  /* Stack:        int32 int32 -->                                         */
+  /*                                                                       */
+  static void
+  Ins_INSTCTRL( TT_ExecContext  exc,
+                FT_Long*        args )
+  {
+    FT_ULong  K, L, Kf;
+
+
+    K = (FT_ULong)args[1];
+    L = (FT_ULong)args[0];
+
+    /* selector values cannot be `OR'ed;                 */
+    /* they are indices starting with index 1, not flags */
+    if ( K < 1 || K > 3 )
+    {
+      if ( exc->pedantic_hinting )
+        exc->error = FT_THROW( Invalid_Reference );
+      return;
+    }
+
+    /* convert index to flag value */
+    Kf = 1 << ( K - 1 );
+
+    if ( L != 0 )
+    {
+      /* arguments to selectors look like flag values */
+      if ( L != Kf )
+      {
+        if ( exc->pedantic_hinting )
+          exc->error = FT_THROW( Invalid_Reference );
+        return;
+      }
+    }
+
+    exc->GS.instruct_control &= ~(FT_Byte)Kf;
+    exc->GS.instruct_control |= (FT_Byte)L;
+
+    if ( K == 3 )
+    {
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+      /* INSTCTRL modifying flag 3 also has an effect */
+      /* outside of the CVT program                   */
+      if ( SUBPIXEL_HINTING_INFINALITY )
+        exc->ignore_x_mode = FT_BOOL( L == 4 );
+#endif
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
+      /* Native ClearType fonts sign a waiver that turns off all backwards */
+      /* compatibility hacks and lets them program points to the grid like */
+      /* it's 1996.  They might sign a waiver for just one glyph, though.  */
+      if ( SUBPIXEL_HINTING_MINIMAL )
+        exc->backwards_compatibility = !FT_BOOL( L == 4 );
+#endif
+    }
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SCANCTRL[]:   SCAN ConTRoL                                            */
+  /* Opcode range: 0x85                                                    */
+  /* Stack:        uint32? -->                                             */
+  /*                                                                       */
+  static void
+  Ins_SCANCTRL( TT_ExecContext  exc,
+                FT_Long*        args )
+  {
+    FT_Int  A;
+
+
+    /* Get Threshold */
+    A = (FT_Int)( args[0] & 0xFF );
+
+    if ( A == 0xFF )
+    {
+      exc->GS.scan_control = TRUE;
+      return;
+    }
+    else if ( A == 0 )
+    {
+      exc->GS.scan_control = FALSE;
+      return;
+    }
+
+    if ( ( args[0] & 0x100 ) != 0 && exc->tt_metrics.ppem <= A )
+      exc->GS.scan_control = TRUE;
+
+    if ( ( args[0] & 0x200 ) != 0 && exc->tt_metrics.rotated )
+      exc->GS.scan_control = TRUE;
+
+    if ( ( args[0] & 0x400 ) != 0 && exc->tt_metrics.stretched )
+      exc->GS.scan_control = TRUE;
+
+    if ( ( args[0] & 0x800 ) != 0 && exc->tt_metrics.ppem > A )
+      exc->GS.scan_control = FALSE;
+
+    if ( ( args[0] & 0x1000 ) != 0 && exc->tt_metrics.rotated )
+      exc->GS.scan_control = FALSE;
+
+    if ( ( args[0] & 0x2000 ) != 0 && exc->tt_metrics.stretched )
+      exc->GS.scan_control = FALSE;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SCANTYPE[]:   SCAN TYPE                                               */
+  /* Opcode range: 0x8D                                                    */
+  /* Stack:        uint32? -->                                             */
+  /*                                                                       */
+  static void
+  Ins_SCANTYPE( TT_ExecContext  exc,
+                FT_Long*        args )
+  {
+    if ( args[0] >= 0 )
+      exc->GS.scan_type = (FT_Int)args[0];
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* MANAGING OUTLINES                                                     */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* FLIPPT[]:     FLIP PoinT                                              */
+  /* Opcode range: 0x80                                                    */
+  /* Stack:        uint32... -->                                           */
+  /*                                                                       */
+  static void
+  Ins_FLIPPT( TT_ExecContext  exc )
+  {
+    FT_UShort  point;
+
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
+    /* See `ttinterp.h' for details on backwards compatibility mode. */
+    if ( SUBPIXEL_HINTING_MINIMAL     &&
+         exc->backwards_compatibility &&
+         exc->iupx_called             &&
+         exc->iupy_called             )
+      goto Fail;
+#endif
+
+    if ( exc->top < exc->GS.loop )
+    {
+      if ( exc->pedantic_hinting )
+        exc->error = FT_THROW( Too_Few_Arguments );
+      goto Fail;
+    }
+
+    while ( exc->GS.loop > 0 )
+    {
+      exc->args--;
+
+      point = (FT_UShort)exc->stack[exc->args];
+
+      if ( BOUNDS( point, exc->pts.n_points ) )
+      {
+        if ( exc->pedantic_hinting )
+        {
+          exc->error = FT_THROW( Invalid_Reference );
+          return;
+        }
+      }
+      else
+        exc->pts.tags[point] ^= FT_CURVE_TAG_ON;
+
+      exc->GS.loop--;
+    }
+
+  Fail:
+    exc->GS.loop = 1;
+    exc->new_top = exc->args;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* FLIPRGON[]:   FLIP RanGe ON                                           */
+  /* Opcode range: 0x81                                                    */
+  /* Stack:        uint32 uint32 -->                                       */
+  /*                                                                       */
+  static void
+  Ins_FLIPRGON( TT_ExecContext  exc,
+                FT_Long*        args )
+  {
+    FT_UShort  I, K, L;
+
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
+    /* See `ttinterp.h' for details on backwards compatibility mode. */
+    if ( SUBPIXEL_HINTING_MINIMAL     &&
+         exc->backwards_compatibility &&
+         exc->iupx_called             &&
+         exc->iupy_called             )
+      return;
+#endif
+
+    K = (FT_UShort)args[1];
+    L = (FT_UShort)args[0];
+
+    if ( BOUNDS( K, exc->pts.n_points ) ||
+         BOUNDS( L, exc->pts.n_points ) )
+    {
+      if ( exc->pedantic_hinting )
+        exc->error = FT_THROW( Invalid_Reference );
+      return;
+    }
+
+    for ( I = L; I <= K; I++ )
+      exc->pts.tags[I] |= FT_CURVE_TAG_ON;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* FLIPRGOFF:    FLIP RanGe OFF                                          */
+  /* Opcode range: 0x82                                                    */
+  /* Stack:        uint32 uint32 -->                                       */
+  /*                                                                       */
+  static void
+  Ins_FLIPRGOFF( TT_ExecContext  exc,
+                 FT_Long*        args )
+  {
+    FT_UShort  I, K, L;
+
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
+    /* See `ttinterp.h' for details on backwards compatibility mode. */
+    if ( SUBPIXEL_HINTING_MINIMAL     &&
+         exc->backwards_compatibility &&
+         exc->iupx_called             &&
+         exc->iupy_called             )
+      return;
+#endif
+
+    K = (FT_UShort)args[1];
+    L = (FT_UShort)args[0];
+
+    if ( BOUNDS( K, exc->pts.n_points ) ||
+         BOUNDS( L, exc->pts.n_points ) )
+    {
+      if ( exc->pedantic_hinting )
+        exc->error = FT_THROW( Invalid_Reference );
+      return;
+    }
+
+    for ( I = L; I <= K; I++ )
+      exc->pts.tags[I] &= ~FT_CURVE_TAG_ON;
+  }
+
+
+  static FT_Bool
+  Compute_Point_Displacement( TT_ExecContext  exc,
+                              FT_F26Dot6*     x,
+                              FT_F26Dot6*     y,
+                              TT_GlyphZone    zone,
+                              FT_UShort*      refp )
+  {
+    TT_GlyphZoneRec  zp;
+    FT_UShort        p;
+    FT_F26Dot6       d;
+
+
+    if ( exc->opcode & 1 )
+    {
+      zp = exc->zp0;
+      p  = exc->GS.rp1;
+    }
+    else
+    {
+      zp = exc->zp1;
+      p  = exc->GS.rp2;
+    }
+
+    if ( BOUNDS( p, zp.n_points ) )
+    {
+      if ( exc->pedantic_hinting )
+        exc->error = FT_THROW( Invalid_Reference );
+      *refp = 0;
+      return FAILURE;
+    }
+
+    *zone = zp;
+    *refp = p;
+
+    d = PROJECT( zp.cur + p, zp.org + p );
+
+    *x = FT_MulDiv( d, (FT_Long)exc->GS.freeVector.x, exc->F_dot_P );
+    *y = FT_MulDiv( d, (FT_Long)exc->GS.freeVector.y, exc->F_dot_P );
+
+    return SUCCESS;
+  }
+
+
+  /* See `ttinterp.h' for details on backwards compatibility mode. */
+  static void
+  Move_Zp2_Point( TT_ExecContext  exc,
+                  FT_UShort       point,
+                  FT_F26Dot6      dx,
+                  FT_F26Dot6      dy,
+                  FT_Bool         touch )
+  {
+    if ( exc->GS.freeVector.x != 0 )
+    {
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
+      if ( !( SUBPIXEL_HINTING_MINIMAL     &&
+              exc->backwards_compatibility ) )
+#endif
+        exc->zp2.cur[point].x += dx;
+
+      if ( touch )
+        exc->zp2.tags[point] |= FT_CURVE_TAG_TOUCH_X;
+    }
+
+    if ( exc->GS.freeVector.y != 0 )
+    {
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
+      if ( !( SUBPIXEL_HINTING_MINIMAL     &&
+              exc->backwards_compatibility &&
+              exc->iupx_called             &&
+              exc->iupy_called             ) )
+#endif
+        exc->zp2.cur[point].y += dy;
+
+      if ( touch )
+        exc->zp2.tags[point] |= FT_CURVE_TAG_TOUCH_Y;
+    }
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SHP[a]:       SHift Point by the last point                           */
+  /* Opcode range: 0x32-0x33                                               */
+  /* Stack:        uint32... -->                                           */
+  /*                                                                       */
+  static void
+  Ins_SHP( TT_ExecContext  exc )
+  {
+    TT_GlyphZoneRec  zp;
+    FT_UShort        refp;
+
+    FT_F26Dot6       dx, dy;
+    FT_UShort        point;
+
+
+    if ( exc->top < exc->GS.loop )
+    {
+      if ( exc->pedantic_hinting )
+        exc->error = FT_THROW( Invalid_Reference );
+      goto Fail;
+    }
+
+    if ( Compute_Point_Displacement( exc, &dx, &dy, &zp, &refp ) )
+      return;
+
+    while ( exc->GS.loop > 0 )
+    {
+      exc->args--;
+      point = (FT_UShort)exc->stack[exc->args];
+
+      if ( BOUNDS( point, exc->zp2.n_points ) )
+      {
+        if ( exc->pedantic_hinting )
+        {
+          exc->error = FT_THROW( Invalid_Reference );
+          return;
+        }
+      }
+      else
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+      /* doesn't follow Cleartype spec but produces better result */
+      if ( SUBPIXEL_HINTING_INFINALITY && exc->ignore_x_mode )
+        Move_Zp2_Point( exc, point, 0, dy, TRUE );
+      else
+#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
+        Move_Zp2_Point( exc, point, dx, dy, TRUE );
+
+      exc->GS.loop--;
+    }
+
+  Fail:
+    exc->GS.loop = 1;
+    exc->new_top = exc->args;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SHC[a]:       SHift Contour                                           */
+  /* Opcode range: 0x34-35                                                 */
+  /* Stack:        uint32 -->                                              */
+  /*                                                                       */
+  /* UNDOCUMENTED: According to Greg Hitchcock, there is one (virtual)     */
+  /*               contour in the twilight zone, namely contour number     */
+  /*               zero which includes all points of it.                   */
+  /*                                                                       */
+  static void
+  Ins_SHC( TT_ExecContext  exc,
+           FT_Long*        args )
+  {
+    TT_GlyphZoneRec  zp;
+    FT_UShort        refp;
+    FT_F26Dot6       dx, dy;
+
+    FT_Short         contour, bounds;
+    FT_UShort        start, limit, i;
+
+
+    contour = (FT_Short)args[0];
+    bounds  = ( exc->GS.gep2 == 0 ) ? 1 : exc->zp2.n_contours;
+
+    if ( BOUNDS( contour, bounds ) )
+    {
+      if ( exc->pedantic_hinting )
+        exc->error = FT_THROW( Invalid_Reference );
+      return;
+    }
+
+    if ( Compute_Point_Displacement( exc, &dx, &dy, &zp, &refp ) )
+      return;
+
+    if ( contour == 0 )
+      start = 0;
+    else
+      start = (FT_UShort)( exc->zp2.contours[contour - 1] + 1 -
+                           exc->zp2.first_point );
+
+    /* we use the number of points if in the twilight zone */
+    if ( exc->GS.gep2 == 0 )
+      limit = exc->zp2.n_points;
+    else
+      limit = (FT_UShort)( exc->zp2.contours[contour] -
+                           exc->zp2.first_point + 1 );
+
+    for ( i = start; i < limit; i++ )
+    {
+      if ( zp.cur != exc->zp2.cur || refp != i )
+        Move_Zp2_Point( exc, i, dx, dy, TRUE );
+    }
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SHZ[a]:       SHift Zone                                              */
+  /* Opcode range: 0x36-37                                                 */
+  /* Stack:        uint32 -->                                              */
+  /*                                                                       */
+  static void
+  Ins_SHZ( TT_ExecContext  exc,
+           FT_Long*        args )
+  {
+    TT_GlyphZoneRec  zp;
+    FT_UShort        refp;
+    FT_F26Dot6       dx,
+                     dy;
+
+    FT_UShort        limit, i;
+
+
+    if ( BOUNDS( args[0], 2 ) )
+    {
+      if ( exc->pedantic_hinting )
+        exc->error = FT_THROW( Invalid_Reference );
+      return;
+    }
+
+    if ( Compute_Point_Displacement( exc, &dx, &dy, &zp, &refp ) )
+      return;
+
+    /* XXX: UNDOCUMENTED! SHZ doesn't move the phantom points.     */
+    /*      Twilight zone has no real contours, so use `n_points'. */
+    /*      Normal zone's `n_points' includes phantoms, so must    */
+    /*      use end of last contour.                               */
+    if ( exc->GS.gep2 == 0 )
+      limit = (FT_UShort)exc->zp2.n_points;
+    else if ( exc->GS.gep2 == 1 && exc->zp2.n_contours > 0 )
+      limit = (FT_UShort)( exc->zp2.contours[exc->zp2.n_contours - 1] + 1 );
+    else
+      limit = 0;
+
+    /* XXX: UNDOCUMENTED! SHZ doesn't touch the points */
+    for ( i = 0; i < limit; i++ )
+    {
+      if ( zp.cur != exc->zp2.cur || refp != i )
+        Move_Zp2_Point( exc, i, dx, dy, FALSE );
+    }
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* SHPIX[]:      SHift points by a PIXel amount                          */
+  /* Opcode range: 0x38                                                    */
+  /* Stack:        f26.6 uint32... -->                                     */
+  /*                                                                       */
+  static void
+  Ins_SHPIX( TT_ExecContext  exc,
+             FT_Long*        args )
+  {
+    FT_F26Dot6  dx, dy;
+    FT_UShort   point;
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+    FT_Int      B1, B2;
+#endif
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
+    FT_Bool     in_twilight = exc->GS.gep0 == 0 || \
+                              exc->GS.gep1 == 0 || \
+                              exc->GS.gep2 == 0;
+#endif
+
+
+
+    if ( exc->top < exc->GS.loop + 1 )
+    {
+      if ( exc->pedantic_hinting )
+        exc->error = FT_THROW( Invalid_Reference );
+      goto Fail;
+    }
+
+    dx = TT_MulFix14( args[0], exc->GS.freeVector.x );
+    dy = TT_MulFix14( args[0], exc->GS.freeVector.y );
+
+    while ( exc->GS.loop > 0 )
+    {
+      exc->args--;
+
+      point = (FT_UShort)exc->stack[exc->args];
+
+      if ( BOUNDS( point, exc->zp2.n_points ) )
+      {
+        if ( exc->pedantic_hinting )
+        {
+          exc->error = FT_THROW( Invalid_Reference );
+          return;
+        }
+      }
+      else
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+      if ( SUBPIXEL_HINTING_INFINALITY )
+      {
+        /*  If not using ignore_x_mode rendering, allow ZP2 move.        */
+        /*  If inline deltas aren't allowed, skip ZP2 move.              */
+        /*  If using ignore_x_mode rendering, allow ZP2 point move if:   */
+        /*   - freedom vector is y and sph_compatibility_mode is off     */
+        /*   - the glyph is composite and the move is in the Y direction */
+        /*   - the glyph is specifically set to allow SHPIX moves        */
+        /*   - the move is on a previously Y-touched point               */
+
+        if ( exc->ignore_x_mode )
+        {
+          /* save point for later comparison */
+          if ( exc->GS.freeVector.y != 0 )
+            B1 = exc->zp2.cur[point].y;
+          else
+            B1 = exc->zp2.cur[point].x;
+
+          if ( !exc->face->sph_compatibility_mode &&
+               exc->GS.freeVector.y != 0          )
+          {
+            Move_Zp2_Point( exc, point, dx, dy, TRUE );
+
+            /* save new point */
+            if ( exc->GS.freeVector.y != 0 )
+            {
+              B2 = exc->zp2.cur[point].y;
+
+              /* reverse any disallowed moves */
+              if ( ( exc->sph_tweak_flags & SPH_TWEAK_SKIP_NONPIXEL_Y_MOVES ) &&
+                   ( B1 & 63 ) != 0                                           &&
+                   ( B2 & 63 ) != 0                                           &&
+                   B1 != B2                                                   )
+                Move_Zp2_Point( exc, point, -dx, -dy, TRUE );
+            }
+          }
+          else if ( exc->face->sph_compatibility_mode )
+          {
+            if ( exc->sph_tweak_flags & SPH_TWEAK_ROUND_NONPIXEL_Y_MOVES )
+            {
+              dx = FT_PIX_ROUND( B1 + dx ) - B1;
+              dy = FT_PIX_ROUND( B1 + dy ) - B1;
+            }
+
+            /* skip post-iup deltas */
+            if ( exc->iup_called                                          &&
+                 ( ( exc->sph_in_func_flags & SPH_FDEF_INLINE_DELTA_1 ) ||
+                   ( exc->sph_in_func_flags & SPH_FDEF_INLINE_DELTA_2 ) ) )
+              goto Skip;
+
+            if ( !( exc->sph_tweak_flags & SPH_TWEAK_ALWAYS_SKIP_DELTAP ) &&
+                  ( ( exc->is_composite && exc->GS.freeVector.y != 0 ) ||
+                    ( exc->zp2.tags[point] & FT_CURVE_TAG_TOUCH_Y )    ||
+                    ( exc->sph_tweak_flags & SPH_TWEAK_DO_SHPIX )      )  )
+              Move_Zp2_Point( exc, point, 0, dy, TRUE );
+
+            /* save new point */
+            if ( exc->GS.freeVector.y != 0 )
+            {
+              B2 = exc->zp2.cur[point].y;
+
+              /* reverse any disallowed moves */
+              if ( ( B1 & 63 ) == 0 &&
+                   ( B2 & 63 ) != 0 &&
+                   B1 != B2         )
+                Move_Zp2_Point( exc, point, 0, -dy, TRUE );
+            }
+          }
+          else if ( exc->sph_in_func_flags & SPH_FDEF_TYPEMAN_DIAGENDCTRL )
+            Move_Zp2_Point( exc, point, dx, dy, TRUE );
+        }
+        else
+          Move_Zp2_Point( exc, point, dx, dy, TRUE );
+      }
+      else
+#endif
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
+      if ( SUBPIXEL_HINTING_MINIMAL     &&
+           exc->backwards_compatibility )
+      {
+        /* Special case: allow SHPIX to move points in the twilight zone.  */
+        /* Otherwise, treat SHPIX the same as DELTAP.  Unbreaks various    */
+        /* fonts such as older versions of Rokkitt and DTL Argo T Light    */
+        /* that would glitch severly after calling ALIGNRP after a blocked */
+        /* SHPIX.                                                          */
+        if ( in_twilight                                                ||
+             ( !( exc->iupx_called && exc->iupy_called )              &&
+               ( ( exc->is_composite && exc->GS.freeVector.y != 0 ) ||
+                 ( exc->zp2.tags[point] & FT_CURVE_TAG_TOUCH_Y )    ) ) )
+          Move_Zp2_Point( exc, point, 0, dy, TRUE );
+      }
+      else
+#endif
+        Move_Zp2_Point( exc, point, dx, dy, TRUE );
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+    Skip:
+#endif
+      exc->GS.loop--;
+    }
+
+  Fail:
+    exc->GS.loop = 1;
+    exc->new_top = exc->args;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* MSIRP[a]:     Move Stack Indirect Relative Position                   */
+  /* Opcode range: 0x3A-0x3B                                               */
+  /* Stack:        f26.6 uint32 -->                                        */
+  /*                                                                       */
+  static void
+  Ins_MSIRP( TT_ExecContext  exc,
+             FT_Long*        args )
+  {
+    FT_UShort   point = 0;
+    FT_F26Dot6  distance;
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+    FT_F26Dot6  control_value_cutin = 0;
+
+
+    if ( SUBPIXEL_HINTING_INFINALITY )
+    {
+      control_value_cutin = exc->GS.control_value_cutin;
+
+      if ( exc->ignore_x_mode                                 &&
+           exc->GS.freeVector.x != 0                          &&
+           !( exc->sph_tweak_flags & SPH_TWEAK_NORMAL_ROUND ) )
+        control_value_cutin = 0;
+    }
+#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
+
+    point = (FT_UShort)args[0];
+
+    if ( BOUNDS( point,       exc->zp1.n_points ) ||
+         BOUNDS( exc->GS.rp0, exc->zp0.n_points ) )
+    {
+      if ( exc->pedantic_hinting )
+        exc->error = FT_THROW( Invalid_Reference );
+      return;
+    }
+
+    /* UNDOCUMENTED!  The MS rasterizer does that with */
+    /* twilight points (confirmed by Greg Hitchcock)   */
+    if ( exc->GS.gep1 == 0 )
+    {
+      exc->zp1.org[point] = exc->zp0.org[exc->GS.rp0];
+      exc->func_move_orig( exc, &exc->zp1, point, args[1] );
+      exc->zp1.cur[point] = exc->zp1.org[point];
+    }
+
+    distance = PROJECT( exc->zp1.cur + point, exc->zp0.cur + exc->GS.rp0 );
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+    /* subpixel hinting - make MSIRP respect CVT cut-in; */
+    if ( SUBPIXEL_HINTING_INFINALITY                         &&
+         exc->ignore_x_mode                                  &&
+         exc->GS.freeVector.x != 0                           &&
+         FT_ABS( distance - args[1] ) >= control_value_cutin )
+      distance = args[1];
+#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
+
+    exc->func_move( exc, &exc->zp1, point, args[1] - distance );
+
+    exc->GS.rp1 = exc->GS.rp0;
+    exc->GS.rp2 = point;
+
+    if ( ( exc->opcode & 1 ) != 0 )
+      exc->GS.rp0 = point;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* MDAP[a]:      Move Direct Absolute Point                              */
+  /* Opcode range: 0x2E-0x2F                                               */
+  /* Stack:        uint32 -->                                              */
+  /*                                                                       */
+  static void
+  Ins_MDAP( TT_ExecContext  exc,
+            FT_Long*        args )
+  {
+    FT_UShort   point;
+    FT_F26Dot6  cur_dist;
+    FT_F26Dot6  distance;
+
+
+    point = (FT_UShort)args[0];
+
+    if ( BOUNDS( point, exc->zp0.n_points ) )
+    {
+      if ( exc->pedantic_hinting )
+        exc->error = FT_THROW( Invalid_Reference );
+      return;
+    }
+
+    if ( ( exc->opcode & 1 ) != 0 )
+    {
+      cur_dist = FAST_PROJECT( &exc->zp0.cur[point] );
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+      if ( SUBPIXEL_HINTING_INFINALITY &&
+           exc->ignore_x_mode          &&
+           exc->GS.freeVector.x != 0   )
+        distance = Round_None(
+                     exc,
+                     cur_dist,
+                     exc->tt_metrics.compensations[0] ) - cur_dist;
+      else
+#endif
+        distance = exc->func_round(
+                     exc,
+                     cur_dist,
+                     exc->tt_metrics.compensations[0] ) - cur_dist;
+    }
+    else
+      distance = 0;
+
+    exc->func_move( exc, &exc->zp0, point, distance );
+
+    exc->GS.rp0 = point;
+    exc->GS.rp1 = point;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* MIAP[a]:      Move Indirect Absolute Point                            */
+  /* Opcode range: 0x3E-0x3F                                               */
+  /* Stack:        uint32 uint32 -->                                       */
+  /*                                                                       */
+  static void
+  Ins_MIAP( TT_ExecContext  exc,
+            FT_Long*        args )
+  {
+    FT_ULong    cvtEntry;
+    FT_UShort   point;
+    FT_F26Dot6  distance;
+    FT_F26Dot6  org_dist;
+    FT_F26Dot6  control_value_cutin;
+
+
+    control_value_cutin = exc->GS.control_value_cutin;
+    cvtEntry            = (FT_ULong)args[1];
+    point               = (FT_UShort)args[0];
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+    if ( SUBPIXEL_HINTING_INFINALITY                        &&
+         exc->ignore_x_mode                                 &&
+         exc->GS.freeVector.x != 0                          &&
+         exc->GS.freeVector.y == 0                          &&
+         !( exc->sph_tweak_flags & SPH_TWEAK_NORMAL_ROUND ) )
+      control_value_cutin = 0;
+#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
+
+    if ( BOUNDS( point,     exc->zp0.n_points ) ||
+         BOUNDSL( cvtEntry, exc->cvtSize )      )
+    {
+      if ( exc->pedantic_hinting )
+        exc->error = FT_THROW( Invalid_Reference );
+      goto Fail;
+    }
+
+    /* UNDOCUMENTED!                                                      */
+    /*                                                                    */
+    /* The behaviour of an MIAP instruction is quite different when used  */
+    /* in the twilight zone.                                              */
+    /*                                                                    */
+    /* First, no control value cut-in test is performed as it would fail  */
+    /* anyway.  Second, the original point, i.e. (org_x,org_y) of         */
+    /* zp0.point, is set to the absolute, unrounded distance found in the */
+    /* CVT.                                                               */
+    /*                                                                    */
+    /* This is used in the CVT programs of the Microsoft fonts Arial,     */
+    /* Times, etc., in order to re-adjust some key font heights.  It      */
+    /* allows the use of the IP instruction in the twilight zone, which   */
+    /* otherwise would be invalid according to the specification.         */
+    /*                                                                    */
+    /* We implement it with a special sequence for the twilight zone.     */
+    /* This is a bad hack, but it seems to work.                          */
+    /*                                                                    */
+    /* Confirmed by Greg Hitchcock.                                       */
+
+    distance = exc->func_read_cvt( exc, cvtEntry );
+
+    if ( exc->GS.gep0 == 0 )   /* If in twilight zone */
+    {
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+      /* Only adjust if not in sph_compatibility_mode or ignore_x_mode. */
+      /* Determined via experimentation and may be incorrect...         */
+      if ( !( SUBPIXEL_HINTING_INFINALITY           &&
+              ( exc->ignore_x_mode                &&
+                exc->face->sph_compatibility_mode ) ) )
+#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
+        exc->zp0.org[point].x = TT_MulFix14( distance,
+                                             exc->GS.freeVector.x );
+      exc->zp0.org[point].y = TT_MulFix14( distance,
+                                           exc->GS.freeVector.y ),
+      exc->zp0.cur[point]   = exc->zp0.org[point];
+    }
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+    if ( SUBPIXEL_HINTING_INFINALITY                    &&
+         exc->ignore_x_mode                             &&
+         ( exc->sph_tweak_flags & SPH_TWEAK_MIAP_HACK ) &&
+         distance > 0                                   &&
+         exc->GS.freeVector.y != 0                      )
+      distance = 0;
+#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
+
+    org_dist = FAST_PROJECT( &exc->zp0.cur[point] );
+
+    if ( ( exc->opcode & 1 ) != 0 )   /* rounding and control cut-in flag */
+    {
+      if ( FT_ABS( distance - org_dist ) > control_value_cutin )
+        distance = org_dist;
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+      if ( SUBPIXEL_HINTING_INFINALITY &&
+           exc->ignore_x_mode          &&
+           exc->GS.freeVector.x != 0   )
+        distance = Round_None( exc,
+                               distance,
+                               exc->tt_metrics.compensations[0] );
+      else
+#endif
+        distance = exc->func_round( exc,
+                                    distance,
+                                    exc->tt_metrics.compensations[0] );
+    }
+
+    exc->func_move( exc, &exc->zp0, point, distance - org_dist );
+
+  Fail:
+    exc->GS.rp0 = point;
+    exc->GS.rp1 = point;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* MDRP[abcde]:  Move Direct Relative Point                              */
+  /* Opcode range: 0xC0-0xDF                                               */
+  /* Stack:        uint32 -->                                              */
+  /*                                                                       */
+  static void
+  Ins_MDRP( TT_ExecContext  exc,
+            FT_Long*        args )
+  {
+    FT_UShort   point = 0;
+    FT_F26Dot6  org_dist, distance, minimum_distance;
+
+
+    minimum_distance = exc->GS.minimum_distance;
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+    if ( SUBPIXEL_HINTING_INFINALITY                        &&
+         exc->ignore_x_mode                                 &&
+         exc->GS.freeVector.x != 0                          &&
+         !( exc->sph_tweak_flags & SPH_TWEAK_NORMAL_ROUND ) )
+      minimum_distance = 0;
+#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
+
+    point = (FT_UShort)args[0];
+
+    if ( BOUNDS( point,       exc->zp1.n_points ) ||
+         BOUNDS( exc->GS.rp0, exc->zp0.n_points ) )
+    {
+      if ( exc->pedantic_hinting )
+        exc->error = FT_THROW( Invalid_Reference );
+      goto Fail;
+    }
+
+    /* XXX: Is there some undocumented feature while in the */
+    /*      twilight zone?                                  */
+
+    /* XXX: UNDOCUMENTED: twilight zone special case */
+
+    if ( exc->GS.gep0 == 0 || exc->GS.gep1 == 0 )
+    {
+      FT_Vector*  vec1 = &exc->zp1.org[point];
+      FT_Vector*  vec2 = &exc->zp0.org[exc->GS.rp0];
+
+
+      org_dist = DUALPROJ( vec1, vec2 );
+    }
+    else
+    {
+      FT_Vector*  vec1 = &exc->zp1.orus[point];
+      FT_Vector*  vec2 = &exc->zp0.orus[exc->GS.rp0];
+
+
+      if ( exc->metrics.x_scale == exc->metrics.y_scale )
+      {
+        /* this should be faster */
+        org_dist = DUALPROJ( vec1, vec2 );
+        org_dist = FT_MulFix( org_dist, exc->metrics.x_scale );
+      }
+      else
+      {
+        FT_Vector  vec;
+
+
+        vec.x = FT_MulFix( vec1->x - vec2->x, exc->metrics.x_scale );
+        vec.y = FT_MulFix( vec1->y - vec2->y, exc->metrics.y_scale );
+
+        org_dist = FAST_DUALPROJ( &vec );
+      }
+    }
+
+    /* single width cut-in test */
+
+    if ( FT_ABS( org_dist - exc->GS.single_width_value ) <
+         exc->GS.single_width_cutin )
+    {
+      if ( org_dist >= 0 )
+        org_dist = exc->GS.single_width_value;
+      else
+        org_dist = -exc->GS.single_width_value;
+    }
+
+    /* round flag */
+
+    if ( ( exc->opcode & 4 ) != 0 )
+    {
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+      if ( SUBPIXEL_HINTING_INFINALITY &&
+           exc->ignore_x_mode          &&
+           exc->GS.freeVector.x != 0   )
+        distance = Round_None(
+                     exc,
+                     org_dist,
+                     exc->tt_metrics.compensations[exc->opcode & 3] );
+      else
+#endif
+        distance = exc->func_round(
+                     exc,
+                     org_dist,
+                     exc->tt_metrics.compensations[exc->opcode & 3] );
+    }
+    else
+      distance = Round_None(
+                   exc,
+                   org_dist,
+                   exc->tt_metrics.compensations[exc->opcode & 3] );
+
+    /* minimum distance flag */
+
+    if ( ( exc->opcode & 8 ) != 0 )
+    {
+      if ( org_dist >= 0 )
+      {
+        if ( distance < minimum_distance )
+          distance = minimum_distance;
+      }
+      else
+      {
+        if ( distance > -minimum_distance )
+          distance = -minimum_distance;
+      }
+    }
+
+    /* now move the point */
+
+    org_dist = PROJECT( exc->zp1.cur + point, exc->zp0.cur + exc->GS.rp0 );
+
+    exc->func_move( exc, &exc->zp1, point, distance - org_dist );
+
+  Fail:
+    exc->GS.rp1 = exc->GS.rp0;
+    exc->GS.rp2 = point;
+
+    if ( ( exc->opcode & 16 ) != 0 )
+      exc->GS.rp0 = point;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* MIRP[abcde]:  Move Indirect Relative Point                            */
+  /* Opcode range: 0xE0-0xFF                                               */
+  /* Stack:        int32? uint32 -->                                       */
+  /*                                                                       */
+  static void
+  Ins_MIRP( TT_ExecContext  exc,
+            FT_Long*        args )
+  {
+    FT_UShort   point;
+    FT_ULong    cvtEntry;
+
+    FT_F26Dot6  cvt_dist,
+                distance,
+                cur_dist,
+                org_dist,
+                control_value_cutin,
+                minimum_distance;
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+    FT_Int      B1           = 0; /* pacify compiler */
+    FT_Int      B2           = 0;
+    FT_Bool     reverse_move = FALSE;
+#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
+
+
+    minimum_distance    = exc->GS.minimum_distance;
+    control_value_cutin = exc->GS.control_value_cutin;
+    point               = (FT_UShort)args[0];
+    cvtEntry            = (FT_ULong)( args[1] + 1 );
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+    if ( SUBPIXEL_HINTING_INFINALITY                        &&
+         exc->ignore_x_mode                                 &&
+         exc->GS.freeVector.x != 0                          &&
+         !( exc->sph_tweak_flags & SPH_TWEAK_NORMAL_ROUND ) )
+      control_value_cutin = minimum_distance = 0;
+#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
+
+    /* XXX: UNDOCUMENTED! cvt[-1] = 0 always */
+
+    if ( BOUNDS( point,       exc->zp1.n_points ) ||
+         BOUNDSL( cvtEntry,   exc->cvtSize + 1 )  ||
+         BOUNDS( exc->GS.rp0, exc->zp0.n_points ) )
+    {
+      if ( exc->pedantic_hinting )
+        exc->error = FT_THROW( Invalid_Reference );
+      goto Fail;
+    }
+
+    if ( !cvtEntry )
+      cvt_dist = 0;
+    else
+      cvt_dist = exc->func_read_cvt( exc, cvtEntry - 1 );
+
+    /* single width test */
+
+    if ( FT_ABS( cvt_dist - exc->GS.single_width_value ) <
+         exc->GS.single_width_cutin )
+    {
+      if ( cvt_dist >= 0 )
+        cvt_dist =  exc->GS.single_width_value;
+      else
+        cvt_dist = -exc->GS.single_width_value;
+    }
+
+    /* UNDOCUMENTED!  The MS rasterizer does that with */
+    /* twilight points (confirmed by Greg Hitchcock)   */
+    if ( exc->GS.gep1 == 0 )
+    {
+      exc->zp1.org[point].x = exc->zp0.org[exc->GS.rp0].x +
+                              TT_MulFix14( cvt_dist,
+                                           exc->GS.freeVector.x );
+      exc->zp1.org[point].y = exc->zp0.org[exc->GS.rp0].y +
+                              TT_MulFix14( cvt_dist,
+                                           exc->GS.freeVector.y );
+      exc->zp1.cur[point]   = exc->zp1.org[point];
+    }
+
+    org_dist = DUALPROJ( &exc->zp1.org[point], &exc->zp0.org[exc->GS.rp0] );
+    cur_dist = PROJECT ( &exc->zp1.cur[point], &exc->zp0.cur[exc->GS.rp0] );
+
+    /* auto-flip test */
+
+    if ( exc->GS.auto_flip )
+    {
+      if ( ( org_dist ^ cvt_dist ) < 0 )
+        cvt_dist = -cvt_dist;
+    }
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+    if ( SUBPIXEL_HINTING_INFINALITY                               &&
+         exc->ignore_x_mode                                        &&
+         exc->GS.freeVector.y != 0                                 &&
+         ( exc->sph_tweak_flags & SPH_TWEAK_TIMES_NEW_ROMAN_HACK ) )
+    {
+      if ( cur_dist < -64 )
+        cvt_dist -= 16;
+      else if ( cur_dist > 64 && cur_dist < 84 )
+        cvt_dist += 32;
+    }
+#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
+
+    /* control value cut-in and round */
+
+    if ( ( exc->opcode & 4 ) != 0 )
+    {
+      /* XXX: UNDOCUMENTED!  Only perform cut-in test when both points */
+      /*      refer to the same zone.                                  */
+
+      if ( exc->GS.gep0 == exc->GS.gep1 )
+      {
+        /* XXX: According to Greg Hitchcock, the following wording is */
+        /*      the right one:                                        */
+        /*                                                            */
+        /*        When the absolute difference between the value in   */
+        /*        the table [CVT] and the measurement directly from   */
+        /*        the outline is _greater_ than the cut_in value, the */
+        /*        outline measurement is used.                        */
+        /*                                                            */
+        /*      This is from `instgly.doc'.  The description in       */
+        /*      `ttinst2.doc', version 1.66, is thus incorrect since  */
+        /*      it implies `>=' instead of `>'.                       */
+
+        if ( FT_ABS( cvt_dist - org_dist ) > control_value_cutin )
+          cvt_dist = org_dist;
+      }
+
+      distance = exc->func_round(
+                   exc,
+                   cvt_dist,
+                   exc->tt_metrics.compensations[exc->opcode & 3] );
+    }
+    else
+    {
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+      /* do cvt cut-in always in MIRP for sph */
+      if ( SUBPIXEL_HINTING_INFINALITY  &&
+           exc->ignore_x_mode           &&
+           exc->GS.gep0 == exc->GS.gep1 )
+      {
+        if ( FT_ABS( cvt_dist - org_dist ) > control_value_cutin )
+          cvt_dist = org_dist;
+      }
+#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
+
+      distance = Round_None(
+                   exc,
+                   cvt_dist,
+                   exc->tt_metrics.compensations[exc->opcode & 3] );
+    }
+
+    /* minimum distance test */
+
+    if ( ( exc->opcode & 8 ) != 0 )
+    {
+      if ( org_dist >= 0 )
+      {
+        if ( distance < minimum_distance )
+          distance = minimum_distance;
+      }
+      else
+      {
+        if ( distance > -minimum_distance )
+          distance = -minimum_distance;
+      }
+    }
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+    if ( SUBPIXEL_HINTING_INFINALITY )
+    {
+      B1 = exc->zp1.cur[point].y;
+
+      /* Round moves if necessary */
+      if ( exc->ignore_x_mode                                          &&
+           exc->GS.freeVector.y != 0                                   &&
+           ( exc->sph_tweak_flags & SPH_TWEAK_ROUND_NONPIXEL_Y_MOVES ) )
+        distance = FT_PIX_ROUND( B1 + distance - cur_dist ) - B1 + cur_dist;
+
+      if ( exc->ignore_x_mode                                      &&
+           exc->GS.freeVector.y != 0                               &&
+           ( exc->opcode & 16 ) == 0                               &&
+           ( exc->opcode & 8 ) == 0                                &&
+           ( exc->sph_tweak_flags & SPH_TWEAK_COURIER_NEW_2_HACK ) )
+        distance += 64;
+    }
+#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
+
+    exc->func_move( exc, &exc->zp1, point, distance - cur_dist );
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+    if ( SUBPIXEL_HINTING_INFINALITY )
+    {
+      B2 = exc->zp1.cur[point].y;
+
+      /* Reverse move if necessary */
+      if ( exc->ignore_x_mode )
+      {
+        if ( exc->face->sph_compatibility_mode &&
+             exc->GS.freeVector.y != 0         &&
+             ( B1 & 63 ) == 0                  &&
+             ( B2 & 63 ) != 0                  )
+          reverse_move = TRUE;
+
+        if ( ( exc->sph_tweak_flags & SPH_TWEAK_SKIP_NONPIXEL_Y_MOVES ) &&
+             exc->GS.freeVector.y != 0                                  &&
+             ( B2 & 63 ) != 0                                           &&
+             ( B1 & 63 ) != 0                                           )
+          reverse_move = TRUE;
+      }
+
+      if ( reverse_move )
+        exc->func_move( exc, &exc->zp1, point, -( distance - cur_dist ) );
+    }
+
+#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
+
+  Fail:
+    exc->GS.rp1 = exc->GS.rp0;
+
+    if ( ( exc->opcode & 16 ) != 0 )
+      exc->GS.rp0 = point;
+
+    exc->GS.rp2 = point;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* ALIGNRP[]:    ALIGN Relative Point                                    */
+  /* Opcode range: 0x3C                                                    */
+  /* Stack:        uint32 uint32... -->                                    */
+  /*                                                                       */
+  static void
+  Ins_ALIGNRP( TT_ExecContext  exc )
+  {
+    FT_UShort   point;
+    FT_F26Dot6  distance;
+
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+    if ( SUBPIXEL_HINTING_INFINALITY                               &&
+         exc->ignore_x_mode                                        &&
+         exc->iup_called                                           &&
+         ( exc->sph_tweak_flags & SPH_TWEAK_NO_ALIGNRP_AFTER_IUP ) )
+    {
+      exc->error = FT_THROW( Invalid_Reference );
+      goto Fail;
+    }
+#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
+
+    if ( exc->top < exc->GS.loop                  ||
+         BOUNDS( exc->GS.rp0, exc->zp0.n_points ) )
+    {
+      if ( exc->pedantic_hinting )
+        exc->error = FT_THROW( Invalid_Reference );
+      goto Fail;
+    }
+
+    while ( exc->GS.loop > 0 )
+    {
+      exc->args--;
+
+      point = (FT_UShort)exc->stack[exc->args];
+
+      if ( BOUNDS( point, exc->zp1.n_points ) )
+      {
+        if ( exc->pedantic_hinting )
+        {
+          exc->error = FT_THROW( Invalid_Reference );
+          return;
+        }
+      }
+      else
+      {
+        distance = PROJECT( exc->zp1.cur + point,
+                            exc->zp0.cur + exc->GS.rp0 );
+
+        exc->func_move( exc, &exc->zp1, point, -distance );
+      }
+
+      exc->GS.loop--;
+    }
+
+  Fail:
+    exc->GS.loop = 1;
+    exc->new_top = exc->args;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* ISECT[]:      moves point to InterSECTion                             */
+  /* Opcode range: 0x0F                                                    */
+  /* Stack:        5 * uint32 -->                                          */
+  /*                                                                       */
+  static void
+  Ins_ISECT( TT_ExecContext  exc,
+             FT_Long*        args )
+  {
+    FT_UShort   point,
+                a0, a1,
+                b0, b1;
+
+    FT_F26Dot6  discriminant, dotproduct;
+
+    FT_F26Dot6  dx,  dy,
+                dax, day,
+                dbx, dby;
+
+    FT_F26Dot6  val;
+
+    FT_Vector   R;
+
+
+    point = (FT_UShort)args[0];
+
+    a0 = (FT_UShort)args[1];
+    a1 = (FT_UShort)args[2];
+    b0 = (FT_UShort)args[3];
+    b1 = (FT_UShort)args[4];
+
+    if ( BOUNDS( b0,    exc->zp0.n_points ) ||
+         BOUNDS( b1,    exc->zp0.n_points ) ||
+         BOUNDS( a0,    exc->zp1.n_points ) ||
+         BOUNDS( a1,    exc->zp1.n_points ) ||
+         BOUNDS( point, exc->zp2.n_points ) )
+    {
+      if ( exc->pedantic_hinting )
+        exc->error = FT_THROW( Invalid_Reference );
+      return;
+    }
+
+    /* Cramer's rule */
+
+    dbx = exc->zp0.cur[b1].x - exc->zp0.cur[b0].x;
+    dby = exc->zp0.cur[b1].y - exc->zp0.cur[b0].y;
+
+    dax = exc->zp1.cur[a1].x - exc->zp1.cur[a0].x;
+    day = exc->zp1.cur[a1].y - exc->zp1.cur[a0].y;
+
+    dx = exc->zp0.cur[b0].x - exc->zp1.cur[a0].x;
+    dy = exc->zp0.cur[b0].y - exc->zp1.cur[a0].y;
+
+    discriminant = FT_MulDiv( dax, -dby, 0x40 ) +
+                   FT_MulDiv( day, dbx, 0x40 );
+    dotproduct   = FT_MulDiv( dax, dbx, 0x40 ) +
+                   FT_MulDiv( day, dby, 0x40 );
+
+    /* The discriminant above is actually a cross product of vectors     */
+    /* da and db. Together with the dot product, they can be used as     */
+    /* surrogates for sine and cosine of the angle between the vectors.  */
+    /* Indeed,                                                           */
+    /*       dotproduct   = |da||db|cos(angle)                           */
+    /*       discriminant = |da||db|sin(angle)     .                     */
+    /* We use these equations to reject grazing intersections by         */
+    /* thresholding abs(tan(angle)) at 1/19, corresponding to 3 degrees. */
+    if ( 19 * FT_ABS( discriminant ) > FT_ABS( dotproduct ) )
+    {
+      val = FT_MulDiv( dx, -dby, 0x40 ) + FT_MulDiv( dy, dbx, 0x40 );
+
+      R.x = FT_MulDiv( val, dax, discriminant );
+      R.y = FT_MulDiv( val, day, discriminant );
+
+      /* XXX: Block in backwards_compatibility and/or post-IUP? */
+      exc->zp2.cur[point].x = exc->zp1.cur[a0].x + R.x;
+      exc->zp2.cur[point].y = exc->zp1.cur[a0].y + R.y;
+    }
+    else
+    {
+      /* else, take the middle of the middles of A and B */
+
+      /* XXX: Block in backwards_compatibility and/or post-IUP? */
+      exc->zp2.cur[point].x = ( exc->zp1.cur[a0].x +
+                                exc->zp1.cur[a1].x +
+                                exc->zp0.cur[b0].x +
+                                exc->zp0.cur[b1].x ) / 4;
+      exc->zp2.cur[point].y = ( exc->zp1.cur[a0].y +
+                                exc->zp1.cur[a1].y +
+                                exc->zp0.cur[b0].y +
+                                exc->zp0.cur[b1].y ) / 4;
+    }
+
+    exc->zp2.tags[point] |= FT_CURVE_TAG_TOUCH_BOTH;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* ALIGNPTS[]:   ALIGN PoinTS                                            */
+  /* Opcode range: 0x27                                                    */
+  /* Stack:        uint32 uint32 -->                                       */
+  /*                                                                       */
+  static void
+  Ins_ALIGNPTS( TT_ExecContext  exc,
+                FT_Long*        args )
+  {
+    FT_UShort   p1, p2;
+    FT_F26Dot6  distance;
+
+
+    p1 = (FT_UShort)args[0];
+    p2 = (FT_UShort)args[1];
+
+    if ( BOUNDS( p1, exc->zp1.n_points ) ||
+         BOUNDS( p2, exc->zp0.n_points ) )
+    {
+      if ( exc->pedantic_hinting )
+        exc->error = FT_THROW( Invalid_Reference );
+      return;
+    }
+
+    distance = PROJECT( exc->zp0.cur + p2, exc->zp1.cur + p1 ) / 2;
+
+    exc->func_move( exc, &exc->zp1, p1, distance );
+    exc->func_move( exc, &exc->zp0, p2, -distance );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* IP[]:         Interpolate Point                                       */
+  /* Opcode range: 0x39                                                    */
+  /* Stack:        uint32... -->                                           */
+  /*                                                                       */
+
+  /* SOMETIMES, DUMBER CODE IS BETTER CODE */
+
+  static void
+  Ins_IP( TT_ExecContext  exc )
+  {
+    FT_F26Dot6  old_range, cur_range;
+    FT_Vector*  orus_base;
+    FT_Vector*  cur_base;
+    FT_Int      twilight;
+
+
+    if ( exc->top < exc->GS.loop )
+    {
+      if ( exc->pedantic_hinting )
+        exc->error = FT_THROW( Invalid_Reference );
+      goto Fail;
+    }
+
+    /*
+     * We need to deal in a special way with the twilight zone.
+     * Otherwise, by definition, the value of exc->twilight.orus[n] is (0,0),
+     * for every n.
+     */
+    twilight = exc->GS.gep0 == 0 || exc->GS.gep1 == 0 || exc->GS.gep2 == 0;
+
+    if ( BOUNDS( exc->GS.rp1, exc->zp0.n_points ) )
+    {
+      if ( exc->pedantic_hinting )
+        exc->error = FT_THROW( Invalid_Reference );
+      goto Fail;
+    }
+
+    if ( twilight )
+      orus_base = &exc->zp0.org[exc->GS.rp1];
+    else
+      orus_base = &exc->zp0.orus[exc->GS.rp1];
+
+    cur_base = &exc->zp0.cur[exc->GS.rp1];
+
+    /* XXX: There are some glyphs in some braindead but popular */
+    /*      fonts out there (e.g. [aeu]grave in monotype.ttf)   */
+    /*      calling IP[] with bad values of rp[12].             */
+    /*      Do something sane when this odd thing happens.      */
+    if ( BOUNDS( exc->GS.rp1, exc->zp0.n_points ) ||
+         BOUNDS( exc->GS.rp2, exc->zp1.n_points ) )
+    {
+      old_range = 0;
+      cur_range = 0;
+    }
+    else
+    {
+      if ( twilight )
+        old_range = DUALPROJ( &exc->zp1.org[exc->GS.rp2], orus_base );
+      else if ( exc->metrics.x_scale == exc->metrics.y_scale )
+        old_range = DUALPROJ( &exc->zp1.orus[exc->GS.rp2], orus_base );
+      else
+      {
+        FT_Vector  vec;
+
+
+        vec.x = FT_MulFix( exc->zp1.orus[exc->GS.rp2].x - orus_base->x,
+                           exc->metrics.x_scale );
+        vec.y = FT_MulFix( exc->zp1.orus[exc->GS.rp2].y - orus_base->y,
+                           exc->metrics.y_scale );
+
+        old_range = FAST_DUALPROJ( &vec );
+      }
+
+      cur_range = PROJECT( &exc->zp1.cur[exc->GS.rp2], cur_base );
+    }
+
+    for ( ; exc->GS.loop > 0; --exc->GS.loop )
+    {
+      FT_UInt     point = (FT_UInt)exc->stack[--exc->args];
+      FT_F26Dot6  org_dist, cur_dist, new_dist;
+
+
+      /* check point bounds */
+      if ( BOUNDS( point, exc->zp2.n_points ) )
+      {
+        if ( exc->pedantic_hinting )
+        {
+          exc->error = FT_THROW( Invalid_Reference );
+          return;
+        }
+        continue;
+      }
+
+      if ( twilight )
+        org_dist = DUALPROJ( &exc->zp2.org[point], orus_base );
+      else if ( exc->metrics.x_scale == exc->metrics.y_scale )
+        org_dist = DUALPROJ( &exc->zp2.orus[point], orus_base );
+      else
+      {
+        FT_Vector  vec;
+
+
+        vec.x = FT_MulFix( exc->zp2.orus[point].x - orus_base->x,
+                           exc->metrics.x_scale );
+        vec.y = FT_MulFix( exc->zp2.orus[point].y - orus_base->y,
+                           exc->metrics.y_scale );
+
+        org_dist = FAST_DUALPROJ( &vec );
+      }
+
+      cur_dist = PROJECT( &exc->zp2.cur[point], cur_base );
+
+      if ( org_dist )
+      {
+        if ( old_range )
+          new_dist = FT_MulDiv( org_dist, cur_range, old_range );
+        else
+        {
+          /* This is the same as what MS does for the invalid case:  */
+          /*                                                         */
+          /*   delta = (Original_Pt - Original_RP1) -                */
+          /*           (Current_Pt - Current_RP1)         ;          */
+          /*                                                         */
+          /* In FreeType speak:                                      */
+          /*                                                         */
+          /*   delta = org_dist - cur_dist          .                */
+          /*                                                         */
+          /* We move `point' by `new_dist - cur_dist' after leaving  */
+          /* this block, thus we have                                */
+          /*                                                         */
+          /*   new_dist - cur_dist = delta                   ,       */
+          /*   new_dist - cur_dist = org_dist - cur_dist     ,       */
+          /*              new_dist = org_dist                .       */
+
+          new_dist = org_dist;
+        }
+      }
+      else
+        new_dist = 0;
+
+      exc->func_move( exc,
+                      &exc->zp2,
+                      (FT_UShort)point,
+                      new_dist - cur_dist );
+    }
+
+  Fail:
+    exc->GS.loop = 1;
+    exc->new_top = exc->args;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* UTP[a]:       UnTouch Point                                           */
+  /* Opcode range: 0x29                                                    */
+  /* Stack:        uint32 -->                                              */
+  /*                                                                       */
+  static void
+  Ins_UTP( TT_ExecContext  exc,
+           FT_Long*        args )
+  {
+    FT_UShort  point;
+    FT_Byte    mask;
+
+
+    point = (FT_UShort)args[0];
+
+    if ( BOUNDS( point, exc->zp0.n_points ) )
+    {
+      if ( exc->pedantic_hinting )
+        exc->error = FT_THROW( Invalid_Reference );
+      return;
+    }
+
+    mask = 0xFF;
+
+    if ( exc->GS.freeVector.x != 0 )
+      mask &= ~FT_CURVE_TAG_TOUCH_X;
+
+    if ( exc->GS.freeVector.y != 0 )
+      mask &= ~FT_CURVE_TAG_TOUCH_Y;
+
+    exc->zp0.tags[point] &= mask;
+  }
+
+
+  /* Local variables for Ins_IUP: */
+  typedef struct  IUP_WorkerRec_
+  {
+    FT_Vector*  orgs;   /* original and current coordinate */
+    FT_Vector*  curs;   /* arrays                          */
+    FT_Vector*  orus;
+    FT_UInt     max_points;
+
+  } IUP_WorkerRec, *IUP_Worker;
+
+
+  static void
+  _iup_worker_shift( IUP_Worker  worker,
+                     FT_UInt     p1,
+                     FT_UInt     p2,
+                     FT_UInt     p )
+  {
+    FT_UInt     i;
+    FT_F26Dot6  dx;
+
+
+    dx = worker->curs[p].x - worker->orgs[p].x;
+    if ( dx != 0 )
+    {
+      for ( i = p1; i < p; i++ )
+        worker->curs[i].x += dx;
+
+      for ( i = p + 1; i <= p2; i++ )
+        worker->curs[i].x += dx;
+    }
+  }
+
+
+  static void
+  _iup_worker_interpolate( IUP_Worker  worker,
+                           FT_UInt     p1,
+                           FT_UInt     p2,
+                           FT_UInt     ref1,
+                           FT_UInt     ref2 )
+  {
+    FT_UInt     i;
+    FT_F26Dot6  orus1, orus2, org1, org2, cur1, cur2, delta1, delta2;
+
+
+    if ( p1 > p2 )
+      return;
+
+    if ( BOUNDS( ref1, worker->max_points ) ||
+         BOUNDS( ref2, worker->max_points ) )
+      return;
+
+    orus1 = worker->orus[ref1].x;
+    orus2 = worker->orus[ref2].x;
+
+    if ( orus1 > orus2 )
+    {
+      FT_F26Dot6  tmp_o;
+      FT_UInt     tmp_r;
+
+
+      tmp_o = orus1;
+      orus1 = orus2;
+      orus2 = tmp_o;
+
+      tmp_r = ref1;
+      ref1  = ref2;
+      ref2  = tmp_r;
+    }
+
+    org1   = worker->orgs[ref1].x;
+    org2   = worker->orgs[ref2].x;
+    cur1   = worker->curs[ref1].x;
+    cur2   = worker->curs[ref2].x;
+    delta1 = cur1 - org1;
+    delta2 = cur2 - org2;
+
+    if ( cur1 == cur2 || orus1 == orus2 )
+    {
+
+      /* trivial snap or shift of untouched points */
+      for ( i = p1; i <= p2; i++ )
+      {
+        FT_F26Dot6  x = worker->orgs[i].x;
+
+
+        if ( x <= org1 )
+          x += delta1;
+
+        else if ( x >= org2 )
+          x += delta2;
+
+        else
+          x = cur1;
+
+        worker->curs[i].x = x;
+      }
+    }
+    else
+    {
+      FT_Fixed  scale       = 0;
+      FT_Bool   scale_valid = 0;
+
+
+      /* interpolation */
+      for ( i = p1; i <= p2; i++ )
+      {
+        FT_F26Dot6  x = worker->orgs[i].x;
+
+
+        if ( x <= org1 )
+          x += delta1;
+
+        else if ( x >= org2 )
+          x += delta2;
+
+        else
+        {
+          if ( !scale_valid )
+          {
+            scale_valid = 1;
+            scale       = FT_DivFix( cur2 - cur1, orus2 - orus1 );
+          }
+
+          x = cur1 + FT_MulFix( worker->orus[i].x - orus1, scale );
+        }
+        worker->curs[i].x = x;
+      }
+    }
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* IUP[a]:       Interpolate Untouched Points                            */
+  /* Opcode range: 0x30-0x31                                               */
+  /* Stack:        -->                                                     */
+  /*                                                                       */
+  static void
+  Ins_IUP( TT_ExecContext  exc )
+  {
+    IUP_WorkerRec  V;
+    FT_Byte        mask;
+
+    FT_UInt   first_point;   /* first point of contour        */
+    FT_UInt   end_point;     /* end point (last+1) of contour */
+
+    FT_UInt   first_touched; /* first touched point in contour   */
+    FT_UInt   cur_touched;   /* current touched point in contour */
+
+    FT_UInt   point;         /* current point   */
+    FT_Short  contour;       /* current contour */
+
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
+    /* See `ttinterp.h' for details on backwards compatibility mode. */
+    /* Allow IUP until it has been called on both axes.  Immediately */
+    /* return on subsequent ones.                                    */
+    if ( SUBPIXEL_HINTING_MINIMAL     &&
+         exc->backwards_compatibility )
+    {
+      if ( exc->iupx_called && exc->iupy_called )
+        return;
+
+      if ( exc->opcode & 1 )
+        exc->iupx_called = TRUE;
+      else
+        exc->iupy_called = TRUE;
+    }
+#endif
+
+    /* ignore empty outlines */
+    if ( exc->pts.n_contours == 0 )
+      return;
+
+    if ( exc->opcode & 1 )
+    {
+      mask   = FT_CURVE_TAG_TOUCH_X;
+      V.orgs = exc->pts.org;
+      V.curs = exc->pts.cur;
+      V.orus = exc->pts.orus;
+    }
+    else
+    {
+      mask   = FT_CURVE_TAG_TOUCH_Y;
+      V.orgs = (FT_Vector*)( (FT_Pos*)exc->pts.org + 1 );
+      V.curs = (FT_Vector*)( (FT_Pos*)exc->pts.cur + 1 );
+      V.orus = (FT_Vector*)( (FT_Pos*)exc->pts.orus + 1 );
+    }
+    V.max_points = exc->pts.n_points;
+
+    contour = 0;
+    point   = 0;
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+    if ( SUBPIXEL_HINTING_INFINALITY &&
+         exc->ignore_x_mode          )
+    {
+      exc->iup_called = TRUE;
+      if ( exc->sph_tweak_flags & SPH_TWEAK_SKIP_IUP )
+        return;
+    }
+#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
+
+    do
+    {
+      end_point   = exc->pts.contours[contour] - exc->pts.first_point;
+      first_point = point;
+
+      if ( BOUNDS( end_point, exc->pts.n_points ) )
+        end_point = exc->pts.n_points - 1;
+
+      while ( point <= end_point && ( exc->pts.tags[point] & mask ) == 0 )
+        point++;
+
+      if ( point <= end_point )
+      {
+        first_touched = point;
+        cur_touched   = point;
+
+        point++;
+
+        while ( point <= end_point )
+        {
+          if ( ( exc->pts.tags[point] & mask ) != 0 )
+          {
+            _iup_worker_interpolate( &V,
+                                     cur_touched + 1,
+                                     point - 1,
+                                     cur_touched,
+                                     point );
+            cur_touched = point;
+          }
+
+          point++;
+        }
+
+        if ( cur_touched == first_touched )
+          _iup_worker_shift( &V, first_point, end_point, cur_touched );
+        else
+        {
+          _iup_worker_interpolate( &V,
+                                   (FT_UShort)( cur_touched + 1 ),
+                                   end_point,
+                                   cur_touched,
+                                   first_touched );
+
+          if ( first_touched > 0 )
+            _iup_worker_interpolate( &V,
+                                     first_point,
+                                     first_touched - 1,
+                                     cur_touched,
+                                     first_touched );
+        }
+      }
+      contour++;
+    } while ( contour < exc->pts.n_contours );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* DELTAPn[]:    DELTA exceptions P1, P2, P3                             */
+  /* Opcode range: 0x5D,0x71,0x72                                          */
+  /* Stack:        uint32 (2 * uint32)... -->                              */
+  /*                                                                       */
+  static void
+  Ins_DELTAP( TT_ExecContext  exc,
+              FT_Long*        args )
+  {
+    FT_ULong   nump, k;
+    FT_UShort  A;
+    FT_ULong   C, P;
+    FT_Long    B;
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+    FT_UShort  B1, B2;
+
+
+    if ( SUBPIXEL_HINTING_INFINALITY                              &&
+         exc->ignore_x_mode                                       &&
+         exc->iup_called                                          &&
+         ( exc->sph_tweak_flags & SPH_TWEAK_NO_DELTAP_AFTER_IUP ) )
+      goto Fail;
+#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
+
+    P    = (FT_ULong)exc->func_cur_ppem( exc );
+    nump = (FT_ULong)args[0];   /* some points theoretically may occur more
+                                   than once, thus UShort isn't enough */
+
+    for ( k = 1; k <= nump; k++ )
+    {
+      if ( exc->args < 2 )
+      {
+        if ( exc->pedantic_hinting )
+          exc->error = FT_THROW( Too_Few_Arguments );
+        exc->args = 0;
+        goto Fail;
+      }
+
+      exc->args -= 2;
+
+      A = (FT_UShort)exc->stack[exc->args + 1];
+      B = exc->stack[exc->args];
+
+      /* XXX: Because some popular fonts contain some invalid DeltaP */
+      /*      instructions, we simply ignore them when the stacked   */
+      /*      point reference is off limit, rather than returning an */
+      /*      error.  As a delta instruction doesn't change a glyph  */
+      /*      in great ways, this shouldn't be a problem.            */
+
+      if ( !BOUNDS( A, exc->zp0.n_points ) )
+      {
+        C = ( (FT_ULong)B & 0xF0 ) >> 4;
+
+        switch ( exc->opcode )
+        {
+        case 0x5D:
+          break;
+
+        case 0x71:
+          C += 16;
+          break;
+
+        case 0x72:
+          C += 32;
+          break;
+        }
+
+        C += exc->GS.delta_base;
+
+        if ( P == C )
+        {
+          B = ( (FT_ULong)B & 0xF ) - 8;
+          if ( B >= 0 )
+            B++;
+          B *= 1L << ( 6 - exc->GS.delta_shift );
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+
+          if ( SUBPIXEL_HINTING_INFINALITY )
+          {
+            /*
+             *  Allow delta move if
+             *
+             *  - not using ignore_x_mode rendering,
+             *  - glyph is specifically set to allow it, or
+             *  - glyph is composite and freedom vector is not in subpixel
+             *    direction.
+             */
+            if ( !exc->ignore_x_mode                                   ||
+                 ( exc->sph_tweak_flags & SPH_TWEAK_ALWAYS_DO_DELTAP ) ||
+                 ( exc->is_composite && exc->GS.freeVector.y != 0 )    )
+              exc->func_move( exc, &exc->zp0, A, B );
+
+            /* Otherwise, apply subpixel hinting and compatibility mode */
+            /* rules, always skipping deltas in subpixel direction.     */
+            else if ( exc->ignore_x_mode && exc->GS.freeVector.y != 0 )
+            {
+              /* save the y value of the point now; compare after move */
+              B1 = (FT_UShort)exc->zp0.cur[A].y;
+
+              /* Standard subpixel hinting: Allow y move for y-touched */
+              /* points.  This messes up DejaVu ...                    */
+              if ( !exc->face->sph_compatibility_mode          &&
+                   ( exc->zp0.tags[A] & FT_CURVE_TAG_TOUCH_Y ) )
+                exc->func_move( exc, &exc->zp0, A, B );
+
+              /* compatibility mode */
+              else if ( exc->face->sph_compatibility_mode                        &&
+                        !( exc->sph_tweak_flags & SPH_TWEAK_ALWAYS_SKIP_DELTAP ) )
+              {
+                if ( exc->sph_tweak_flags & SPH_TWEAK_ROUND_NONPIXEL_Y_MOVES )
+                  B = FT_PIX_ROUND( B1 + B ) - B1;
+
+                /* Allow delta move if using sph_compatibility_mode,   */
+                /* IUP has not been called, and point is touched on Y. */
+                if ( !exc->iup_called                            &&
+                     ( exc->zp0.tags[A] & FT_CURVE_TAG_TOUCH_Y ) )
+                  exc->func_move( exc, &exc->zp0, A, B );
+              }
+
+              B2 = (FT_UShort)exc->zp0.cur[A].y;
+
+              /* Reverse this move if it results in a disallowed move */
+              if ( exc->GS.freeVector.y != 0                          &&
+                   ( ( exc->face->sph_compatibility_mode          &&
+                       ( B1 & 63 ) == 0                           &&
+                       ( B2 & 63 ) != 0                           ) ||
+                     ( ( exc->sph_tweak_flags                   &
+                         SPH_TWEAK_SKIP_NONPIXEL_Y_MOVES_DELTAP ) &&
+                       ( B1 & 63 ) != 0                           &&
+                       ( B2 & 63 ) != 0                           ) ) )
+                exc->func_move( exc, &exc->zp0, A, -B );
+            }
+          }
+          else
+#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
+
+          {
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
+            /* See `ttinterp.h' for details on backwards compatibility */
+            /* mode.                                                   */
+            if ( SUBPIXEL_HINTING_MINIMAL     &&
+                 exc->backwards_compatibility )
+            {
+              if ( !( exc->iupx_called && exc->iupy_called )              &&
+                   ( ( exc->is_composite && exc->GS.freeVector.y != 0 ) ||
+                     ( exc->zp0.tags[A] & FT_CURVE_TAG_TOUCH_Y )        ) )
+                exc->func_move( exc, &exc->zp0, A, B );
+            }
+            else
+#endif
+              exc->func_move( exc, &exc->zp0, A, B );
+          }
+        }
+      }
+      else
+        if ( exc->pedantic_hinting )
+          exc->error = FT_THROW( Invalid_Reference );
+    }
+
+  Fail:
+    exc->new_top = exc->args;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* DELTACn[]:    DELTA exceptions C1, C2, C3                             */
+  /* Opcode range: 0x73,0x74,0x75                                          */
+  /* Stack:        uint32 (2 * uint32)... -->                              */
+  /*                                                                       */
+  static void
+  Ins_DELTAC( TT_ExecContext  exc,
+              FT_Long*        args )
+  {
+    FT_ULong  nump, k;
+    FT_ULong  A, C, P;
+    FT_Long   B;
+
+
+    P    = (FT_ULong)exc->func_cur_ppem( exc );
+    nump = (FT_ULong)args[0];
+
+    for ( k = 1; k <= nump; k++ )
+    {
+      if ( exc->args < 2 )
+      {
+        if ( exc->pedantic_hinting )
+          exc->error = FT_THROW( Too_Few_Arguments );
+        exc->args = 0;
+        goto Fail;
+      }
+
+      exc->args -= 2;
+
+      A = (FT_ULong)exc->stack[exc->args + 1];
+      B = exc->stack[exc->args];
+
+      if ( BOUNDSL( A, exc->cvtSize ) )
+      {
+        if ( exc->pedantic_hinting )
+        {
+          exc->error = FT_THROW( Invalid_Reference );
+          return;
+        }
+      }
+      else
+      {
+        C = ( (FT_ULong)B & 0xF0 ) >> 4;
+
+        switch ( exc->opcode )
+        {
+        case 0x73:
+          break;
+
+        case 0x74:
+          C += 16;
+          break;
+
+        case 0x75:
+          C += 32;
+          break;
+        }
+
+        C += exc->GS.delta_base;
+
+        if ( P == C )
+        {
+          B = ( (FT_ULong)B & 0xF ) - 8;
+          if ( B >= 0 )
+            B++;
+          B *= 1L << ( 6 - exc->GS.delta_shift );
+
+          exc->func_move_cvt( exc, A, B );
+        }
+      }
+    }
+
+  Fail:
+    exc->new_top = exc->args;
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* MISC. INSTRUCTIONS                                                    */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* GETINFO[]:    GET INFOrmation                                         */
+  /* Opcode range: 0x88                                                    */
+  /* Stack:        uint32 --> uint32                                       */
+  /*                                                                       */
+  /* XXX: UNDOCUMENTED: Selector bits higher than 9 are currently (May     */
+  /*      2015) not documented in the OpenType specification.              */
+  /*                                                                       */
+  /*      Selector bit 11 is incorrectly described as bit 8, while the     */
+  /*      real meaning of bit 8 (vertical LCD subpixels) stays             */
+  /*      undocumented.  The same mistake can be found in Greg Hitchcock's */
+  /*      whitepaper.                                                      */
+  /*                                                                       */
+  static void
+  Ins_GETINFO( TT_ExecContext  exc,
+               FT_Long*        args )
+  {
+    FT_Long    K;
+    TT_Driver  driver = (TT_Driver)FT_FACE_DRIVER( exc->face );
+
+
+    K = 0;
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+    /********************************/
+    /* RASTERIZER VERSION           */
+    /* Selector Bit:  0             */
+    /* Return Bit(s): 0-7           */
+    /*                              */
+    if ( SUBPIXEL_HINTING_INFINALITY &&
+         ( args[0] & 1 ) != 0        &&
+         exc->subpixel_hinting       )
+    {
+      if ( exc->ignore_x_mode )
+      {
+        /* if in ClearType backwards compatibility mode,        */
+        /* we sometimes change the TrueType version dynamically */
+        K = exc->rasterizer_version;
+        FT_TRACE6(( "Setting rasterizer version %d\n",
+                    exc->rasterizer_version ));
+      }
+      else
+        K = TT_INTERPRETER_VERSION_38;
+    }
+    else
+#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
+      if ( ( args[0] & 1 ) != 0 )
+        K = driver->interpreter_version;
+
+    /********************************/
+    /* GLYPH ROTATED                */
+    /* Selector Bit:  1             */
+    /* Return Bit(s): 8             */
+    /*                              */
+    if ( ( args[0] & 2 ) != 0 && exc->tt_metrics.rotated )
+      K |= 1 << 8;
+
+    /********************************/
+    /* GLYPH STRETCHED              */
+    /* Selector Bit:  2             */
+    /* Return Bit(s): 9             */
+    /*                              */
+    if ( ( args[0] & 4 ) != 0 && exc->tt_metrics.stretched )
+      K |= 1 << 9;
+
+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
+    /********************************/
+    /* VARIATION GLYPH              */
+    /* Selector Bit:  3             */
+    /* Return Bit(s): 10            */
+    /*                              */
+    /* XXX: UNDOCUMENTED!           */
+    if ( (args[0] & 8 ) != 0 && exc->face->blend )
+      K |= 1 << 10;
+#endif
+
+    /********************************/
+    /* BI-LEVEL HINTING AND         */
+    /* GRAYSCALE RENDERING          */
+    /* Selector Bit:  5             */
+    /* Return Bit(s): 12            */
+    /*                              */
+    if ( ( args[0] & 32 ) != 0 && exc->grayscale )
+      K |= 1 << 12;
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
+    if ( SUBPIXEL_HINTING_MINIMAL )
+    {
+      /********************************/
+      /* HINTING FOR SUBPIXEL         */
+      /* Selector Bit:  6             */
+      /* Return Bit(s): 13            */
+      /*                              */
+      /* v40 does subpixel hinting by default. */
+      if ( ( args[0] & 64 ) != 0 )
+        K |= 1 << 13;
+
+      /********************************/
+      /* VERTICAL LCD SUBPIXELS?      */
+      /* Selector Bit:  8             */
+      /* Return Bit(s): 15            */
+      /*                              */
+      if ( ( args[0] & 256 ) != 0 && exc->vertical_lcd_lean )
+        K |= 1 << 15;
+
+      /********************************/
+      /* SUBPIXEL POSITIONED?         */
+      /* Selector Bit:  10            */
+      /* Return Bit(s): 17            */
+      /*                              */
+      /* XXX: FreeType supports it, dependent on what client does? */
+      if ( ( args[0] & 1024 ) != 0 )
+        K |= 1 << 17;
+
+      /********************************/
+      /* SYMMETRICAL SMOOTHING        */
+      /* Selector Bit:  11            */
+      /* Return Bit(s): 18            */
+      /*                              */
+      /* The only smoothing method FreeType supports unless someone sets */
+      /* FT_LOAD_TARGET_MONO.                                            */
+      if ( ( args[0] & 2048 ) != 0 )
+        K |= 1 << 18;
+
+      /********************************/
+      /* CLEARTYPE HINTING AND        */
+      /* GRAYSCALE RENDERING          */
+      /* Selector Bit:  12            */
+      /* Return Bit(s): 19            */
+      /*                              */
+      /* Grayscale rendering is what FreeType does anyway unless someone */
+      /* sets FT_LOAD_TARGET_MONO or FT_LOAD_TARGET_LCD(_V)              */
+      if ( ( args[0] & 4096 ) != 0 && exc->grayscale_cleartype )
+        K |= 1 << 19;
+    }
+#endif
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+
+    if ( SUBPIXEL_HINTING_INFINALITY                          &&
+         exc->rasterizer_version >= TT_INTERPRETER_VERSION_35 )
+    {
+
+      if ( exc->rasterizer_version >= 37 )
+      {
+        /********************************/
+        /* HINTING FOR SUBPIXEL         */
+        /* Selector Bit:  6             */
+        /* Return Bit(s): 13            */
+        /*                              */
+        if ( ( args[0] & 64 ) != 0 && exc->subpixel_hinting )
+          K |= 1 << 13;
+
+        /********************************/
+        /* COMPATIBLE WIDTHS ENABLED    */
+        /* Selector Bit:  7             */
+        /* Return Bit(s): 14            */
+        /*                              */
+        /* Functionality still needs to be added */
+        if ( ( args[0] & 128 ) != 0 && exc->compatible_widths )
+          K |= 1 << 14;
+
+        /********************************/
+        /* VERTICAL LCD SUBPIXELS?      */
+        /* Selector Bit:  8             */
+        /* Return Bit(s): 15            */
+        /*                              */
+        /* Functionality still needs to be added */
+        if ( ( args[0] & 256 ) != 0 && exc->vertical_lcd )
+          K |= 1 << 15;
+
+        /********************************/
+        /* HINTING FOR BGR?             */
+        /* Selector Bit:  9             */
+        /* Return Bit(s): 16            */
+        /*                              */
+        /* Functionality still needs to be added */
+        if ( ( args[0] & 512 ) != 0 && exc->bgr )
+          K |= 1 << 16;
+
+        if ( exc->rasterizer_version >= 38 )
+        {
+          /********************************/
+          /* SUBPIXEL POSITIONED?         */
+          /* Selector Bit:  10            */
+          /* Return Bit(s): 17            */
+          /*                              */
+          /* Functionality still needs to be added */
+          if ( ( args[0] & 1024 ) != 0 && exc->subpixel_positioned )
+            K |= 1 << 17;
+
+          /********************************/
+          /* SYMMETRICAL SMOOTHING        */
+          /* Selector Bit:  11            */
+          /* Return Bit(s): 18            */
+          /*                              */
+          /* Functionality still needs to be added */
+          if ( ( args[0] & 2048 ) != 0 && exc->symmetrical_smoothing )
+            K |= 1 << 18;
+
+          /********************************/
+          /* GRAY CLEARTYPE               */
+          /* Selector Bit:  12            */
+          /* Return Bit(s): 19            */
+          /*                              */
+          /* Functionality still needs to be added */
+          if ( ( args[0] & 4096 ) != 0 && exc->gray_cleartype )
+            K |= 1 << 19;
+        }
+      }
+    }
+
+#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
+
+    args[0] = K;
+  }
+
+
+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* GETVARIATION[]: get normalized variation (blend) coordinates          */
+  /* Opcode range: 0x91                                                    */
+  /* Stack:        --> f2.14...                                            */
+  /*                                                                       */
+  /* XXX: UNDOCUMENTED!  There is no official documentation from Apple for */
+  /*      this bytecode instruction.  Active only if a font has GX         */
+  /*      variation axes.                                                  */
+  /*                                                                       */
+  static void
+  Ins_GETVARIATION( TT_ExecContext  exc,
+                    FT_Long*        args )
+  {
+    FT_UInt    num_axes = exc->face->blend->num_axis;
+    FT_Fixed*  coords   = exc->face->blend->normalizedcoords;
+
+    FT_UInt  i;
+
+
+    if ( BOUNDS( num_axes, exc->stackSize + 1 - exc->top ) )
+    {
+      exc->error = FT_THROW( Stack_Overflow );
+      return;
+    }
+
+    for ( i = 0; i < num_axes; i++ )
+      args[i] = coords[i] >> 2; /* convert 16.16 to 2.14 format */
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* GETDATA[]:    no idea what this is good for                           */
+  /* Opcode range: 0x92                                                    */
+  /* Stack:        --> 17                                                  */
+  /*                                                                       */
+  /* XXX: UNDOCUMENTED!  There is no documentation from Apple for this     */
+  /*      very weird bytecode instruction.                                 */
+  /*                                                                       */
+  static void
+  Ins_GETDATA( FT_Long*  args )
+  {
+    args[0] = 17;
+  }
+
+#endif /* TT_CONFIG_OPTION_GX_VAR_SUPPORT */
+
+
+  static void
+  Ins_UNKNOWN( TT_ExecContext  exc )
+  {
+    TT_DefRecord*  def   = exc->IDefs;
+    TT_DefRecord*  limit = def + exc->numIDefs;
+
+
+    for ( ; def < limit; def++ )
+    {
+      if ( (FT_Byte)def->opc == exc->opcode && def->active )
+      {
+        TT_CallRec*  call;
+
+
+        if ( exc->callTop >= exc->callSize )
+        {
+          exc->error = FT_THROW( Stack_Overflow );
+          return;
+        }
+
+        call = exc->callStack + exc->callTop++;
+
+        call->Caller_Range = exc->curRange;
+        call->Caller_IP    = exc->IP + 1;
+        call->Cur_Count    = 1;
+        call->Def          = def;
+
+        Ins_Goto_CodeRange( exc, def->range, def->start );
+
+        exc->step_ins = FALSE;
+        return;
+      }
+    }
+
+    exc->error = FT_THROW( Invalid_Opcode );
+  }
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* RUN                                                                   */
+  /*                                                                       */
+  /*  This function executes a run of opcodes.  It will exit in the        */
+  /*  following cases:                                                     */
+  /*                                                                       */
+  /*  - Errors (in which case it returns FALSE).                           */
+  /*                                                                       */
+  /*  - Reaching the end of the main code range (returns TRUE).            */
+  /*    Reaching the end of a code range within a function call is an      */
+  /*    error.                                                             */
+  /*                                                                       */
+  /*  - After executing one single opcode, if the flag `Instruction_Trap'  */
+  /*    is set to TRUE (returns TRUE).                                     */
+  /*                                                                       */
+  /*  On exit with TRUE, test IP < CodeSize to know whether it comes from  */
+  /*  an instruction trap or a normal termination.                         */
+  /*                                                                       */
+  /*                                                                       */
+  /*  Note: The documented DEBUG opcode pops a value from the stack.  This */
+  /*        behaviour is unsupported; here a DEBUG opcode is always an     */
+  /*        error.                                                         */
+  /*                                                                       */
+  /*                                                                       */
+  /* THIS IS THE INTERPRETER'S MAIN LOOP.                                  */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /* documentation is in ttinterp.h */
+
+  FT_EXPORT_DEF( FT_Error )
+  TT_RunIns( TT_ExecContext  exc )
+  {
+    FT_Long    ins_counter = 0;  /* executed instructions counter */
+    FT_UShort  i;
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+    FT_Byte    opcode_pattern[1][2] = {
+                  /* #8 TypeMan Talk Align */
+                  {
+                    0x06, /* SPVTL   */
+                    0x7D, /* RDTG    */
+                  },
+                };
+    FT_UShort  opcode_patterns   = 1;
+    FT_UShort  opcode_pointer[1] = { 0 };
+    FT_UShort  opcode_size[1]    = { 1 };
+#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
+
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+    exc->iup_called = FALSE;
+#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
+    /* Toggle backwards compatibility according to what font says, except  */
+    /* when it's a `tricky' font that heavily relies on the interpreter to */
+    /* render glyphs correctly, e.g. DFKai-SB.  Backwards compatibility    */
+    /* hacks may break it.                                                 */
+    if ( SUBPIXEL_HINTING_MINIMAL          &&
+         !FT_IS_TRICKY( &exc->face->root ) )
+      exc->backwards_compatibility = !( exc->GS.instruct_control & 4 );
+    else
+      exc->backwards_compatibility = FALSE;
+
+    exc->iupx_called = FALSE;
+    exc->iupy_called = FALSE;
+#endif
+
+    /* set PPEM and CVT functions */
+    exc->tt_metrics.ratio = 0;
+    if ( exc->metrics.x_ppem != exc->metrics.y_ppem )
+    {
+      /* non-square pixels, use the stretched routines */
+      exc->func_cur_ppem  = Current_Ppem_Stretched;
+      exc->func_read_cvt  = Read_CVT_Stretched;
+      exc->func_write_cvt = Write_CVT_Stretched;
+      exc->func_move_cvt  = Move_CVT_Stretched;
+    }
+    else
+    {
+      /* square pixels, use normal routines */
+      exc->func_cur_ppem  = Current_Ppem;
+      exc->func_read_cvt  = Read_CVT;
+      exc->func_write_cvt = Write_CVT;
+      exc->func_move_cvt  = Move_CVT;
+    }
+
+    Compute_Funcs( exc );
+    Compute_Round( exc, (FT_Byte)exc->GS.round_state );
+
+    do
+    {
+      exc->opcode = exc->code[exc->IP];
+
+#ifdef FT_DEBUG_LEVEL_TRACE
+      {
+        FT_Long  cnt = FT_MIN( 8, exc->top );
+        FT_Long  n;
+
+
+        /* if tracing level is 7, show current code position */
+        /* and the first few stack elements also             */
+        FT_TRACE6(( "  " ));
+        FT_TRACE7(( "%06d ", exc->IP ));
+        FT_TRACE6(( opcode_name[exc->opcode] + 2 ));
+        FT_TRACE7(( "%*s", *opcode_name[exc->opcode] == 'A'
+                              ? 2
+                              : 12 - ( *opcode_name[exc->opcode] - '0' ),
+                              "#" ));
+        for ( n = 1; n <= cnt; n++ )
+          FT_TRACE7(( " %d", exc->stack[exc->top - n] ));
+        FT_TRACE6(( "\n" ));
+      }
+#endif /* FT_DEBUG_LEVEL_TRACE */
+
+      if ( ( exc->length = opcode_length[exc->opcode] ) < 0 )
+      {
+        if ( exc->IP + 1 >= exc->codeSize )
+          goto LErrorCodeOverflow_;
+
+        exc->length = 2 - exc->length * exc->code[exc->IP + 1];
+      }
+
+      if ( exc->IP + exc->length > exc->codeSize )
+        goto LErrorCodeOverflow_;
+
+      /* First, let's check for empty stack and overflow */
+      exc->args = exc->top - ( Pop_Push_Count[exc->opcode] >> 4 );
+
+      /* `args' is the top of the stack once arguments have been popped. */
+      /* One can also interpret it as the index of the last argument.    */
+      if ( exc->args < 0 )
+      {
+        if ( exc->pedantic_hinting )
+        {
+          exc->error = FT_THROW( Too_Few_Arguments );
+          goto LErrorLabel_;
+        }
+
+        /* push zeroes onto the stack */
+        for ( i = 0; i < Pop_Push_Count[exc->opcode] >> 4; i++ )
+          exc->stack[i] = 0;
+        exc->args = 0;
+      }
+
+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
+      if ( exc->opcode == 0x91 )
+      {
+        /* this is very special: GETVARIATION returns */
+        /* a variable number of arguments             */
+
+        /* it is the job of the application to `activate' GX handling, */
+        /* this is, calling any of the GX API functions on the current */
+        /* font to select a variation instance                         */
+        if ( exc->face->blend )
+          exc->new_top = exc->args + exc->face->blend->num_axis;
+      }
+      else
+#endif
+        exc->new_top = exc->args + ( Pop_Push_Count[exc->opcode] & 15 );
+
+      /* `new_top' is the new top of the stack, after the instruction's */
+      /* execution.  `top' will be set to `new_top' after the `switch'  */
+      /* statement.                                                     */
+      if ( exc->new_top > exc->stackSize )
+      {
+        exc->error = FT_THROW( Stack_Overflow );
+        goto LErrorLabel_;
+      }
+
+      exc->step_ins = TRUE;
+      exc->error    = FT_Err_Ok;
+
+#ifdef TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+
+      if ( SUBPIXEL_HINTING_INFINALITY )
+      {
+        for ( i = 0; i < opcode_patterns; i++ )
+        {
+          if ( opcode_pointer[i] < opcode_size[i]                  &&
+               exc->opcode == opcode_pattern[i][opcode_pointer[i]] )
+          {
+            opcode_pointer[i] += 1;
+
+            if ( opcode_pointer[i] == opcode_size[i] )
+            {
+              FT_TRACE6(( "sph: opcode ptrn: %d, %s %s\n",
+                          i,
+                          exc->face->root.family_name,
+                          exc->face->root.style_name ));
+
+              switch ( i )
+              {
+              case 0:
+                break;
+              }
+              opcode_pointer[i] = 0;
+            }
+          }
+          else
+            opcode_pointer[i] = 0;
+        }
+      }
+
+#endif /* TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY */
+
+      {
+        FT_Long*  args   = exc->stack + exc->args;
+        FT_Byte   opcode = exc->opcode;
+
+
+        switch ( opcode )
+        {
+        case 0x00:  /* SVTCA y  */
+        case 0x01:  /* SVTCA x  */
+        case 0x02:  /* SPvTCA y */
+        case 0x03:  /* SPvTCA x */
+        case 0x04:  /* SFvTCA y */
+        case 0x05:  /* SFvTCA x */
+          Ins_SxyTCA( exc );
+          break;
+
+        case 0x06:  /* SPvTL // */
+        case 0x07:  /* SPvTL +  */
+          Ins_SPVTL( exc, args );
+          break;
+
+        case 0x08:  /* SFvTL // */
+        case 0x09:  /* SFvTL +  */
+          Ins_SFVTL( exc, args );
+          break;
+
+        case 0x0A:  /* SPvFS */
+          Ins_SPVFS( exc, args );
+          break;
+
+        case 0x0B:  /* SFvFS */
+          Ins_SFVFS( exc, args );
+          break;
+
+        case 0x0C:  /* GPv */
+          Ins_GPV( exc, args );
+          break;
+
+        case 0x0D:  /* GFv */
+          Ins_GFV( exc, args );
+          break;
+
+        case 0x0E:  /* SFvTPv */
+          Ins_SFVTPV( exc );
+          break;
+
+        case 0x0F:  /* ISECT  */
+          Ins_ISECT( exc, args );
+          break;
+
+        case 0x10:  /* SRP0 */
+          Ins_SRP0( exc, args );
+          break;
+
+        case 0x11:  /* SRP1 */
+          Ins_SRP1( exc, args );
+          break;
+
+        case 0x12:  /* SRP2 */
+          Ins_SRP2( exc, args );
+          break;
+
+        case 0x13:  /* SZP0 */
+          Ins_SZP0( exc, args );
+          break;
+
+        case 0x14:  /* SZP1 */
+          Ins_SZP1( exc, args );
+          break;
+
+        case 0x15:  /* SZP2 */
+          Ins_SZP2( exc, args );
+          break;
+
+        case 0x16:  /* SZPS */
+          Ins_SZPS( exc, args );
+          break;
+
+        case 0x17:  /* SLOOP */
+          Ins_SLOOP( exc, args );
+          break;
+
+        case 0x18:  /* RTG */
+          Ins_RTG( exc );
+          break;
+
+        case 0x19:  /* RTHG */
+          Ins_RTHG( exc );
+          break;
+
+        case 0x1A:  /* SMD */
+          Ins_SMD( exc, args );
+          break;
+
+        case 0x1B:  /* ELSE */
+          Ins_ELSE( exc );
+          break;
+
+        case 0x1C:  /* JMPR */
+          Ins_JMPR( exc, args );
+          break;
+
+        case 0x1D:  /* SCVTCI */
+          Ins_SCVTCI( exc, args );
+          break;
+
+        case 0x1E:  /* SSWCI */
+          Ins_SSWCI( exc, args );
+          break;
+
+        case 0x1F:  /* SSW */
+          Ins_SSW( exc, args );
+          break;
+
+        case 0x20:  /* DUP */
+          Ins_DUP( args );
+          break;
+
+        case 0x21:  /* POP */
+          Ins_POP();
+          break;
+
+        case 0x22:  /* CLEAR */
+          Ins_CLEAR( exc );
+          break;
+
+        case 0x23:  /* SWAP */
+          Ins_SWAP( args );
+          break;
+
+        case 0x24:  /* DEPTH */
+          Ins_DEPTH( exc, args );
+          break;
+
+        case 0x25:  /* CINDEX */
+          Ins_CINDEX( exc, args );
+          break;
+
+        case 0x26:  /* MINDEX */
+          Ins_MINDEX( exc, args );
+          break;
+
+        case 0x27:  /* ALIGNPTS */
+          Ins_ALIGNPTS( exc, args );
+          break;
+
+        case 0x28:  /* RAW */
+          Ins_UNKNOWN( exc );
+          break;
+
+        case 0x29:  /* UTP */
+          Ins_UTP( exc, args );
+          break;
+
+        case 0x2A:  /* LOOPCALL */
+          Ins_LOOPCALL( exc, args );
+          break;
+
+        case 0x2B:  /* CALL */
+          Ins_CALL( exc, args );
+          break;
+
+        case 0x2C:  /* FDEF */
+          Ins_FDEF( exc, args );
+          break;
+
+        case 0x2D:  /* ENDF */
+          Ins_ENDF( exc );
+          break;
+
+        case 0x2E:  /* MDAP */
+        case 0x2F:  /* MDAP */
+          Ins_MDAP( exc, args );
+          break;
+
+        case 0x30:  /* IUP */
+        case 0x31:  /* IUP */
+          Ins_IUP( exc );
+          break;
+
+        case 0x32:  /* SHP */
+        case 0x33:  /* SHP */
+          Ins_SHP( exc );
+          break;
+
+        case 0x34:  /* SHC */
+        case 0x35:  /* SHC */
+          Ins_SHC( exc, args );
+          break;
+
+        case 0x36:  /* SHZ */
+        case 0x37:  /* SHZ */
+          Ins_SHZ( exc, args );
+          break;
+
+        case 0x38:  /* SHPIX */
+          Ins_SHPIX( exc, args );
+          break;
+
+        case 0x39:  /* IP    */
+          Ins_IP( exc );
+          break;
+
+        case 0x3A:  /* MSIRP */
+        case 0x3B:  /* MSIRP */
+          Ins_MSIRP( exc, args );
+          break;
+
+        case 0x3C:  /* AlignRP */
+          Ins_ALIGNRP( exc );
+          break;
+
+        case 0x3D:  /* RTDG */
+          Ins_RTDG( exc );
+          break;
+
+        case 0x3E:  /* MIAP */
+        case 0x3F:  /* MIAP */
+          Ins_MIAP( exc, args );
+          break;
+
+        case 0x40:  /* NPUSHB */
+          Ins_NPUSHB( exc, args );
+          break;
+
+        case 0x41:  /* NPUSHW */
+          Ins_NPUSHW( exc, args );
+          break;
+
+        case 0x42:  /* WS */
+          Ins_WS( exc, args );
+          break;
+
+        case 0x43:  /* RS */
+          Ins_RS( exc, args );
+          break;
+
+        case 0x44:  /* WCVTP */
+          Ins_WCVTP( exc, args );
+          break;
+
+        case 0x45:  /* RCVT */
+          Ins_RCVT( exc, args );
+          break;
+
+        case 0x46:  /* GC */
+        case 0x47:  /* GC */
+          Ins_GC( exc, args );
+          break;
+
+        case 0x48:  /* SCFS */
+          Ins_SCFS( exc, args );
+          break;
+
+        case 0x49:  /* MD */
+        case 0x4A:  /* MD */
+          Ins_MD( exc, args );
+          break;
+
+        case 0x4B:  /* MPPEM */
+          Ins_MPPEM( exc, args );
+          break;
+
+        case 0x4C:  /* MPS */
+          Ins_MPS( exc, args );
+          break;
+
+        case 0x4D:  /* FLIPON */
+          Ins_FLIPON( exc );
+          break;
+
+        case 0x4E:  /* FLIPOFF */
+          Ins_FLIPOFF( exc );
+          break;
+
+        case 0x4F:  /* DEBUG */
+          Ins_DEBUG( exc );
+          break;
+
+        case 0x50:  /* LT */
+          Ins_LT( args );
+          break;
+
+        case 0x51:  /* LTEQ */
+          Ins_LTEQ( args );
+          break;
+
+        case 0x52:  /* GT */
+          Ins_GT( args );
+          break;
+
+        case 0x53:  /* GTEQ */
+          Ins_GTEQ( args );
+          break;
+
+        case 0x54:  /* EQ */
+          Ins_EQ( args );
+          break;
+
+        case 0x55:  /* NEQ */
+          Ins_NEQ( args );
+          break;
+
+        case 0x56:  /* ODD */
+          Ins_ODD( exc, args );
+          break;
+
+        case 0x57:  /* EVEN */
+          Ins_EVEN( exc, args );
+          break;
+
+        case 0x58:  /* IF */
+          Ins_IF( exc, args );
+          break;
+
+        case 0x59:  /* EIF */
+          Ins_EIF();
+          break;
+
+        case 0x5A:  /* AND */
+          Ins_AND( args );
+          break;
+
+        case 0x5B:  /* OR */
+          Ins_OR( args );
+          break;
+
+        case 0x5C:  /* NOT */
+          Ins_NOT( args );
+          break;
+
+        case 0x5D:  /* DELTAP1 */
+          Ins_DELTAP( exc, args );
+          break;
+
+        case 0x5E:  /* SDB */
+          Ins_SDB( exc, args );
+          break;
+
+        case 0x5F:  /* SDS */
+          Ins_SDS( exc, args );
+          break;
+
+        case 0x60:  /* ADD */
+          Ins_ADD( args );
+          break;
+
+        case 0x61:  /* SUB */
+          Ins_SUB( args );
+          break;
+
+        case 0x62:  /* DIV */
+          Ins_DIV( exc, args );
+          break;
+
+        case 0x63:  /* MUL */
+          Ins_MUL( args );
+          break;
+
+        case 0x64:  /* ABS */
+          Ins_ABS( args );
+          break;
+
+        case 0x65:  /* NEG */
+          Ins_NEG( args );
+          break;
+
+        case 0x66:  /* FLOOR */
+          Ins_FLOOR( args );
+          break;
+
+        case 0x67:  /* CEILING */
+          Ins_CEILING( args );
+          break;
+
+        case 0x68:  /* ROUND */
+        case 0x69:  /* ROUND */
+        case 0x6A:  /* ROUND */
+        case 0x6B:  /* ROUND */
+          Ins_ROUND( exc, args );
+          break;
+
+        case 0x6C:  /* NROUND */
+        case 0x6D:  /* NROUND */
+        case 0x6E:  /* NRRUND */
+        case 0x6F:  /* NROUND */
+          Ins_NROUND( exc, args );
+          break;
+
+        case 0x70:  /* WCVTF */
+          Ins_WCVTF( exc, args );
+          break;
+
+        case 0x71:  /* DELTAP2 */
+        case 0x72:  /* DELTAP3 */
+          Ins_DELTAP( exc, args );
+          break;
+
+        case 0x73:  /* DELTAC0 */
+        case 0x74:  /* DELTAC1 */
+        case 0x75:  /* DELTAC2 */
+          Ins_DELTAC( exc, args );
+          break;
+
+        case 0x76:  /* SROUND */
+          Ins_SROUND( exc, args );
+          break;
+
+        case 0x77:  /* S45Round */
+          Ins_S45ROUND( exc, args );
+          break;
+
+        case 0x78:  /* JROT */
+          Ins_JROT( exc, args );
+          break;
+
+        case 0x79:  /* JROF */
+          Ins_JROF( exc, args );
+          break;
+
+        case 0x7A:  /* ROFF */
+          Ins_ROFF( exc );
+          break;
+
+        case 0x7B:  /* ???? */
+          Ins_UNKNOWN( exc );
+          break;
+
+        case 0x7C:  /* RUTG */
+          Ins_RUTG( exc );
+          break;
+
+        case 0x7D:  /* RDTG */
+          Ins_RDTG( exc );
+          break;
+
+        case 0x7E:  /* SANGW */
+          Ins_SANGW();
+          break;
+
+        case 0x7F:  /* AA */
+          Ins_AA();
+          break;
+
+        case 0x80:  /* FLIPPT */
+          Ins_FLIPPT( exc );
+          break;
+
+        case 0x81:  /* FLIPRGON */
+          Ins_FLIPRGON( exc, args );
+          break;
+
+        case 0x82:  /* FLIPRGOFF */
+          Ins_FLIPRGOFF( exc, args );
+          break;
+
+        case 0x83:  /* UNKNOWN */
+        case 0x84:  /* UNKNOWN */
+          Ins_UNKNOWN( exc );
+          break;
+
+        case 0x85:  /* SCANCTRL */
+          Ins_SCANCTRL( exc, args );
+          break;
+
+        case 0x86:  /* SDPvTL */
+        case 0x87:  /* SDPvTL */
+          Ins_SDPVTL( exc, args );
+          break;
+
+        case 0x88:  /* GETINFO */
+          Ins_GETINFO( exc, args );
+          break;
+
+        case 0x89:  /* IDEF */
+          Ins_IDEF( exc, args );
+          break;
+
+        case 0x8A:  /* ROLL */
+          Ins_ROLL( args );
+          break;
+
+        case 0x8B:  /* MAX */
+          Ins_MAX( args );
+          break;
+
+        case 0x8C:  /* MIN */
+          Ins_MIN( args );
+          break;
+
+        case 0x8D:  /* SCANTYPE */
+          Ins_SCANTYPE( exc, args );
+          break;
+
+        case 0x8E:  /* INSTCTRL */
+          Ins_INSTCTRL( exc, args );
+          break;
+
+        case 0x8F:  /* ADJUST */
+        case 0x90:  /* ADJUST */
+          Ins_UNKNOWN( exc );
+          break;
+
+#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT
+        case 0x91:
+          /* it is the job of the application to `activate' GX handling, */
+          /* this is, calling any of the GX API functions on the current */
+          /* font to select a variation instance                         */
+          if ( exc->face->blend )
+            Ins_GETVARIATION( exc, args );
+          else
+            Ins_UNKNOWN( exc );
+          break;
+
+        case 0x92:
+          /* there is at least one MS font (LaoUI.ttf version 5.01) that */
+          /* uses IDEFs for 0x91 and 0x92; for this reason we activate   */
+          /* GETDATA for GX fonts only, similar to GETVARIATION          */
+          if ( exc->face->blend )
+            Ins_GETDATA( args );
+          else
+            Ins_UNKNOWN( exc );
+          break;
+#endif
+
+        default:
+          if ( opcode >= 0xE0 )
+            Ins_MIRP( exc, args );
+          else if ( opcode >= 0xC0 )
+            Ins_MDRP( exc, args );
+          else if ( opcode >= 0xB8 )
+            Ins_PUSHW( exc, args );
+          else if ( opcode >= 0xB0 )
+            Ins_PUSHB( exc, args );
+          else
+            Ins_UNKNOWN( exc );
+        }
+      }
+
+      if ( exc->error )
+      {
+        switch ( exc->error )
+        {
+          /* looking for redefined instructions */
+        case FT_ERR( Invalid_Opcode ):
+          {
+            TT_DefRecord*  def   = exc->IDefs;
+            TT_DefRecord*  limit = def + exc->numIDefs;
+
+
+            for ( ; def < limit; def++ )
+            {
+              if ( def->active && exc->opcode == (FT_Byte)def->opc )
+              {
+                TT_CallRec*  callrec;
+
+
+                if ( exc->callTop >= exc->callSize )
+                {
+                  exc->error = FT_THROW( Invalid_Reference );
+                  goto LErrorLabel_;
+                }
+
+                callrec = &exc->callStack[exc->callTop];
+
+                callrec->Caller_Range = exc->curRange;
+                callrec->Caller_IP    = exc->IP + 1;
+                callrec->Cur_Count    = 1;
+                callrec->Def          = def;
+
+                if ( Ins_Goto_CodeRange( exc,
+                                         def->range,
+                                         def->start ) == FAILURE )
+                  goto LErrorLabel_;
+
+                goto LSuiteLabel_;
+              }
+            }
+          }
+
+          exc->error = FT_THROW( Invalid_Opcode );
+          goto LErrorLabel_;
+
+#if 0
+          break;   /* Unreachable code warning suppression.             */
+                   /* Leave to remind in case a later change the editor */
+                   /* to consider break;                                */
+#endif
+
+        default:
+          goto LErrorLabel_;
+
+#if 0
+        break;
+#endif
+        }
+      }
+
+      exc->top = exc->new_top;
+
+      if ( exc->step_ins )
+        exc->IP += exc->length;
+
+      /* increment instruction counter and check if we didn't */
+      /* run this program for too long (e.g. infinite loops). */
+      if ( ++ins_counter > TT_CONFIG_OPTION_MAX_RUNNABLE_OPCODES )
+        return FT_THROW( Execution_Too_Long );
+
+    LSuiteLabel_:
+      if ( exc->IP >= exc->codeSize )
+      {
+        if ( exc->callTop > 0 )
+        {
+          exc->error = FT_THROW( Code_Overflow );
+          goto LErrorLabel_;
+        }
+        else
+          goto LNo_Error_;
+      }
+    } while ( !exc->instruction_trap );
+
+  LNo_Error_:
+    return FT_Err_Ok;
+
+  LErrorCodeOverflow_:
+    exc->error = FT_THROW( Code_Overflow );
+
+  LErrorLabel_:
+    /* If any errors have occurred, function tables may be broken. */
+    /* Force a re-execution of `prep' and `fpgm' tables if no      */
+    /* bytecode debugger is run.                                   */
+    if ( exc->error                          &&
+         !exc->instruction_trap              &&
+         exc->curRange == tt_coderange_glyph )
+    {
+      FT_TRACE1(( "  The interpreter returned error 0x%x\n", exc->error ));
+      exc->size->bytecode_ready = -1;
+      exc->size->cvt_ready      = -1;
+    }
+
+    return exc->error;
+  }
+
+
+#endif /* TT_USE_BYTECODE_INTERPRETER */
+
+
+/* END */
